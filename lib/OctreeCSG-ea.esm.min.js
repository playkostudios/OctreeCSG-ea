var gt=Math.pow;var rt=(a,o,t)=>new Promise((e,r)=>{var n=c=>{try{i(t.next(c))}catch(l){r(l)}},s=c=>{try{i(t.throw(c))}catch(l){r(l)}},i=c=>c.done?e(c.value):Promise.resolve(c.value).then(n,s);i((t=t.apply(a,o)).next())});var Ur=(e=>(e[e.WorkerCreationFailure=0]="WorkerCreationFailure",e[e.OperationFailure=1]="OperationFailure",e[e.DecodeFailure=2]="DecodeFailure",e))(Ur||{}),ie=class extends Error{constructor(t,e){let r;switch(t){case 0:r="Job failed (worker creation failed)";break;case 1:r="Job failed (operation exception)";break;default:r="Job failed (decode failure)"}super(`${r}: ${e}`);this.failReason=t;this.originalError=e}static WorkerCreationFailure(t){return new ie(0,""+t)}static OperationFailure(t){return new ie(1,""+t)}static DecodeFailure(t){return new ie(2,""+t)}};var ze=.3333333333333333,F=Math.PI*2,zr=Math.PI/2;import{mat3 as Kt,vec3 as L}from"gl-matrix";var De=L.create(),Te=L.create(),Ie=L.create(),yt=L.create(),Zt=[L.fromValues(1e-5,0,0),L.fromValues(0,1e-5,0),L.fromValues(0,0,1e-5),L.fromValues(-1e-5,0,0),L.fromValues(0,-1e-5,0),L.fromValues(0,0,-1e-5)],Wr=Kt.create(),Eo=4*Math.PI;function Xt(a,o){return a.slice(o,o+3)}function $r(a,o){let t=0,e=a.length;for(let r=0;r<e;r+=9){L.sub(De,Xt(a,r),o),L.sub(Te,Xt(a,r+3),o),L.sub(Ie,Xt(a,r+6),o);let n=L.length(De),s=L.length(Te),i=L.length(Ie);Kt.set(Wr,De[0],Te[0],Ie[0],De[1],Te[1],Ie[1],De[2],Te[2],Ie[2]),t+=2*Math.atan2(Kt.determinant(Wr),n*s*i+L.dot(De,Te)*i+L.dot(Te,Ie)*n+L.dot(De,Ie)*s)}return Math.round(t/Eo)}function Lr(a,o,t){if(L.copy(yt,o),$r(a,yt)!==0)return!0;if(t){for(let e of Zt)if(L.add(yt,o,e),$r(a,yt)!==0)return!0}return!1}function Qt(a){let o=new Float32Array(a.length*3*3),t=0;for(let e of a){let r=e.triangle;o.set(r.a,t),t+=3,o.set(r.b,t),t+=3,o.set(r.c,t),t+=3}return o}import{vec2 as We,vec3 as b}from"gl-matrix";var A=b.create(),G=b.create(),$e=b.create();function Fo(a,o,t={coplanar:!1,source:b.create(),target:b.create()}){let e=t,r=a.a,n=a.b,s=a.c,i=o.a,c=o.b,l=o.c;b.sub(A,i,l),b.sub(G,c,l);let u=b.cross(b.create(),A,G);b.sub(A,r,l);let m=b.dot(A,u);b.sub(A,n,l);let f=b.dot(A,u);b.sub(A,s,l);let h=b.dot(A,u);if(m*f>0&&m*h>0)return!1;b.sub(A,n,r),b.sub(G,s,r);let g=b.cross(b.create(),A,G);b.sub(A,i,s);let p=b.dot(A,g);b.sub(A,c,s);let d=b.dot(A,g);b.sub(A,l,s);let y=b.dot(A,g);return p*d>0&&p*y>0?!1:(e.N2=u,e.N1=g,m>0?f>0?ue(s,r,n,i,l,c,p,y,d,e):h>0?ue(n,s,r,i,l,c,p,y,d,e):ue(r,n,s,i,c,l,p,d,y,e):m<0?f<0?ue(s,r,n,i,c,l,p,d,y,e):h<0?ue(n,s,r,i,c,l,p,d,y,e):ue(r,n,s,i,l,c,p,y,d,e):f<0?h>=0?ue(n,s,r,i,l,c,p,y,d,e):ue(r,n,s,i,c,l,p,d,y,e):f>0?h>0?ue(r,n,s,i,l,c,p,y,d,e):ue(n,s,r,i,c,l,p,d,y,e):h>0?ue(s,r,n,i,c,l,p,d,y,e):h<0?ue(s,r,n,i,l,c,p,y,d,e):(e.coplanar=!0,Hr(r,n,s,i,c,l,g)))}function ue(a,o,t,e,r,n,s,i,c,l){return s>0?i>0?me(a,t,o,n,e,r,l):c>0?me(a,t,o,r,n,e,l):me(a,o,t,e,r,n,l):s<0?i<0?me(a,o,t,n,e,r,l):c<0?me(a,o,t,r,n,e,l):me(a,t,o,e,r,n,l):i<0?c>=0?me(a,t,o,r,n,e,l):me(a,o,t,e,r,n,l):i>0?c>0?me(a,t,o,e,r,n,l):me(a,o,t,r,n,e,l):c>0?me(a,o,t,n,e,r,l):c<0?me(a,t,o,n,e,r,l):(l.coplanar=!0,Hr(a,o,t,e,r,n,l.N1))}function Hr(a,o,t,e,r,n,s){let i=We.create(),c=We.create(),l=We.create(),u=We.create(),m=We.create(),f=We.create(),h=s[0]<0?-s[0]:s[0],g=s[1]<0?-s[1]:s[1],p=s[2]<0?-s[2]:s[2];return h>p&&h>=g?(i[0]=o[2],i[1]=o[1],c[0]=a[2],c[1]=a[1],l[0]=t[2],l[1]=t[1],u[0]=r[2],u[1]=r[1],m[0]=e[2],m[1]=e[1],f[0]=n[2],f[1]=n[1]):g>p&&g>=h?(i[0]=o[0],i[1]=o[2],c[0]=a[0],c[1]=a[2],l[0]=t[0],l[1]=t[2],u[0]=r[0],u[1]=r[2],m[0]=e[0],m[1]=e[2],f[0]=n[0],f[1]=n[2]):(i[0]=a[0],i[1]=a[1],c[0]=o[0],c[1]=o[1],l[0]=t[0],l[1]=t[1],u[0]=e[0],u[1]=e[1],m[0]=r[0],m[1]=r[1],f[0]=n[0],f[1]=n[1]),No(i,c,l,u,m,f)}function No(a,o,t,e,r,n){return T(a,o,t)<0?T(e,r,n)<0?vt(a,t,o,e,n,r):vt(a,t,o,e,r,n):T(e,r,n)<0?vt(a,o,t,e,n,r):vt(a,o,t,e,r,n)}function T(a,o,t){return(a[0]-t[0])*(o[1]-t[1])-(a[1]-t[1])*(o[0]-t[1])}function vt(a,o,t,e,r,n){return T(e,r,a)>=0?T(r,n,a)>=0?T(n,e,a)>=0?!0:qt(a,o,t,e,n):T(n,e,a)>=0?qt(a,o,t,n,r):er(a,o,t,e,r,n):T(r,n,a)>=0?T(n,e,a)>=0?qt(a,o,n,r,e):er(a,o,t,r,n,e):er(a,o,t,n,e,r)}function qt(a,o,t,e,r){if(T(r,e,o)>=0){if(T(a,e,o)>=0)return T(a,o,r)>=0;if(T(o,t,e)>=0)return T(t,a,e)>=0}else if(T(r,e,t)>=0&&T(a,e,t)>=0)return T(a,t,r)>=0||T(o,t,r)>=0;return!1}function er(a,o,t,e,r,n){if(T(n,e,o)>=0){if(T(n,r,o)<=0){if(T(a,e,o)>0)return T(a,r,o)<=0;if(T(a,e,t)>=0)return T(o,t,e)>=0}else if(T(a,r,o)<=0&&T(n,r,t)<=0)return T(o,t,r)>=0}else if(T(n,e,t)>=0){if(T(o,t,n)>=0)return T(a,e,t)>=0;if(T(o,t,r)>=0)return T(n,t,r)>=0}return!1}function me(a,o,t,e,r,n,s){let i;b.sub(A,o,a),b.sub(G,n,a);let c=b.cross(b.create(),A,G);if(b.sub($e,e,a),b.dot($e,c)>0){if(b.sub(A,t,a),b.cross(c,A,G),b.dot($e,c)<=0)return b.sub(G,r,a),b.cross(c,A,G),b.dot($e,c)>0?(b.sub(A,a,e),b.sub(G,a,t),i=b.dot(A,s.N2)/b.dot(G,s.N2),b.scale(A,G,i),b.sub(s.source,a,A),b.sub(A,e,a),b.sub(G,e,n),i=b.dot(A,s.N1)/b.dot(G,s.N1),b.scale(A,G,i),b.sub(s.target,e,A)):(b.sub(A,e,a),b.sub(G,e,r),i=b.dot(A,s.N1)/b.dot(G,s.N1),b.scale(A,G,i),b.sub(s.source,e,A),b.sub(A,e,a),b.sub(G,e,n),i=b.dot(A,s.N1)/b.dot(G,s.N1),b.scale(A,G,i),b.sub(s.target,e,A)),!0}else if(b.sub(G,r,a),b.cross(c,A,G),b.dot($e,c)>=0)return b.sub(A,t,a),b.cross(c,A,G),b.dot($e,c)>=0?(b.sub(A,a,e),b.sub(G,a,t),i=b.dot(A,s.N2)/b.dot(G,s.N2),b.scale(A,G,i),b.sub(s.source,a,A),b.sub(A,a,e),b.sub(G,a,o),i=b.dot(A,s.N2)/b.dot(G,s.N2),b.scale(A,G,i),b.sub(s.target,a,A)):(b.sub(A,e,a),b.sub(G,e,r),i=b.dot(A,s.N1)/b.dot(G,s.N1),b.scale(A,G,i),b.sub(s.source,e,A),b.sub(A,a,e),b.sub(G,a,o),i=b.dot(A,s.N2)/b.dot(G,s.N2),b.scale(A,G,i),b.sub(s.target,a,A)),!0;return!1}function jo(a,o,t){let e=b.sub(b.create(),a.end,a.start),r=b.sub(b.create(),o.end,o.start),n=b.sub(b.create(),a.start,o.start),s=b.dot(n,e),i=b.dot(n,r),c=b.dot(e,r),l=b.dot(e,e),u=b.dot(r,r),m=l*u-c*c,h=(i*c-s*u)/m,g=(i+h*c)/u,p=b.scaleAndAdd(e,a.start,e,h),d=b.scaleAndAdd(r,o.start,r,g),y=!1,x=!1;return 0<=h&&h<=1&&0<=g&&g<=1&&(y=!0),b.distance(p,d)<=1e-5&&(x=!0),x&&y?(t&&t.push(p,d),!0):!1}function Jr(a){return[{start:a.a,end:a.b},{start:a.b,end:a.c},{start:a.c,end:a.a}]}function Yr(a,o,t={coplanar:!1,source:b.create(),target:b.create()}){if(t.coplanar){let e=Jr(a),r=Jr(o);for(let n=0;n<3;n++)for(let s=0;s<3;s++)if(jo(e[n],r[s]))return!0}return Fo(a,o,t)}import{vec3 as Ce}from"gl-matrix";var Le=class{constructor(o,t,e){this.a=o;this.b=t;this.c=e}static copyAuxValues(o,t){o._midpoint&&(t._midpoint?Ce.copy(t._midpoint,o._midpoint):t._midpoint=Ce.clone(o._midpoint)),o._hash&&(t._hash=o._hash)}set(o,t,e){this.a=o,this.b=t,this.c=e,this._midpoint=void 0,this._hash=void 0}get midpoint(){return this._midpoint?this._midpoint:(this._midpoint=Ce.clone(this.a),Ce.add(this._midpoint,this._midpoint,this.b),Ce.add(this._midpoint,this._midpoint,this.c),Ce.scale(this._midpoint,this._midpoint,ze))}equals(o){return Ce.equals(this.a,o.a)&&Ce.equals(this.b,o.b)&&Ce.equals(this.c,o.c)}murmur_32_scramble(o){return o*=3432918353,o=o<<15|o>>17,o*=461845907,o&4294967295}murmur3_32(o,t){let e=t,r=new Uint32Array(o.buffer);for(let n of r)e^=this.murmur_32_scramble(n),e=e<<13&4294967295|e>>19,e=e*5+3864292196&4294967295;return e^=r.byteLength,e^=e>>16,e=e*2246822507&4294967295,e^=e>>13,e=e*3266489909&4294967295,e^=e>>16,e}get hash(){if(this._hash!==void 0)return this._hash;let o=new Float32Array([this.a[0]*1e5,this.a[1]*1e5,this.a[2]*1e5,this.b[0]*1e5,this.b[1]*1e5,this.b[2]*1e5,this.c[0]*1e5,this.c[1]*1e5,this.c[2]*1e5]);return this._hash=this.murmur3_32(o,3935228948),this._hash}};import{mat3 as Bo,mat4 as Xr,quat as _o,vec2 as Kr,vec3 as tr}from"gl-matrix";var v=tr.create(),O=tr.create(),se=tr.create(),B=Bo.create(),ot=Xr.create(),rr=Xr.create(),Zr=Kr.create(),Qr=Kr.create(),xt=_o.create();import{vec3 as we,vec4 as or}from"gl-matrix";var X=class{constructor(o){this.buffer=o}static fromNormal(o,t){let e=or.create();return we.copy(e,o),e[3]=t,new X(e)}get w(){return this.buffer[3]}set w(o){this.buffer[3]=o}get unsafeNormal(){return this.buffer}clone(){return new X(or.clone(this.buffer))}flip(){we.negate(this.buffer,this.buffer),this.w=-this.w}delete(){this.buffer=void 0}equals(o){return or.equals(this.buffer,o.buffer)}static calculateNormal(o,t,e){return we.sub(v,t,o),we.sub(O,e,o),we.cross(v,v,O),we.normalize(v,v),we.clone(v)}static fromPoints(o,t,e){let r=X.calculateNormal(o,t,e);return X.fromNormal(r,we.dot(r,o))}};import{mat3 as Uo,vec3 as zo}from"gl-matrix";var ke=(r=>(r[r.Number=0]="Number",r[r.Vec2=1]="Vec2",r[r.Vec3=2]="Vec3",r[r.Vec4=3]="Vec4",r))(ke||{}),nt=(t=>(t[t.Model=0]="Model",t[t.Normal=1]="Normal",t))(nt||{}),nr=(r=>(r[r.TextureCoordinate=-1]="TextureCoordinate",r[r.Color=-2]="Color",r[r.Normal=-3]="Normal",r[r.Tangent=-4]="Tangent",r))(nr||{});var Wo=0;var Z=class{constructor(o,t=0){this.intersects=!1;this.state=0;this.previousState=0;this.previousStates=[];this.valid=!0;this.coplanar=!1;this.originalValid=!1;this.newPolygon=!1;this.id=Wo++,this.vertices=o.map(e=>e.clone()),this.shared=t,this.plane=X.fromPoints(this.vertices[0].pos,this.vertices[1].pos,this.vertices[2].pos),this.triangle=new Le(this.vertices[0].pos,this.vertices[1].pos,this.vertices[2].pos)}get midpoint(){return this.triangle.midpoint}applyMatrixNoAuto(o,t,e){this.vertices.forEach(r=>{zo.transformMat4(r.pos,r.pos,t),e&&r.applyMatrix(t,e,o)}),this.plane.delete(),this.plane=X.fromPoints(this.vertices[0].pos,this.vertices[1].pos,this.vertices[2].pos),this.triangle.set(this.vertices[0].pos,this.vertices[1].pos,this.vertices[2].pos)}applyMatrix(o,t,e){let r,n=o.get(this.shared);if(n){for(let s of n)if(s.transformable===1){r=e||Uo.normalFromMat4(B,t);break}}this.applyMatrixNoAuto(n,t,r)}reset(o=!0){this.intersects=!1,this.state=0,this.previousState=0,this.previousStates.length=0,this.valid=!0,this.coplanar=!1,o&&(this.originalValid=!1),this.newPolygon=!1}setState(o,t){this.state!==t&&(this.previousState=this.state,this.state!==0&&this.previousStates.push(this.state),this.state=o)}checkAllStates(o){if(this.state!==o||this.previousState!==o&&this.previousState!==0)return!1;for(let t of this.previousStates)if(t!==o)return!1;return!0}setInvalid(){this.valid=!1}setValid(){this.valid=!0}clone(){let o=new Z(this.vertices.map(t=>t.clone()),this.shared);return o.intersects=this.intersects,o.valid=this.valid,o.coplanar=this.coplanar,o.state=this.state,o.originalValid=this.originalValid,o.newPolygon=this.newPolygon,o.previousState=this.previousState,o.previousStates=this.previousStates.slice(),Le.copyAuxValues(this.triangle,o.triangle),o}flip(o){let t=o.get(this.shared);this.vertices.reverse().forEach(r=>r.flip(t));let e=this.triangle.a;this.triangle.a=this.triangle.c,this.triangle.c=e,this.plane.flip()}delete(){this.vertices.forEach(o=>o.delete()),this.vertices.length=0,this.plane&&(this.plane.delete(),this.plane=void 0),this.triangle=void 0,this.shared=0,this.setInvalid()}};import{vec3 as Re}from"gl-matrix";var ce=(n=>(n[n.Undecided=0]="Undecided",n[n.Back=void 0]="Back",n[n.Front=void 0]="Front",n[n.CoplanarBack=3]="CoplanarBack",n[n.CoplanarFront=4]="CoplanarFront",n))(ce||{}),qr=0,sr=1,Pt=2,eo=3;function oo(a,o,t,e=[]){let r=t.get(a.shared),n={polygon:a,type:ce.Undecided},s=0,i=[];for(let c of a.vertices){let l=Re.dot(o.unsafeNormal,c.pos)-o.w,u=l<-1e-5?Pt:l>1e-5?sr:qr;s|=u,i.push(u)}switch(s){case qr:n.type=Re.dot(o.unsafeNormal,a.plane.unsafeNormal)>0?ce.CoplanarFront:ce.CoplanarBack,e.push(n);break;case sr:n.type=ce.Front,e.push(n);break;case Pt:n.type=ce.Back,e.push(n);break;case eo:{let c=[],l=[],u=a.vertices.length;for(let m=0;m<u;m++){let f=(m+1)%u,h=i[m],g=i[f],p=a.vertices[m],d=a.vertices[f];if(h!==Pt&&c.push(p),h!==sr&&l.push(h!=Pt?p.clone():p),(h|g)===eo){Re.sub(v,d.pos,p.pos);let y=(o.w-Re.dot(o.unsafeNormal,p.pos))/Re.dot(o.unsafeNormal,v),x=p.interpolate(d,y,r);c.push(x),l.push(x.clone())}}if(c.length>3)for(let m of to(c))e.push({polygon:new Z(m,a.shared),type:ce.Front});else c.length===3&&e.push({polygon:new Z(c,a.shared),type:ce.Front});if(l.length>3)for(let m of to(l))e.push({polygon:new Z(m,a.shared),type:ce.Back});else l.length===3&&e.push({polygon:new Z(l,a.shared),type:ce.Back});break}}return e.length==0&&e.push(n),e}function to(a){let o=[];if(a.length>4){console.warn(`[splitPolygonArr] arr.length (${a.length}) > 4`);for(let t=3;t<=a.length;t++)o.push([a[0].clone(),a[t-2].clone(),a[t-1].clone()])}else Re.squaredDistance(a[0].pos,a[2].pos)<=Re.squaredDistance(a[1].pos,a[3].pos)?o.push([a[0].clone(),a[1].clone(),a[2].clone()],[a[0].clone(),a[2].clone(),a[3].clone()]):o.push([a[0].clone(),a[1].clone(),a[3].clone()],[a[1].clone(),a[2].clone(),a[3].clone()]);return o}import{vec3 as de}from"gl-matrix";var ar=[0,0,0],ir=[0,0,0],cr=[0,0,0],lr=[0,0,0],ur=[0,0,0],mr=1e-8;function Ct(a,o,t=de.create()){de.sub(ar,o.b,o.a),de.sub(ir,o.c,o.a),de.cross(cr,a.direction,ir);let e=de.dot(ar,cr);if(e>-mr&&e<mr)return null;de.sub(lr,a.origin,o.a);let r=1/e,n=r*de.dot(lr,cr);if(n<0||n>1)return null;de.cross(ur,lr,ar);let s=r*de.dot(a.direction,ur);if(s<0||n+s>1)return null;let i=r*de.dot(ir,ur);return i>mr?de.scaleAndAdd(t,a.origin,a.direction,i):null}import{vec3 as S}from"gl-matrix";var W=S.create(),Q=S.create(),Je=S.create(),At=S.fromValues(1,0,0),St=S.fromValues(0,1,0),wt=S.fromValues(0,0,1),$o=S.create(),Lo=S.create(),Jo=S.create(),Ho=S.create(),Yo=S.create(),Xo=S.create(),Ko=S.create(),Zo=S.create(),Mt=S.create(),Ot=S.create(),Vt=S.create();function fe(a,o){return a<o?a:o}function he(a,o){return a>o?a:o}var _=class{constructor(o=S.create(),t=S.create()){this.min=o;this.max=t}clone(){return new _(S.clone(this.min),S.clone(this.max))}expandByPoint(o){S.min(this.min,this.min,o),S.max(this.max,this.max,o)}expandByScalar(o){S.set(W,o,o,o),S.sub(this.min,this.min,W),S.add(this.max,this.max,W)}_project(o,t){let e=o.length,r=S.dot(o[0],t),n=r;for(let s=1;s<e;s++){let i=S.dot(o[s],t);r=Math.min(r,i),n=Math.max(n,i)}return[r,n]}_testNormal(o,t,e,r){let[n,s]=this._project(r,e);return s<o||n>t}_testECP(o,t,e,r){let n=S.cross(W,o,t),[s,i]=this._project(r,n),[c,l]=this._project(e,n);return i<c||s>l}intersectsTriangle(o){let t=[o.a,o.b,o.c];if(this._testNormal(this.min[0],this.max[0],At,t)||this._testNormal(this.min[1],this.max[1],St,t)||this._testNormal(this.min[2],this.max[2],wt,t))return!1;let e=X.calculateNormal(o.a,o.b,o.c),r=S.dot(e,o.a),n=[S.set($o,this.min[0],this.max[1],this.min[2]),S.set(Lo,this.max[0],this.max[1],this.min[2]),S.set(Jo,this.min[0],this.max[1],this.max[2]),S.set(Ho,this.max[0],this.max[1],this.max[2]),S.set(Yo,this.min[0],this.min[1],this.min[2]),S.set(Xo,this.max[0],this.min[1],this.min[2]),S.set(Ko,this.min[0],this.min[1],this.max[2]),S.set(Zo,this.max[0],this.min[1],this.max[2])],[s,i]=this._project(n,e);return i<r||s>r?!1:(S.sub(Mt,o.a,o.b),S.sub(Ot,o.b,o.c),S.sub(Vt,o.c,o.a),!(this._testECP(Mt,At,t,n)||this._testECP(Mt,St,t,n)||this._testECP(Mt,wt,t,n)||this._testECP(Ot,At,t,n)||this._testECP(Ot,St,t,n)||this._testECP(Ot,wt,t,n)||this._testECP(Vt,At,t,n)||this._testECP(Vt,St,t,n)||this._testECP(Vt,wt,t,n)))}intersectsBox(o){return!(this.min[0]>o.max[0]||this.max[0]<o.min[0]||this.min[1]>o.max[1]||this.max[1]<o.min[1]||this.min[2]>o.max[2]||this.max[2]<o.min[2])}intersectsRay(o){S.inverse(Je,o.direction),S.sub(W,this.min,o.origin),S.mul(W,W,Je),S.sub(Q,this.max,o.origin),S.mul(Q,Q,Je);let t=Math.max(fe(W[0],1/0),fe(Q[0],1/0));t=Math.max(fe(W[1],t),fe(Q[1],t)),t=Math.max(fe(W[2],t),fe(Q[2],t));let e=Math.min(he(W[0],0),he(Q[0],0));return e=Math.min(he(W[1],e),he(Q[1],e)),e=Math.min(he(W[2],e),he(Q[2],e)),e<t}rayIntersection(o,t){S.inverse(Je,o.direction),S.sub(W,this.min,o.origin),S.mul(W,W,Je),S.sub(Q,this.max,o.origin),S.mul(Q,Q,Je);let e=Math.max(fe(W[0],1/0),fe(Q[0],1/0));e=Math.max(fe(W[1],e),fe(Q[1],e)),e=Math.max(fe(W[2],e),fe(Q[2],e));let r=Math.min(he(W[0],0),he(Q[0],0));return r=Math.min(he(W[1],r),he(Q[1],r)),r=Math.min(he(W[2],r),he(Q[2],r)),r>=e?!1:(S.scaleAndAdd(t,o.origin,o.direction,r<0?e:r),!0)}containsPoint(o){return o[0]>=this.min[0]&&o[0]<=this.max[0]&&o[1]>=this.min[1]&&o[1]<=this.max[1]&&o[2]>=this.min[2]&&o[2]<=this.max[2]}makeEmpty(){S.set(this.min,0,0,0),S.set(this.max,0,0,0)}};import{vec3 as no}from"gl-matrix";var st=class{constructor(){this.origin=no.create();this.direction=no.fromValues(0,0,-1)}};import{mat3 as rn,vec3 as k}from"gl-matrix";function Ee(a){switch(a){case 0:return 4;case 1:return 8;case 2:return 12;case 3:return 16}throw new Error(`Unknown vertex property type ID (${a})`)}function at(a,o,t,e){switch(o){case 0:t.setFloat32(e,a);break;case 1:{let r=a;t.setFloat32(e,r[0]),e+=4,t.setFloat32(e,r[1]);break}case 2:{let r=a;t.setFloat32(e,r[0]),e+=4,t.setFloat32(e,r[1]),e+=4,t.setFloat32(e,r[2]);break}case 3:{let r=a;t.setFloat32(e,r[0]),e+=4,t.setFloat32(e,r[1]),e+=4,t.setFloat32(e,r[2]),e+=4,t.setFloat32(e,r[3]);break}}}function Gt(a,o,t,e){if(at(a.pos,2,t,e),e+=12,o){let r=0;for(let n of o)a.extra&&at(a.extra[r++],n.valueType,t,e),e+=Ee(n.valueType)}return e}var Fe=class{constructor(){this.buckets=new Map}isUnique(o){let t=o.hash,e=this.buckets.get(t);if(e){for(let r of e)if(o.equals(r))return!1;e.push(o)}else e=[o];return!0}clear(){this.buckets.clear()}};var Ne={union:{a:[{array:!0,rule:[1,3]},{array:!1,rule:1}],b:[{array:!0,rule:[1,3]},{array:!0,rule:[1,4]},{array:!1,rule:1}]},subtract:{a:[{array:!0,rule:[1,3]},{array:!0,rule:[1,4]},{array:!1,rule:1}],b:[{array:!0,rule:[2,3]},{array:!0,rule:[2,4]},{array:!0,rule:[1,4]},{array:!1,rule:2}]},intersect:{a:[{array:!0,rule:[1,3]},{array:!0,rule:[2,4]},{array:!0,rule:[2,3]},{array:!1,rule:2}],b:[{array:!0,rule:[1,4]},{array:!0,rule:[1,3]},{array:!0,rule:[2,4]},{array:!0,rule:[2,3]},{array:!1,rule:2}]}};function Dt(a,o){let t=0;if(a){let e=a.get(o);if(e)for(let r of e)t+=Ee(r.valueType)}return t}import{vec2 as hr,vec3 as Ae,vec4 as Tt}from"gl-matrix";function fr(a,o,t){return a+t*(o-a)}var C=class{constructor(o,t){this.pos=o;this.extra=t}clone(){let o;if(this.extra){let t=this.extra.length;o=new Array(t);for(let e=0;e<t;e++){let r=this.extra[e];typeof r=="number"?o[e]=r:o[e]=r.slice()}}return new C(Ae.clone(this.pos),o)}flip(o){if(o&&this.extra){let t=this.extra.length;for(let e=0;e<t;e++){let r=o[e];if(r.flippable)switch(r.valueType){case 0:this.extra[e]=-this.extra[e];break;case 1:hr.negate(this.extra[e],this.extra[e]);break;case 2:Ae.negate(this.extra[e],this.extra[e]);break;case 3:Tt.negate(this.extra[e],this.extra[e]);break}}}}applyMatrix(o,t,e){if(e&&this.extra){let r=this.extra.length;for(let n=0;n<r;n++){let s=e[n],i=s.transformable;if(i!==null)if(i===0)switch(s.valueType){case 2:Ae.transformMat4(this.extra[n],this.extra[n],o);break;case 3:Tt.transformMat4(this.extra[n],this.extra[n],o);break;default:throw new Error("Can't transform this vertex attribute with a model matrix; must be a vec3 or vec4")}else{if(s.valueType!==2)throw new Error("Can't transform this vertex attribute with a normal matrix; must be a vec3");if(t===void 0)throw new Error("Missing normal matrix");let c=this.extra[n];Ae.transformMat3(c,c,t),Ae.normalize(c,c)}}}}delete(){this.pos=void 0,this.extra=void 0}interpolate(o,t,e){let r;if(e&&this.extra){let n=this.extra.length;r=new Array(n);for(let s=0;s<n;s++){let i=this.extra[s],c=o.extra[s];switch(e[s].valueType){case 0:r[s]=fr(i,c,t);break;case 1:r[s]=hr.lerp(hr.create(),i,c,t);break;case 2:r[s]=Ae.lerp(Ae.create(),i,c,t);break;case 3:r[s]=Tt.lerp(Tt.create(),i,c,t);break}}}return new C(Ae.lerp(Ae.create(),this.pos,o.pos,t),r)}};import{vec2 as Qo,vec3 as qo,vec4 as en}from"gl-matrix";function it(a,o,t){switch(a){case 0:return o.getFloat32(t);case 1:{let e=o.getFloat32(t);t+=4;let r=o.getFloat32(t);return Qo.fromValues(e,r)}case 2:{let e=o.getFloat32(t);t+=4;let r=o.getFloat32(t);t+=4;let n=o.getFloat32(t);return qo.fromValues(e,r,n)}case 3:{let e=o.getFloat32(t);t+=4;let r=o.getFloat32(t);t+=4;let n=o.getFloat32(t);t+=4;let s=o.getFloat32(t);return en.fromValues(e,r,n,s)}}}function It(a,o,t){let e=it(2,o,t);t+=12;let r;if(a){r=[];for(let n of a)r.push(it(n.valueType,o,t)),t+=Ee(n.valueType)}return new C(e,r)}var so="Incompatible material definitions for material ID ",tn=["type","valueType","transformable","flippable"];function ao(a,o,t){let e=o.length;if(e!==t.length)throw new Error(`${so}${a}; extra attributes count doesn't match`);for(let r=0;r<e;r++){let n=o[r],s=t[r];for(let i of tn)if(n[i]!==s[i])throw new Error(`${so}${a}; attribute ${r}'s ${i} doesn't match`)}}function je(a,o){if(a===o)return a;if(a.size===o.size){let e=!0;for(let[r,n]of a){let s=o.get(r);if(!s){e=!1;break}ao(r,n,s)}if(e)return a}let t=new Map;for(let[e,r]of a){let n=o.get(e);n&&ao(e,r,n),t.set(e,r)}for(let[e,r]of o)a.has(e)||t.set(e,r);return t}var pr=k.create(),ct=k.create(),io=k.create(),He=new st,kt=k.fromValues(0,0,1),co=gt(2,32)-1,dr=!1,on=100,nn=16,sn=100;let o;var M=class{constructor(t,e,r=null){this.materials=t;this.needsRebuild=!0;this.polygons=[],this.replacedPolygons=[],this.box=e,this.subTrees=[],this.parent=r,this.level=0,this.polygonArrays=[],this.addPolygonsArrayToRoot(this.polygons)}clone(){return new M(this.materials).copy(this)}copy(t){var e;this.deletePolygonsArrayFromRoot(this.polygons),this.polygons=t.polygons.map(r=>r.clone()),this.addPolygonsArrayToRoot(this.polygons),this.replacedPolygons=t.replacedPolygons.map(r=>r.clone()),this.box=(e=t.box)==null?void 0:e.clone(),this.level=t.level,this.needsRebuild=t.needsRebuild;for(let r of t.subTrees)this.subTrees.push(new M(this.materials,void 0,this).copy(r));return this}addPolygonsArrayToRoot(t){this.parent?this.parent.addPolygonsArrayToRoot(t):this.polygonArrays.push(t)}deletePolygonsArrayFromRoot(t){if(this.parent)this.parent.deletePolygonsArrayFromRoot(t);else{let e=this.polygonArrays.indexOf(t);e>-1&&this.polygonArrays.splice(e,1)}}isEmpty(){return this.polygons.length===0}addPolygon(t,e){let r=t.triangle;return e&&!e.isUnique(r)?this:(this.box?(this.box.min[0]=Math.min(this.box.min[0],r.a[0],r.b[0],r.c[0]),this.box.min[1]=Math.min(this.box.min[1],r.a[1],r.b[1],r.c[1]),this.box.min[2]=Math.min(this.box.min[2],r.a[2],r.b[2],r.c[2]),this.box.max[0]=Math.max(this.box.max[0],r.a[0],r.b[0],r.c[0]),this.box.max[1]=Math.max(this.box.max[1],r.a[1],r.b[1],r.c[1]),this.box.max[2]=Math.max(this.box.max[2],r.a[2],r.b[2],r.c[2])):(this.box=new _,this.box.min[0]=Math.min(r.a[0],r.b[0],r.c[0]),this.box.min[1]=Math.min(r.a[1],r.b[1],r.c[1]),this.box.min[2]=Math.min(r.a[2],r.b[2],r.c[2]),this.box.max[0]=Math.max(r.a[0],r.b[0],r.c[0]),this.box.max[1]=Math.max(r.a[1],r.b[1],r.c[1]),this.box.max[2]=Math.max(r.a[2],r.b[2],r.c[2])),this.polygons.push(t),this)}getSubtreeIdx(t,e){return(e[0]>=t[0]?4:0)|(e[1]>=t[1]?2:0)|(e[2]>=t[2]?1:0)}split(t,e,r){if(this.polygons.length<=r||t>=e)return;if(!this.box)throw new Error("Octree has no box");let n=[];k.sub(ct,this.box.max,this.box.min);let s=k.scale(ct,ct,.5);for(let l=0;l<2;l++)for(let u=0;u<2;u++)for(let m=0;m<2;m++){let f=new _,h=k.set(pr,l,u,m);k.multiply(io,h,s),k.add(f.min,this.box.min,io),k.add(f.max,f.min,s),n.push(new M(this.materials,f,this))}let i=k.add(ct,this.box.max,this.box.min);k.scale(i,i,.5);let c=[];for(let l of this.polygons){let u=this.getSubtreeIdx(i,l.midpoint),m=n[u],f=m.box,[h,g,p]=l.vertices;f.containsPoint(h.pos)&&f.containsPoint(g.pos)&&f.containsPoint(p.pos)?m.polygons.push(l):c.push(l)}this.polygons.splice(0,this.polygons.length,...c);for(let l of n){let u=t+1;l.level=u,l.split(u,e,r),this.subTrees.push(l)}return this}buildTree(t,e){if(this.subTrees.length>0){console.warn("Octree is already built, but buildTree was called. A rebuild will occur");let r=this.getPolygons();for(let n of this.subTrees)n.delete(!1);this.subTrees.length=0,this.polygons.splice(0,this.polygons.length,...r)}return this.split(0,t!=null?t:nn,e!=null?e:sn),this.processTree(),this.needsRebuild=!1,this}processTree(){if(!this.isEmpty()){this.box||(this.box=new _);let e=this.polygons[0].triangle.a;k.copy(this.box.min,e),k.copy(this.box.max,e);for(let r of this.polygons)this.box.expandByPoint(r.triangle.a),this.box.expandByPoint(r.triangle.b),this.box.expandByPoint(r.triangle.c);this.expandParentBox()}for(let t of this.subTrees)t.processTree()}expandParentBox(){if(this.parent){if(!this.box)throw new Error("Octree has no box");if(!this.parent.box)throw new Error("Octree's parent has no box");this.parent.box.expandByPoint(this.box.min),this.parent.box.expandByPoint(this.box.max),this.parent.expandParentBox()}}getPolygonsIntersectingPolygon(t,e=[]){if(!this.box)throw new Error("Octree has no box");this.polygons.length>0&&this.box.intersectsTriangle(t.triangle)&&(uo(t,e,this.polygons),uo(t,e,this.replacedPolygons));for(let r of this.subTrees)r.getPolygonsIntersectingPolygon(t,e);return e}getRayPolygons(t,e){if(e)for(let r of this.replacedPolygons)e.add(r);else e=new Set(this.replacedPolygons);for(let r of this.polygons)r.valid&&r.originalValid&&e.add(r);for(let r of this.subTrees)r.box.intersectsRay(t)&&r.getRayPolygons(t,e);return e}rayIntersect(t,e=[]){if(k.squaredLength(t.direction)===0)return[];for(let r of this.getRayPolygons(t)){let n=Ct(t,r.triangle,pr);if(n){let s=k.distance(n,t.origin);e.push({distance:s,polygon:r,position:k.add(k.create(),n,t.origin)})}}return e.length&&e.sort(an),e}handlePolyIntersection(t,e,r){let n=Ct(t,e.triangle,pr);if(n){let s=k.distance(n,t.origin);(!r||s<r.distance)&&(r={distance:s,polygon:e,position:k.add(k.create(),n,t.origin)})}return r}marchingClosestRayIntersection(t){let e=null;for(let r of this.replacedPolygons)e=this.handlePolyIntersection(t,r,e);for(let r of this.polygons)r.valid&&r.originalValid&&(e=this.handlePolyIntersection(t,r,e));if(this.subTrees.length>0){let r=new Array,n=0;for(let s of this.subTrees){let i=null;if(s.box.rayIntersection(t,v)){i=k.squaredDistance(t.origin,v);let c=0;for(;c<n&&i>=r[c][1];c++);r.splice(c,0,[s,i]),n++}}for(let[s,i]of r){let c=s.marchingClosestRayIntersection(t);c&&(!e||e.distance>c.distance)&&(e=c)}}return e}closestRayIntersection(t){return this.parent===null?this.marchingClosestRayIntersection(t):this.parent.closestRayIntersection(t)}getIntersectingPolygons(t=[]){for(let e of this.polygonArrays)for(let r of e)r.valid&&r.intersects&&t.push(r);return t}getPolygons(t=[]){for(let e of this.polygonArrays)for(let r of e)r.valid&&t.indexOf(r)===-1&&t.push(r);return t}*levelPolygonsGen(){for(let t of this.polygons)t.valid&&(yield t)}get levelPolygons(){return this.levelPolygonsGen()}*treePolygonsGen(){for(let t of this.levelPolygons)yield t;for(let t of this.subTrees)for(let e of t.treePolygons)yield e}get treePolygons(){return this.treePolygonsGen()}*lowerLevelsGen(){for(let t of this.subTrees)yield t}get lowerLevels(){return this.lowerLevelsGen()}invert(){for(let t of this.polygonArrays)for(let e of t)e.valid&&e.flip(this.materials)}replacePolygon(t,e){if(Array.isArray(e)||(e=[e]),this.polygons.length>0){let r=this.polygons.indexOf(t);r>-1&&(t.originalValid?this.replacedPolygons.push(t):t.setInvalid(),this.polygons.splice(r,1,...e))}for(let r of this.subTrees)r.replacePolygon(t,e)}deletePolygonsByStateRules(t,e=!0){for(let r of this.polygonArrays)if(r.length!==0)for(let n of r.slice()){if(!n.valid||!n.intersects)continue;let s=!1;for(let i of t)if(i.array){let c=i.rule;if(c.includes(n.state)&&(n.previousState!==0&&c.includes(n.previousState)||n.previousState===0)){s=!0;let l=new Set;for(let u of c)l.add(u);l.delete(n.state);for(let u of n.previousStates)if(c.includes(u))l.delete(u);else{s=!1;break}if(s)if(l.size>0)s=!1;else break}}else if(n.checkAllStates(i.rule)){s=!0;break}if(s){let i=r.indexOf(n);i>-1&&(n.setInvalid(),r.splice(i,1)),e&&n.delete()}}}deletePolygonsByIntersection(t,e=!0){for(let r of this.polygonArrays)if(r.length!==0){for(let n of r.slice())if(n.valid&&n.intersects===t){let s=r.indexOf(n);s>-1&&(n.setInvalid(),r.splice(s,1)),e&&n.delete()}}}isPolygonIntersecting(t){if(!this.box)throw new Error("Octree has no box");return this.box.intersectsTriangle(t.triangle)}markIntersectingPolygons(t){for(let e of this.polygonArrays)for(let r of e)r.intersects=t.isPolygonIntersecting(r)}resetPolygons(t=!0){for(let e of this.polygonArrays)for(let r of e)r.reset(t)}handleIntersectingPolygons(t,e,r){if(e&&!r)throw new Error("targetOctreeBuffer must be set if using winding number");if(this.polygons.length>0){let n=this.polygons.filter(i=>i.valid&&i.intersects&&i.state===0),s;for(;s=n.pop();){if(s.state!==0||!s.valid)continue;let i=t.getPolygonsIntersectingPolygon(s);for(let c of i){let l=oo(s,c.plane,this.materials);if(l.length>1){for(let u of l){let m=u.polygon;m.intersects=s.intersects,m.newPolygon=!0,n.push(m)}this.replacePolygon(s,l.map(u=>u.polygon));break}else{let u=l[0];if(s.id!==u.polygon.id){u.polygon.intersects=s.intersects,u.polygon.newPolygon=!0,n.push(u.polygon),this.replacePolygon(s,u.polygon);break}else(u.type===ce.CoplanarFront||u.type===ce.CoplanarBack)&&(s.setState(u.type),s.coplanar=!0)}}}for(let i of this.polygons){if(!i.valid||!i.intersects)continue;if(!t.box)throw new Error("Octree has no box");let c=!1;if(t.box.containsPoint(i.midpoint))if(e)c=Lr(r,i.midpoint,i.coplanar);else{let l=k.copy(ct,i.midpoint);k.copy(He.origin,l),k.copy(kt,i.plane.unsafeNormal),k.copy(He.direction,i.plane.unsafeNormal);let u=t.closestRayIntersection(He);if(u&&k.dot(kt,u.polygon.plane.unsafeNormal)>0)c=!0;else if(i.coplanar){for(let m of Zt)if(k.add(He.origin,l,m),k.copy(kt,i.plane.unsafeNormal),k.copy(He.direction,i.plane.unsafeNormal),u=t.closestRayIntersection(He),u&&k.dot(kt,u.polygon.plane.unsafeNormal)>0){c=!0;break}}}i.setState(c?1:2)}}for(let n of this.subTrees)n.handleIntersectingPolygons(t,e,r)}delete(t=!0){if(this.polygons.length>0&&t){for(let e of this.polygons)e.delete();this.polygons.length=0}if(this.replacedPolygons.length>0&&t){for(let e of this.replacedPolygons)e.delete();this.replacedPolygons.length=0}if(this.polygonArrays&&(this.polygonArrays.length=0),this.subTrees.length){for(let e of this.subTrees)e.delete(t);this.subTrees.length=0}this.box=void 0,this.parent=null,this.level=0}dispose(t=!0){this.delete(t)}countEncodingBytes(t,e,r,n,s=0){var u;e.set(this,s),s+=5,this.box&&(s+=24);let i=new Map;for(let m of this.polygons){if(!m.valid||!m.originalValid)continue;let f=m.shared;if(f<0||f>M.maxMaterialID)throw new Error(`Invalid material ID (${f}) for polygon. Valid range: 0-${M.maxMaterialID}`);let h=((u=i.get(f))!=null?u:0)+1;i.set(f,h)}let c=new Map;for(let[m,f]of i){c.set(m,s);let h=Dt(t,m);s+=8+f*(12+h)*3}r.set(this,i),n.set(this,c);let l=this.subTrees.length;if(l>0){if(l!==8)throw new Error(`Unexpected sub-tree count. Expected 8, got ${l}`);for(let m of this.subTrees)s=m.countEncodingBytes(t,e,r,n,s)}return s}encodeBytes(t,e,r,n,s){let i=r.get(this),c=n.get(this),l=s.get(this),u=c.size;t.setUint32(i,u),i+=4;let m=this.box!==void 0,f=(m?1:0)|(this.subTrees.length>0?2:0)|(this.needsRebuild?4:0);if(t.setUint8(i,f),i++,m){let h=this.box;at(h.min,2,t,i),i+=12,at(h.max,2,t,i)}for(let[h,g]of c){let p=l.get(h);t.setUint32(p,h),p+=4,t.setUint32(p,g),p+=4,l.set(h,p)}for(let h of this.polygons){let g=h.shared,p=l.get(g),d=e.get(g);p=Gt(h.vertices[0],d,t,p),p=Gt(h.vertices[1],d,t,p),p=Gt(h.vertices[2],d,t,p),l.set(g,p)}for(let h of this.subTrees)h.encodeBytes(t,e,r,n,s)}encode(t,e){let r=new Map,n=new Map,s=new Map,i=this.countEncodingBytes(t,r,n,s),c=new ArrayBuffer(i),l=new DataView(c);return this.encodeBytes(l,t,r,n,s),e.push(c),c}static decodeBytes(t,e,r,n,s){if(e+5>r)throw new Error("Invalid octree; expected octree header, but there are not enough bytes left for it");let i=new M(s,void 0,n),c=t.getUint32(e);e+=4;let l=t.getUint8(e);e++;let u=(l&1)>0,m=(l&2)>0;if(i.needsRebuild=(l&4)>0,u){if(e+24>r)throw new Error("Invalid octree; expected octree bounding box in header, but there are not enough bytes left for it");let f=it(2,t,e);e+=12;let h=it(2,t,e);e+=12,i.box=new _(f,h)}for(let f=0;f<c;f++){if(e+6>r)throw new Error("Invalid material section; expected material section header, but there are not enough bytes left for it");let h=t.getUint32(e);e+=4;let g=t.getUint32(e);e+=4;let p=Dt(s,h),d=12+p,y=g*d*3;if(y===0)throw new Error("Invalid material section; expected at least one polygon, got none");let x=e+y;if(x>r)throw new Error("Invalid material section; expected material section polygon data, but there are not enough bytes left for it");let w=s===null?void 0:s.get(h);for(;e<x;){let D=It(w,t,e);e+=d;let $=It(w,t,e);e+=d;let j=It(w,t,e);e+=d;let H=new Z([D,$,j],h);H.originalValid=!0,i.polygons.push(H)}}if(m)for(let f=0;f<8;f++){let h;[h,e]=M.decodeBytes(t,e,r,i,s),i.subTrees.push(h)}return[i,e]}static decode(t,e){let[r,n]=M.decodeBytes(new DataView(t),0,t.byteLength,null,e);return r}getPolygonCloneCallback(t,e){for(let r of this.polygonArrays)for(let n of r)n.valid&&t(n.clone(),e)}deleteReplacedPolygons(){if(this.replacedPolygons.length>0){for(let t of this.replacedPolygons)t.delete();this.replacedPolygons.length=0}for(let t of this.subTrees)t.deleteReplacedPolygons()}markPolygonsAsOriginal(){for(let t of this.polygonArrays)for(let e of t)e.originalValid=!0}applyMatrix(t,e,r=!0,n=!1){if(this.box&&(this.box=void 0),r){if(!n)for(let s of this.materials.values()){if(s){for(let i of s)if(i.transformable===1){n=!0;break}}if(n)break}n&&!e&&(e=rn.normalFromMat4(B,t))}for(let s of this.polygons)s.valid&&s.applyMatrixNoAuto(this.materials.get(s.shared),t,e);for(let s of this.subTrees)s.applyMatrix(t,e,!1,n);r&&this.processTree()}setPolygonIndex(t){if(t!==void 0)for(let e of this.polygonArrays)for(let r of e)r.shared=t}getTriangles(t=[]){for(let e of this.getPolygons())t.push(e.triangle);return t}getRayTriangles(t,e=[]){for(let r of this.getRayPolygons(t))e.push(r.triangle);return e}static union(t,e,r){var c;let n=je(t.materials,e.materials);(t.needsRebuild||!t.box)&&t.buildTree(r==null?void 0:r.maxLevel,r==null?void 0:r.polygonsPerTree),(e.needsRebuild||!e.box)&&e.buildTree(r==null?void 0:r.maxLevel,r==null?void 0:r.polygonsPerTree);let s=new M(n),i=new Fe;return t.box.intersectsBox(e.box)&&(t.resetPolygons(!1),e.resetPolygons(!1),t.markIntersectingPolygons(e),e.markIntersectingPolygons(t),M.handleIntersectingOctrees(t,e,(c=r==null?void 0:r.useWindingNumber)!=null?c:dr),t.deleteReplacedPolygons(),e.deleteReplacedPolygons(),t.deletePolygonsByStateRules(Ne.union.a),e.deletePolygonsByStateRules(Ne.union.b)),t.getPolygonCloneCallback(s.addPolygon.bind(s),i),e.getPolygonCloneCallback(s.addPolygon.bind(s),i),i.clear(),s.markPolygonsAsOriginal(),s}static subtract(t,e,r){var c;let n=je(t.materials,e.materials);(t.needsRebuild||!t.box)&&t.buildTree(r==null?void 0:r.maxLevel,r==null?void 0:r.polygonsPerTree),(e.needsRebuild||!e.box)&&e.buildTree(r==null?void 0:r.maxLevel,r==null?void 0:r.polygonsPerTree);let s=new M(n),i=new Fe;return t.box.intersectsBox(e.box)?(t.resetPolygons(!1),e.resetPolygons(!1),t.markIntersectingPolygons(e),e.markIntersectingPolygons(t),M.handleIntersectingOctrees(t,e,(c=r==null?void 0:r.useWindingNumber)!=null?c:dr),t.deleteReplacedPolygons(),e.deleteReplacedPolygons(),t.deletePolygonsByStateRules(Ne.subtract.a),e.deletePolygonsByStateRules(Ne.subtract.b),e.deletePolygonsByIntersection(!1),e.invert(),t.getPolygonCloneCallback(s.addPolygon.bind(s),i),e.getPolygonCloneCallback(s.addPolygon.bind(s),i)):t.getPolygonCloneCallback(s.addPolygon.bind(s),i),i.clear(),s.markPolygonsAsOriginal(),s}static intersect(t,e,r){var c;let n=je(t.materials,e.materials);(t.needsRebuild||!t.box)&&t.buildTree(r==null?void 0:r.maxLevel,r==null?void 0:r.polygonsPerTree),(e.needsRebuild||!e.box)&&e.buildTree(r==null?void 0:r.maxLevel,r==null?void 0:r.polygonsPerTree);let s=new M(n),i=new Fe;return t.box.intersectsBox(e.box)&&(t.resetPolygons(!1),e.resetPolygons(!1),t.markIntersectingPolygons(e),e.markIntersectingPolygons(t),M.handleIntersectingOctrees(t,e,(c=r==null?void 0:r.useWindingNumber)!=null?c:dr),t.deleteReplacedPolygons(),e.deleteReplacedPolygons(),t.deletePolygonsByStateRules(Ne.intersect.a),e.deletePolygonsByStateRules(Ne.intersect.b),t.deletePolygonsByIntersection(!1),e.deletePolygonsByIntersection(!1),t.getPolygonCloneCallback(s.addPolygon.bind(s),i),e.getPolygonCloneCallback(s.addPolygon.bind(s),i)),i.clear(),s.markPolygonsAsOriginal(),s}static unionArray(t,e){return mo(M.union,t,e)}static subtractArray(t,e){let r=t.length;if(r===0)throw new Error("Unable to find any result octree");return r===1?t[0]:r===2?M.subtract(t[0],t[1],e):M.subtract(t[0],M.unionArray(t.slice(1),e),e)}static intersectArray(t,e){return mo(M.intersect,t,e)}static operation(t,e){let r;switch(t.op){case"union":case"subtract":case"intersect":{let n=Rt(t.objA,e),s=Rt(t.objB,e);switch(t.op){case"union":r=M.union(n,s,e);break;case"subtract":r=M.subtract(n,s,e);break;default:r=M.intersect(n,s,e)}Ye(n,s);break}case"unionArray":case"subtractArray":case"intersectArray":{let n=new Array;for(let s of t.objs)n.push(Rt(s,e));switch(t.op){case"unionArray":r=M.unionArray(n,e);break;case"subtractArray":r=M.subtractArray(n,e);break;default:r=M.intersectArray(n,e)}Ye(...n);break}default:throw new Error(`Unknown operation: ${t.op}`)}return r}static handleIntersectingOctrees(t,e,r,n=!0,s,i){r&&(n&&!s&&(s=Qt(t.getPolygons())),i||(i=Qt(e.getPolygons()))),t.handleIntersectingPolygons(e,r,i),n&&e.handleIntersectingPolygons(t,r,s),s!==void 0&&(s=void 0,i=void 0)}},K=M;K.maxSectionID=co,K.maxMaterialID=co,K.async={union(t,e,r){let n=je(t.materials,e.materials);return br("union",M.union,t,e,n,r)},subtract(t,e,r){let n=je(t.materials,e.materials);return br("subtract",M.subtract,t,e,n,r)},intersect(t,e,r){let n=je(t.materials,e.materials);return br("intersect",M.intersect,t,e,n,r)},unionArray(t,e){return fo(M.async.union,M.async.unionArray,t,e)},subtractArray(t,e){return rt(this,null,function*(){let r=t.length;if(r===0)throw new Error("Unable to find any result octree");return r===1?t[0]:r===2?yield M.async.subtract(t[0],t[1],e):yield M.async.subtract(t[0],yield M.async.unionArray(t.slice(1),e),e)})},intersectArray(t,e){return fo(M.async.intersect,M.async.intersectArray,t,e)},operation(t,e){return new Promise((r,n)=>{try{switch(t.op){case"union":case"subtract":case"intersect":{let s,i,c=[];t.objA&&c.push(lo(t.objA,0,e)),t.objB&&c.push(lo(t.objB,1,e)),Promise.allSettled(c).then(l=>{for(let m of l)if(m.status==="fulfilled"){let[f,h]=m.value;h===0?s=f:h===1&&(i=f)}let u;switch(t.op){case"union":u=M.async.union(s,i,e);break;case"subtract":u=M.async.subtract(s,i,e);break;default:u=M.async.intersect(s,i,e)}u.then(m=>{r(m),Ye(s,i)}).catch(m=>n(m))});break}case"unionArray":case"subtractArray":case"intersectArray":{let s=new Array;for(let c of t.objs)s.push(Rt(c,e));let i;switch(t.op){case"unionArray":i=M.async.unionArray(s,e);break;case"subtractArray":i=M.async.subtractArray(s,e);break;default:i=M.async.intersectArray(s,e)}Ye(...s),i.then(c=>r(c));break}default:throw new Error(`Unknown operation: ${t.op}`)}}catch(s){n(s)}})}};function an(a,o){return a.distance-o.distance}function Rt(a,o){if(a instanceof K)return a;if(a.op)return K.operation(a,o);throw new Error("Invalid OctreeCSG operation object")}function lo(a,o,t){return new Promise((e,r)=>{try{if(a instanceof K)e([a,o]);else if(a.op)K.async.operation(a,t).then(n=>{e([n,o])});else throw new Error("Invalid OctreeCSG operation object")}catch(n){r(n)}})}function Ye(...a){for(let o of a)o.delete()}function uo(a,o,t){for(let e of t)e.originalValid&&e.valid&&e.intersects&&Yr(a.triangle,e.triangle)&&o.push(e)}function mo(a,o,t){let e=o.slice();for(;e.length>1;){let r=e.length,n=new Array,s=0;for(;s+1<r;s+=2){let i=e[s],c=e[s+1],l=a(i,c,t);Ye(i,c),n.push(l)}s<r&&n.push(e[s]),e=n}if(e.length===0)throw new Error("Unable to find any result octree");return e[0]}function br(a,o,t,e,r,n){return rt(this,null,function*(){if(globalThis.globalOctreeCSGJobDispatcher)try{return yield globalThis.globalOctreeCSGJobDispatcher.dispatch({op:a,objA:t,objB:e},r,n)}catch(i){let c=!0;if(i instanceof ie&&i.failReason===0&&(console.warn("Queued job failed due to worker creation failure. Retrying synchronously"),c=!1),c)throw i}let s=o(t,e,n);return Ye(t,e),s})}function fo(a,o,t,e){var n;let r=(n=e==null?void 0:e.batchSize)!=null?n:on;return new Promise((s,i)=>{try{let c=r>4&&r<t.length,l,u=!1,m=[];if(c){let f=[],h=0;for(;h<t.length;)f.push(t.slice(h,h+r)),h+=r;let g;for(;g=f.shift();)m.push(o(g,e));u=!0,t.length=0}else{let f=[],h=t.length;for(let d=0;d<h;d++)f.push(t[d]);l=f.shift();let g,p=f.length;for(let d=0;d<p;d+=2){if(d+1>=p){g=f[d];break}m.push(a(f[d],f[d+1],e))}g&&(m.push(a(l,g,e)),u=!0)}Promise.allSettled(m).then(f=>{let h=new Array;for(let g of f)g.status==="fulfilled"&&h.push(g.value);u||h.unshift(l),h.length<=0?i("Unable to find any result octree"):h.length===1?s(h[0]):h.length>3?o(h,e).then(g=>{s(g)}).catch(g=>i(g)):a(h[0],h[1],e).then(g=>{h.length===3?a(g,h[2],e).then(p=>{s(p)}).catch(p=>i(p)):s(g)}).catch(g=>i(g))})}catch(c){i(c)}})}function ho(a,o,t){switch(a.op){case"union":case"subtract":case"intersect":return{op:a.op,objA:gr(a.objA,o,t),objB:gr(a.objB,o,t)};case"unionArray":case"subtractArray":case"intersectArray":{let e=new Array;for(let r of a.objs)e.push(gr(r,o,t));return{op:a.op,objs:e}}default:throw new Error(`Unknown operation: ${a.op}`)}}function gr(a,o,t){return a instanceof K?a.encode(o,t):ho(a,o,t)}var lt=class{constructor(o,t,e,r,n){this.resolveCallback=r;this.rejectCallback=n;this.workerIndex=null;this.transferables=[],this.operation=ho(o,t,this.transferables),this.materials=t,this.options=e}getMessage(o,t){if(!(this.operation&&this.transferables))throw new Error("Message already created");let e=this.operation,r=this.materials,n=this.options,s=this.transferables;return this.operation=null,this.materials=null,this.options=void 0,this.transferables=null,this.workerIndex=o,[{type:"operation",jobIndex:t,operation:e,materials:r,options:n},s]}resolve(o,t){try{this.resolveCallback(K.decode(o,t))}catch(e){this.rejectCallback(ie.DecodeFailure(e))}}reject(o){this.rejectCallback(o)}};var po="OctreeCSG job dispatcher worker creation",yr=`Skipped ${po}; `,Xe=class{constructor(){this.workers=null;this.nextJobIndex=0;this.waitingJobs=new Map;this.jobCounts=new Array}initWorker(o,t,e,r){return new Promise((n,s)=>{let i=setTimeout(()=>{c.terminate(),s(new Error("Timed out"))},e),c=new Worker(t,{type:"classic",name:r});c.onmessage=l=>{if(clearTimeout(i),l.data==="initialized"){let u=o.length;o.push(c),c.onmessage=this.makeMessageHandler(u),n(void 0)}else c.terminate(),s(new Error("Unexpected initialization message"))}})}init(o,t,e){return new Promise((r,n)=>{let s=new Array,i=0;for(let c=0;c<t;c++)this.initWorker(s,o,e,`octreecsg-ea-${c}`).catch(l=>{console.error("Failed to create OctreeCSG worker:",l.message)}).finally(()=>{if(++i===t){let l=s.length;if(l===0){n(new Error("All OctreeCSG workers failed to be created"));return}else l!==t?console.warn(`Some OctreeCSG workers failed to be created. Created ${l} workers instead of ${t}`):console.info(`Created ${l} OctreeCSG workers`);this.workers=s,this.jobCounts=new Array(l),this.jobCounts.fill(0),r(void 0)}})})}makeMessageHandler(o){let t=this;return function(e){t.handleMessage(o,e)}}handleMessage(o,t){this.jobCounts[o]--;let e=t.data.jobIndex,r=this.waitingJobs.get(e);this.waitingJobs.delete(e),t.data.success?r.resolve(t.data.buffer,t.data.materials):r.reject(ie.OperationFailure(t.data.error))}doDispatch(o,t){let e=0,r=this.jobCounts[0],n=this.jobCounts.length;for(let i=1;i<n;i++){let c=this.jobCounts[i];c<r&&(e=i,r=c)}this.jobCounts[e]++,this.workers[e].postMessage(...t.getMessage(e,o))}dispatch(o,t,e){return new Promise((r,n)=>{let s=new lt(o,t,e,r,n),i=this.nextJobIndex++;this.waitingJobs.set(i,s),this.workers&&this.doDispatch(i,s)})}static create(o,t,e){return rt(this,null,function*(){if(globalThis.globalOctreeCSGJobDispatcher){console.warn(`${yr}already created`);return}else if(globalThis.globalOctreeCSGJobDispatcher===null){console.warn(`${yr}previous creation failed`);return}let r;if(globalThis.Worker){try{r=new Xe,globalThis.globalOctreeCSGJobDispatcher=r,yield r.init(o,t,e)}catch(n){if(console.error(`${po} failed:`,n),globalThis.globalOctreeCSGJobDispatcher=null,r){for(let s of r.waitingJobs.values())s.reject(ie.WorkerCreationFailure(n));r.waitingJobs.clear()}throw n}for(let[n,s]of r.waitingJobs)r.doDispatch(n,s)}else{console.warn(`${yr}Worker API not supported`);return}})}};import{vec3 as U}from"gl-matrix";import{mat4 as ee,quat as bo}from"gl-matrix";var cn={type:-3,valueType:2,transformable:1,flippable:!0},ln=[cn],ut=ln;var te=class extends K{constructor(o,t,e){var c;let r=t.length;if(r%3!==0)throw new Error("Input triangle vertices array has a non-multiple-of-three length");let n=(c=e==null?void 0:e.materialID)!=null?c:0,s=new Map([[n,ut]]);super(s,o);for(let l=0;l<r;l+=3){let u=new Z(t.slice(l,l+3),n);u.originalValid=!0,this.polygons.push(u)}if(!e)return;let i=e.outputMatrix;if("matrix"in e){let l=e.matrix;this.applyMatrix(l,e.normalMatrix),i&&ee.copy(i,l)}else if("rotation"in e||"translation"in e||"scale"in e){let l=ee.create(),u;if(e.rotation)if(e.rotation.length===4)u=e.rotation;else{let[m,f,h]=e.rotation;u=bo.fromEuler(bo.create(),m,f,h)}if(u&&e.translation)e.scale?ee.fromRotationTranslationScale(l,u,e.translation,e.scale):ee.fromRotationTranslation(l,u,e.translation);else if(e.translation)e.scale?(ee.identity(l),ee.translate(l,l,e.translation),ee.scale(l,l,e.scale)):ee.fromTranslation(l,e.translation);else if(u)if(e.scale){ee.identity(l);let m=ee.create();ee.fromQuat(m,u),ee.multiply(l,l,m),ee.scale(l,l,e.scale)}else ee.fromQuat(l,u);else ee.fromScaling(l,e.scale);this.applyMatrix(l),i&&ee.copy(i,l)}else i&&ee.identity(i);e!=null&&e.inverted&&this.invert()}};function Ke(a,o,t,e,r,n,s){return a[o++]=new C(U.clone(t),[U.clone(s)]),a[o++]=new C(e,[U.clone(s)]),a[o++]=new C(U.clone(r),[U.clone(s)]),a[o++]=new C(r,[U.clone(s)]),a[o++]=new C(n,[U.clone(s)]),a[o++]=new C(t,[s]),o}var mt=class extends te{constructor(o,t,e,r){o*=.5,t*=.5,e*=.5;let n=U.fromValues(o,t,e),s=U.negate(U.create(),n),i=U.fromValues(-o,t,e),c=U.fromValues(o,t,e),l=U.fromValues(-o,t,-e),u=U.fromValues(o,t,-e),m=U.fromValues(-o,-t,e),f=U.fromValues(o,-t,e),h=U.fromValues(-o,-t,-e),g=U.fromValues(o,-t,-e),p=new Array(36),d=Ke(p,0,i,c,u,l,U.fromValues(0,1,0));d=Ke(p,d,h,g,f,m,U.fromValues(0,-1,0)),d=Ke(p,d,u,c,f,g,U.fromValues(1,0,0)),d=Ke(p,d,h,m,i,l,U.fromValues(-1,0,0)),d=Ke(p,d,f,c,i,m,U.fromValues(0,0,1)),Ke(p,d,h,l,u,g,U.fromValues(0,0,-1)),super(new _(s,n),p,r)}};var vr=class extends mt{constructor(o=1,t){super(o,o,o,t)}};import{vec3 as Be}from"gl-matrix";function Ze(a,o,t,e,r,n,s,i){for(let c=0;c<t;c++){let l=c/t,u=(c+1)/t;for(let m=0;m<t;m++){let f=m/t,h=(m+1)/t,[g,p]=a(l,f,e,n,s,i),[d,y]=a(u,f,e,n,s,i),[x,w]=a(u,h,e,n,s,i),[D,$]=a(l,h,e,n,s,i);r[o++]=new C(Be.clone(g),[Be.clone(p)]),r[o++]=new C(d,[y]),r[o++]=new C(Be.clone(x),[Be.clone(w)]),r[o++]=new C(x,[w]),r[o++]=new C(D,[$]),r[o++]=new C(g,[p])}}return o}var _e=class extends te{constructor(o,t=1,e){var m;let r=(m=e==null?void 0:e.subDivisions)!=null?m:4,n=36*r*r,s=new Array(n),i=t/2,c=Ze(o,0,r,i,s,[1,-1,1],[0,0,-2],[0,2,0]);c=Ze(o,c,r,i,s,[-1,-1,-1],[0,0,2],[0,2,0]),c=Ze(o,c,r,i,s,[-1,1,1],[2,0,0],[0,0,-2]),c=Ze(o,c,r,i,s,[1,-1,1],[-2,0,0],[0,0,-2]),c=Ze(o,c,r,i,s,[-1,-1,1],[2,0,0],[0,2,0]),Ze(o,c,r,i,s,[1,-1,-1],[-2,0,0],[0,2,0]);let l=Be.fromValues(i,i,i),u=Be.negate(Be.create(),l);super(new _(u,l),s,e)}};import{vec3 as Ue}from"gl-matrix";function un(a,o,t,e,r,n){Ue.copy(v,e),Ue.scaleAndAdd(v,v,r,a),Ue.scaleAndAdd(v,v,n,o),Ue.multiply(O,v,v);let s=Ue.fromValues(v[0]*Math.sqrt(1-.5*(O[1]+O[2])+O[1]*O[2]*ze),v[1]*Math.sqrt(1-.5*(O[2]+O[0])+O[2]*O[0]*ze),v[2]*Math.sqrt(1-.5*(O[0]+O[1])+O[0]*O[1]*ze));return[Ue.scale(Ue.create(),s,t),s]}var xr=class extends _e{constructor(o=1,t){super(un,o,t)}};import{vec3 as Qe}from"gl-matrix";function mn(a,o,t,e,r,n){Qe.copy(v,e),Qe.scaleAndAdd(v,v,r,a),Qe.scaleAndAdd(v,v,n,o);let s=Qe.normalize(v,v);return[Qe.scale(Qe.create(),s,t),s]}var Pr=class extends _e{constructor(o=1,t){super(mn,o,t)}};import{vec3 as re}from"gl-matrix";import{vec3 as Cr}from"gl-matrix";import{vec3 as go}from"gl-matrix";function Et(a,o=!1,t,e=0){let r=a.length;if(r<3)throw new Error(`Expected input polyline with 3 or more vertices, got ${r}`);if(t||(t=new Array(e+(r-2)*3)),r===3)return o?(t[e++]=a[2].clone(),t[e++]=a[1].clone(),t[e++]=a[0].clone()):(t[e++]=a[0].clone(),t[e++]=a[1].clone(),t[e++]=a[2].clone()),[t,e];if(r===4)return o?(t[e++]=a[2].clone(),t[e++]=a[1].clone(),t[e++]=a[0].clone()):(t[e++]=a[0].clone(),t[e++]=a[1].clone(),t[e++]=a[2].clone()),go.squaredDistance(a[0].pos,a[2].pos)<=go.squaredDistance(a[1].pos,a[3].pos)?t[e++]=a[0].clone():t[e++]=a[1].clone(),o?(t[e++]=a[3].clone(),t[e++]=a[2].clone()):(t[e++]=a[2].clone(),t[e++]=a[3].clone()),[t,e];let n=Array.from({length:r},(s,i)=>i);n.sort((s,i)=>{let c=a[s],l=a[i];return c.pos[0]<l.pos[0]?-1:c.pos[0]>l.pos[0]?1:c.pos[1]<l.pos[1]?-1:c.pos[1]>l.pos[1]?1:c.pos[2]<l.pos[2]?-1:c.pos[2]>l.pos[2]?1:0});for(let s=2;s<r;s++){let i=n[s-2],c=n[s-1],l=n[s];i>c&&([i,c]=[c,i]),c>l&&([c,l]=[l,c],i>c&&([i,c]=[c,i])),o&&([l,i]=[i,l]),t[e++]=a[l].clone(),t[e++]=a[i].clone(),t[e++]=a[c].clone()}return[t,e]}function ft(a,o,t,e,r,n){let s=o.length,i=new Array(s);for(let c=0;c<s;c++)i[c]=new C(Cr.fromValues(o[c][0],t,o[c][1]),[Cr.clone(e)]);return Et(i,n,a,r)[1]}function Ft(a,o,t){let e=new Array(a);for(let r=0;r<a;r++){let n=F*(a-1-r)/a,s=Math.cos(n),i=Math.sin(n);t?e[r]=[o*s,o*i,Cr.fromValues(s,0,i)]:e[r]=[o*s,o*i]}return e}var Ar=class extends te{constructor(o=1,t=1,e){var h;let r=(h=e==null?void 0:e.subDivisions)!=null?h:12,n=(r-2)*6+r*6,s=new Array(n),i=o/2,c=t/2,l=Ft(r,i,!0),u=ft(s,l,c,re.fromValues(0,1,0),0,!1);u=ft(s,l,-c,re.fromValues(0,-1,0),u,!0);for(let g=0;g<r;g++){let[p,d,y]=l[g],[x,w,D]=l[(g+1)%r];s[u++]=new C(re.fromValues(x,c,w),[re.clone(D)]),s[u++]=new C(re.fromValues(p,c,d),[re.clone(y)]),s[u++]=new C(re.fromValues(p,-c,d),[re.clone(y)]),s[u++]=new C(re.fromValues(p,-c,d),[re.clone(y)]),s[u++]=new C(re.fromValues(x,-c,w),[re.clone(D)]),s[u++]=new C(re.fromValues(x,c,w),[re.clone(D)])}let m=re.fromValues(i,c,i),f=re.negate(re.create(),m);super(new _(f,m),s,e)}};import{vec3 as be}from"gl-matrix";var qe=class extends te{constructor(o,t,e,r,n){let s=(o-2)*3+o*3,i=new Array(s),c=e/2,l=r/2,u=be.fromValues(0,l,0),m=Ft(o,c,t);if(t){let p=Math.atan(c/r),d=Math.cos(p),y=Math.sin(p);for(let x=0;x<o;x++){let w=m[x][2];w[0]*=d,w[1]=y,w[2]*=d}}let f=ft(i,m,-l,be.fromValues(0,-1,0),0,!0);for(let p=0;p<o;p++){let d=m[p],y=m[(p+1)%o],[x,w]=d,[D,$]=y,j=be.fromValues(D,-l,$),H=be.clone(u),ae=be.fromValues(x,-l,w),E,Y,ne;t?(E=d[2],Y=be.fromValues(0,1,0),ne=y[2]):E=Y=ne=X.calculateNormal(j,H,ae),i[f++]=new C(j,[be.clone(ne)]),i[f++]=new C(H,[Y]),i[f++]=new C(ae,[be.clone(E)])}let h=be.fromValues(c,l,c),g=be.negate(be.create(),h);super(new _(g,h),i,n)}};var Sr=class extends qe{constructor(o=1,t=1,e){var r;super((r=e==null?void 0:e.subDivisions)!=null?r:12,!0,o,t,e)}};var wr=class extends qe{constructor(o,t=1,e=1,r){super(o,!1,t,e,r)}};import{vec3 as ge}from"gl-matrix";import{vec3 as pe}from"gl-matrix";var P=[pe.fromValues(0,1,0),pe.fromValues(.276385,.447215,-.85064),pe.fromValues(-.7236,.447215,-.52572),pe.fromValues(-.7236,.447215,.52572),pe.fromValues(.276385,.447215,.85064),pe.fromValues(.894425,.447215,0),pe.fromValues(-.276385,-.447215,-.85064),pe.fromValues(-.894425,-.447215,0),pe.fromValues(-.276385,-.447215,.85064),pe.fromValues(.7236,-.447215,.52572),pe.fromValues(.7236,-.447215,-.52572),pe.fromValues(0,-1,0)];function ht(a,o,t){let e=a(o,0,t,P[0],P[1],P[2]);e=a(o,e,t,P[0],P[2],P[3]),e=a(o,e,t,P[0],P[3],P[4]),e=a(o,e,t,P[0],P[4],P[5]),e=a(o,e,t,P[0],P[5],P[1]),e=a(o,e,t,P[1],P[6],P[2]),e=a(o,e,t,P[2],P[6],P[7]),e=a(o,e,t,P[2],P[7],P[3]),e=a(o,e,t,P[3],P[7],P[8]),e=a(o,e,t,P[3],P[8],P[4]),e=a(o,e,t,P[4],P[8],P[9]),e=a(o,e,t,P[4],P[9],P[5]),e=a(o,e,t,P[5],P[9],P[10]),e=a(o,e,t,P[5],P[10],P[1]),e=a(o,e,t,P[1],P[10],P[6]),e=a(o,e,t,P[11],P[7],P[6]),e=a(o,e,t,P[11],P[8],P[7]),e=a(o,e,t,P[11],P[9],P[8]),e=a(o,e,t,P[11],P[10],P[9]),a(o,e,t,P[11],P[6],P[10])}function fn(a,o,t,e,r,n){let s=X.calculateNormal(e,r,n);return a[o++]=new C(ge.scale(ge.create(),e,t),[ge.clone(s)]),a[o++]=new C(ge.scale(ge.create(),r,t),[ge.clone(s)]),a[o++]=new C(ge.scale(ge.create(),n,t),[s]),o}var Mr=class extends te{constructor(o=1,t){let e=o/2,r=ge.fromValues(e,e,e),n=ge.negate(ge.create(),r),s=new Array(60);ht(fn,s,e),super(new _(n,r),s,t)}};import{vec3 as J}from"gl-matrix";function pt(a,o,t,e,r,n,s){if(a<=0)o[t++]=new C(J.scale(J.create(),r,e),[J.clone(r)]),o[t++]=new C(J.scale(J.create(),n,e),[J.clone(n)]),o[t++]=new C(J.scale(J.create(),s,e),[J.clone(s)]);else{let i=J.add(J.create(),r,n);J.normalize(i,i);let c=J.add(J.create(),n,s);J.normalize(c,c);let l=J.add(J.create(),s,r);J.normalize(l,l);let u=a-1;t=pt(u,o,t,e,r,i,l),t=pt(u,o,t,e,i,n,c),t=pt(u,o,t,e,i,c,l),t=pt(u,o,t,e,l,c,s)}return t}var Or=class extends te{constructor(o=1,t){var c;let e=o/2,r=J.fromValues(e,e,e),n=J.negate(J.create(),r),s=(c=t==null?void 0:t.subDivisions)!=null?c:2,i=new Array(60*gt(4,s));ht(pt.bind(null,s),i,e),super(new _(n,r),i,t)}};import{mat4 as Vr,quat as yo,vec3 as oe}from"gl-matrix";var Gr=class extends te{constructor(o=1,t=.5,e){var g,p;let r=(g=e==null?void 0:e.radialSubDivisions)!=null?g:8,n=(p=e==null?void 0:e.tubularSubDivisions)!=null?p:16,s=o/2,i=t/2,c=s-i,l=oe.fromValues(s,c,s),u=oe.negate(oe.create(),l),m=new Array(n);for(let d=0;d<n;d++){let y=new Array(r);m[d]=y;let x=yo.fromEuler(yo.create(),0,360*d/n,0);oe.set(v,i+c,0,0),Vr.fromTranslation(ot,v),Vr.fromQuat(rr,x),Vr.multiply(ot,rr,ot);for(let w=0;w<r;w++){let D=F*w/r,$=Math.cos(D),j=Math.sin(D),H=oe.fromValues($*c,j*c,0);oe.transformMat4(H,H,ot);let ae=oe.fromValues($,j,0);oe.transformQuat(ae,ae,x),y[w]=[H,ae]}}let f=new Array(n*r*6),h=0;for(let d=0;d<n;d++){let y=m[d],x=m[(d+1)%n];for(let w=0;w<r;w++){let D=(w+1)%r,[$,j]=y[w],[H,ae]=x[w],[E,Y]=y[D],[ne,ye]=x[D];f[h++]=new C(oe.clone(E),[oe.clone(Y)]),f[h++]=new C($,[j]),f[h++]=new C(oe.clone(H),[oe.clone(ae)]),f[h++]=new C(oe.clone(H),[oe.clone(ae)]),f[h++]=new C(oe.clone(ne),[oe.clone(ye)]),f[h++]=new C(E,[Y])}}super(new _(u,l),f,e)}};import{mat3 as Ut,mat4 as Rr,vec2 as zt,vec3 as R}from"gl-matrix";function Me(a){let o=0,t=a.length,e=a[t-1];for(let r of a)o+=(r[0]-e[0])*(r[1]+e[1]),e=r;return o>=0}function dt(a){let o=Array.from({length:a.length},(t,e)=>e);return o.sort((t,e)=>{let r=a[t],n=a[e];return r[0]<n[0]?-1:r[0]>n[0]?1:r[1]<n[1]?-1:r[1]>n[1]?1:0}),o}function vo(a,o,t){let e=a.length,r=[o];for(let n=(a.indexOf(o)+1)%e;;n=(n+1)%e){let s=a[n];if(r.push(s),s===t)return r;if(s===o)throw new Error(`getPolygonInLoop aborted; infinite loop detected due to possibly invalid split diagonal (${o}, ${t})`)}}function Dr(a,o,t,e,r){if(t.length>0){let[n,s]=t[0],i=vo(o,n,s),c=vo(o,s,n),l=new Array,u=new Array,m=t.length;for(let f=1;f<m;f++){let[h,g]=t[f];if(i.indexOf(h)>=0&&i.indexOf(g)>=0)l.push([h,g]);else if(c.indexOf(h)>=0&&c.indexOf(g)>=0)u.push([h,g]);else throw new Error(`Invalid split diagonal (${h}, ${g})`)}Dr(a,i,l,e,r),Dr(a,c,u,e,r)}else{let n=o.length,s=new Array(n);if(r)for(let i=0;i<n;i++)s[i]=a[o[n-1-i]];else for(let i=0;i<n;i++)s[i]=a[o[i]];e.push(s)}}function Nt(a,o,t,e=!1){return t||(t=[]),Dr(a,Array.from({length:a.length},(r,n)=>n),o,t,e),t}function xo(a,o){return a[0]<o[0]||a[0]===o[0]&&a[1]<o[1]}function Po(a,o,t){let e=-Math.atan2(a[1]-o[1],a[0]-o[0]);return((-Math.atan2(t[1]-o[1],t[0]-o[0])-e)%F+F)%F}function Tr(a,o,t,e){let r=-1,n=-1/0;for(let s of o){let i=(s+1)%t,c=a[s],l=a[i],u,m;if(c[0]>l[0]?(u=l,m=c):(m=l,u=c),e[0]>=u[0]&&e[0]<=m[0]){let f=(m[1]-u[1])/(m[0]-u[0]),h=u[1]-f*u[0],g=f*e[0]+h;g<=e[1]&&g>=n&&(n=g,r=s)}}if(r===-1)throw new Error(`No edge to the left of vertex. Status: ${Array.from(o)}`);return r}function jt(a,o,t){t===void 0&&(t=Me(a)),t&&(a=a.slice().reverse());let e=a.length,r=new Map,n=new Set,s=new Map,i=new Array;for(let c of dt(a)){let l=(c-1%e+e)%e,u=(c+1)%e,m=a[l],f=a[c],h=a[u],g=xo(f,m),p=xo(f,h);if(g&&p){if(Po(m,f,h)<Math.PI)s.set(c,0);else{s.set(c,3);let d=Tr(a,n,e,f);i.push([c,r.get(d)]),r.set(d,c)}n.add(c),r.set(c,c);continue}else if(!g&&!p){let d=r.get(l);if(d!==void 0&&s.get(d)===4&&i.push([c,d]),n.delete(l),Po(m,f,h)<Math.PI)s.set(c,1);else{s.set(c,4);let y=Tr(a,n,e,f),x=r.get(y);x!==void 0&&s.get(x)===4&&i.push([c,x]),r.set(y,c)}continue}if(s.set(c,2),h[0]>f[0]){let d=r.get(l);d!==void 0&&s.get(d)===4&&i.push([c,d]),n.delete(l),n.add(c),r.set(c,c)}else{let d=Tr(a,n,e,f),y=r.get(d);y!==void 0&&s.get(y)===4&&i.push([c,y]),r.set(d,c)}}return Nt(a,i,o,t)}import{vec2 as le}from"gl-matrix";function Ir(a,o,t){return(o[0]-a[0])*(o[1]+a[1])+(t[0]-o[0])*(t[1]+o[1])+(a[0]-t[0])*(a[1]+t[1])>=0}function kr(a,o,t,e,r,n){return a[o++]=e,Ir(e,r,n)===t?(a[o++]=r,a[o++]=n):(a[o++]=n,a[o++]=r),o}function Co(a,o,t){return o>t?a>=o||a<t:a>=o&&a<t}function Bt(a,o,t=0,e){let r=a.length;if(r<3)throw new Error(`Expected input polyline with 3 or more vertices, got ${r}`);let n=t+(r-2)*3;if(o?o.length<n&&(o.length=n):o=new Array(n),r===3)return o[t++]=le.clone(a[0]),o[t++]=le.clone(a[1]),o[t++]=le.clone(a[2]),[o,t];e===void 0&&(e=Me(a));let s=dt(a),i=s[r-1],c=s[0],l=[s[0],s[1]];for(let f=2;f<r-1;f++){let h=s[f],g=a[h],p=l.length,d=l[p-1],y=a[d];if(Co(h,i,c)!==Co(d,i,c)){for(let x=0;x<p-1;x++)t=kr(o,t,e,g,le.clone(a[l[x]]),le.clone(a[l[x+1]]));l=[d,h]}else{let x=y,w=l.pop(),D=le.sub(Qr,x,g);for(h===(w+1)%r!==e&&le.negate(D,D);l.length>0;){let $=l[l.length-1],j=a[$],H=le.sub(Zr,j,x);if(D[0]*H[1]-D[1]*H[0]<=0)break;l.pop(),t=kr(o,t,e,g,le.clone(x),le.clone(j)),w=$,x=j}l.push(w),l.push(h)}}let u=a[s[r-1]],m=l.length-1;for(let f=0;f<m;f++)t=kr(o,t,e,le.clone(u),le.clone(a[l[f]]),le.clone(a[l[f+1]]));return[o,t]}function _t(a,o){let t=Me(a),e=jt(a,void 0,t),r=0;for(let s of e)r+=(s.length-2)*3;o?o.length<r&&(o.length=r):o=new Array(r);let n=0;for(let s of e)[o,n]=Bt(s,o,n,t);return o}function Ao(a,o,t,e,r,n,s){Rr.set(o,n[0],n[1],n[2],0,r[0],r[1],r[2],0,s[0],s[1],s[2],0,e[0],e[1],e[2],1);let i=t.length;for(let c=0;c<i;c++){let l=a[c];zt.copy(l,t[c]),l[2]=0,R.transformMat4(l,l,o)}}function So(a,o,t,e,r){for(let n=0;n<e;){let s=R.create();zt.copy(s,o[n++]),R.transformMat4(s,s,t);let i=R.create();zt.copy(i,o[n++]),R.transformMat4(i,i,t);let c=R.create();zt.copy(c,o[n++]),R.transformMat4(c,c,t),r&&([s,c]=[c,s]);let l=X.calculateNormal(s,i,c),u=new C(s,[R.clone(l)]),m=new C(i,[R.clone(l)]),f=new C(c,[l]),h=new Z([u,m,f]);h.originalValid=!0,a.addPolygon(h)}}function bt(a,o,t,e){var j,H,ae;let r=o.length;if(t.length!==r)throw new Error("There must be at least one frame per point");if(r<2)throw new Error("There must be at least 1 segment (2 points) in the curve");let n=(j=e==null?void 0:e.materialID)!=null?j:0,s=new Map([[n,ut]]),i=new K(s),c=a.length,l=new Array(c),u=new Array(c);for(let E=0;E<c;E++)l[E]=R.create(),u[E]=R.create();let m=Rr.create(),f=Ut.create(),h=Rr.create(),g=Ut.create();Ao(u,h,a,o[0],...t[0]),Ut.fromMat4(g,h);let p=new Array(c);R.set(v,0,0,1);for(let E=0;E<c;E++){let Y=(E+1)%c,ne=a[E],ye=a[Y],Se=R.fromValues(ne[0]-ye[0],ne[1]-ye[1],0);p[E]=R.cross(Se,v,Se)}let d=(H=e==null?void 0:e.smoothNormals)!=null?H:!1,y;if(d){y=new Array(c);for(let E=0;E<c;E++){let Y=E-1;Y===-1&&(Y=c-1);let ne=R.add(R.create(),p[Y],p[E]);y[E]=R.normalize(ne,ne)}}let x,w,D=(ae=e==null?void 0:e.includeBases)!=null?ae:!0;D&&(x=_t(a),w=x.length,So(i,x,h,w,!1));let $=r-1;for(let E=1;E<r;E++){[l,u,m,h,f,g]=[u,l,h,m,g,f],Ao(u,h,a,o[E],...t[E]),Ut.fromMat4(g,h);for(let Y=0;Y<c;Y++){let ne=(Y+1)%c,ye,Se,et,tt;if(y){let Ge=y[Y],_r=y[ne];ye=R.clone(Ge),Se=R.clone(_r),et=R.clone(Ge),tt=R.clone(_r)}else{let Ge=p[Y];ye=R.clone(Ge),Se=R.clone(Ge),et=R.clone(Ge),tt=R.clone(Ge)}R.transformMat3(ye,ye,f),R.transformMat3(Se,Se,f),R.transformMat3(et,et,g),R.transformMat3(tt,tt,g);let Fr=new C(l[Y],[ye]),ko=new C(l[ne],[Se]),Ro=new C(R.clone(u[Y]),[et]),Nr=new C(R.clone(u[ne]),[tt]),jr=new Z([Nr.clone(),ko,Fr.clone()],n);jr.originalValid=!0,i.addPolygon(jr);let Br=new Z([Fr,Ro,Nr],n);Br.originalValid=!0,i.addPolygon(Br)}D&&E===$&&So(i,x,h,w,!0)}return i}function wo(a,o,t){let e=[[0,0,0],[0,0,o]],r=o>=0?[[0,1,0],[1,0,0],[0,0,1]]:[[0,1,0],[-1,0,0],[0,0,-1]];return bt(a,e,[r,r],t)}import{quat as hn,vec3 as z}from"gl-matrix";function Er(a,o,t,e){var u;let r=a.length;if(o.length<r)throw new Error("There must be at least one tangent per point");if(r<2)throw new Error("There must be at least 1 segment (2 points) in the curve");let n=new Array(r),s=o[0],i=z.cross(z.create(),s,t);n[0]=[t,i,s];for(let m=0;m<r-1;m++){let f=z.sub(v,a[m+1],a[m]),h=z.dot(f,f),g=n[m][0],p=n[m][2],d=-2/h,y=z.scaleAndAdd(O,g,f,z.dot(f,g)*d),x=z.scaleAndAdd(se,p,f,z.dot(f,p)*d),w=o[m+1],D=z.sub(se,w,x),$=z.dot(D,D),j=z.scaleAndAdd(z.create(),y,D,z.dot(D,y)*-2/$),H=z.cross(z.create(),w,j);n[m+1]=[j,H,w]}let c=e==null?void 0:e.endNormal,l=(u=e==null?void 0:e.twists)!=null?u:0;if(c||l>0){let m=0;if(c){let f=o[r-1],h=z.cross(z.create(),f,c),g=n[r-1][0],p=z.dot(h,g),d=z.dot(c,g);p!==0&&d!==0&&(m=Math.atan2(d,p)-zr)}if(m+=F*l,m!==0){let f=0,h=a[0];for(let p=1;p<r;p++){let d=a[p];f+=z.distance(h,d),h=d}let g=0;h=a[0];for(let p=1;p<r;p++){let[d,y,x]=n[p],w=a[p];g+=z.distance(h,w),h=w;let D=m*g/f;hn.setAxisAngle(xt,o[p],D),z.transformQuat(d,d,xt),z.transformQuat(y,y,xt)}}}return n}function pn(a,o,t,e,r){return bt(a,o,Er(o,t,e,r),r)}import{vec2 as dn}from"gl-matrix";function Wt(a,o,t=!1){if(o<3)throw new Error("There must be at least 3 sides in a regular polyline");let e=new Array(o),r=o-1;for(let n=0;n<o;n++){let s=t?n:r-n,i=F*s/o,c=Math.cos(i)*a,l=Math.sin(i)*a;e[n]=dn.fromValues(l,c)}return e}function Mo(a,o=!1,t=12){return Wt(a,t,o)}import{vec2 as Oe}from"gl-matrix";function Oo(a,o=!1){let t=a/2;return o?[Oe.fromValues(t,t),Oe.fromValues(t,-t),Oe.fromValues(-t,-t),Oe.fromValues(-t,t)]:[Oe.fromValues(t,t),Oe.fromValues(-t,t),Oe.fromValues(-t,-t),Oe.fromValues(t,-t)]}import{vec2 as Ve}from"gl-matrix";function Vo(a,o,t=!1){let e=a/2,r=o/2;return t?[Ve.fromValues(e,r),Ve.fromValues(e,-r),Ve.fromValues(-e,-r),Ve.fromValues(-e,r)]:[Ve.fromValues(e,r),Ve.fromValues(-e,r),Ve.fromValues(-e,-r),Ve.fromValues(e,-r)]}import{vec2 as Go}from"gl-matrix";function Do(a,o,t,e=!1){if(t<3)throw new Error("There must be at least 3 sides in a star polyline");let r=new Array(t*2),n=t-1,s=F/t/2,i=0;for(let c=0;c<t;c++){let l=e?c:n-c,u=F*l/t,m=Math.cos(u)*a,f=Math.sin(u)*a,h=Go.fromValues(f,m),g=u+s,p=Math.cos(g)*o,d=Math.sin(g)*o,y=Go.fromValues(d,p);e?(r[i++]=h,r[i++]=y):(r[i++]=y,r[i++]=h)}return r}import{vec2 as To}from"gl-matrix";var $t=class{constructor(o){this.conditions=new Array;var t;this.generatesUVs=(t=o==null?void 0:o.generatesUVs)!=null?t:!0}canProjectToPolygon(o){for(let t of this.conditions)if(!t(o))return!1;return!0}projectVertex(o,t,e,r,n){if(!o.extra)throw new Error("Expected extra polygon attributes, but got undefined");let s=[...o.extra];if(o.extra.length=r===null?0:r.length,o.extra.length>0){for(let[i,c]of t.entries())if(c!==null){if(this.generatesUVs&&r[c].type===-1){let[l,u]=this.projectUV(o.pos,n);To.set(s[i],l,u)}o.extra[c]=s[i]}if(e!==null){let[i,c]=this.projectUV(o.pos,n);o.extra[e]=To.fromValues(i,c)}}}projectSingleWithExtraData(o,t,e,r,n,s){let i=e.get(o.shared);o.shared=t,this.projectVertex(o.vertices[0],i,r,n,s),this.projectVertex(o.vertices[1],i,r,n,s),this.projectVertex(o.vertices[2],i,r,n,s)}handlePolygon(o,t,e,r,n){var s,i;if(this.canProjectToPolygon(o)){let c=t.get(o.shared);c!==void 0&&this.projectSingle(o,c,e,(s=r.get(o.shared))!=null?s:null,(i=n==null?void 0:n.get(o.shared))!=null?i:null)}}makeAttributesMap(o,t){let e=new Map,r=new Map;if(t)for(let[n,s]of o){let i=t.get(s);if(i===void 0||i.length===0){e.set(n,[]);continue}let c=t.get(n);if(c===void 0||c.length===0)throw new Error(`Projection failed; material ID ${n} has no extra attributes and is not compatible with material ID ${s}`);let l=new Map(i.entries()),u=new Array;for(let m of c){let f=!0;for(let[h,g]of l)if(m.type===g.type){u.push(h),l.delete(h),f=!1;break}f&&(console.warn(`No matching attribute for extra attribute at index ${u.length} (mapping material ID ${n} to ${s})`),u.push(null))}if(l.size===1&&this.generatesUVs){let[m,f]=l.entries().next().value;f.type===-1&&(r.set(n,m),l.delete(m))}if(l.size>0){let m=`index${l.size>1?"es":""} ${Array.from(l.keys()).join(", ")}`;throw new Error(`Projection failed; material ID ${n} is missing some extra attributes (${m}) and is not compatible with material ID ${s}`)}e.set(n,u)}else for(let n of o.keys())e.set(n,[]);return[e,r]}projectSubtree(o,t,e,r,n){for(let s of o.treePolygons)this.handlePolygon(s,t,r,n,e);e&&(o.materials=e);for(let s of o.lowerLevels)this.projectSubtree(s,t,e,r,n)}projectOctree(o,t,e=null){let r=null;if(e&&e.size>0){r=new Map(o.materials.entries());for(let[i,c]of e)r.set(i,c)}for(let[i,c]of t)if(!o.materials.has(c)){if(r&&r.has(c))continue;let l=o.materials.get(i);r||(r=new Map(o.materials.entries())),r.set(c,l)}let[n,s]=this.makeAttributesMap(t,r);this.projectSubtree(o,t,r,n,s)}project(o,t,e=null){let[r,n]=this.makeAttributesMap(t,e);if(Symbol.iterator in o)for(let s of o)this.handlePolygon(s,t,r,n,e);else this.handlePolygon(o,t,r,n,e)}};var ve=class extends $t{constructor(t){var e,r;super(t);this.ignoreBackFaces=(e=t==null?void 0:t.ignoreBackFaces)!=null?e:!0,this.threshold=(r=t==null?void 0:t.threshold)!=null?r:0}};import{mat3 as bn,vec2 as gn,vec3 as q}from"gl-matrix";var Lt=class extends ve{constructor(t,e,r,n){var c,l;super(n);this.origin=t;this.normal=e;this.rightTangent=r;this.upTangent=q.create();this.width=(c=n==null?void 0:n.width)!=null?c:1,this.height=(l=n==null?void 0:n.height)!=null?l:1,q.cross(this.upTangent,e,r),this.invWidth=1/this.width,this.invHeight=1/this.height;let[s,i]=this.projectUV(t);this.uOffset=s+.5*this.invWidth,this.vOffset=i+.5*this.invHeight}clone(){return new Lt(q.clone(this.origin),q.clone(this.normal),q.clone(this.rightTangent),{width:this.width,height:this.height,ignoreBackFaces:this.ignoreBackFaces,threshold:this.threshold,generatesUVs:this.generatesUVs})}projectUV(t){q.sub(v,t,this.origin);let e=q.dot(this.normal,v);return q.scaleAndAdd(v,t,this.normal,-e),gn.fromValues(q.dot(v,this.rightTangent)*this.invWidth,q.dot(v,this.upTangent)*this.invHeight)}projectSingle(t,e,r,n,s){let i=q.dot(this.normal,t.plane.unsafeNormal);!(this.ignoreBackFaces&&i<=0)&&(this.threshold===0||Math.abs(i)>=this.threshold)&&super.projectSingleWithExtraData(t,e,r,n,s,void 0)}applyMatrix(t){q.transformMat4(this.origin,this.origin,t),bn.normalFromMat4(B,t),q.transformMat3(this.normal,this.normal,B),q.normalize(this.normal,this.normal),q.transformMat3(this.rightTangent,this.rightTangent,B),q.normalize(this.rightTangent,this.rightTangent),q.transformMat3(this.upTangent,this.upTangent,B),q.normalize(this.upTangent,this.upTangent)}};import{mat3 as yn,vec2 as vn,vec3 as I}from"gl-matrix";var Jt=class extends ve{constructor(t,e,r,n){var s,i,c,l;super(n);this.origin=t;this.direction=e;this.normal=r;this.binormal=I.create();I.cross(this.binormal,this.normal,this.direction),this.length=(s=n==null?void 0:n.length)!=null?s:1,this.wrapAngle=(i=n==null?void 0:n.wrapAngle)!=null?i:F,this.invLength=1/this.length,this.uMul=F/this.wrapAngle,this.useInnerFaces=(c=n==null?void 0:n.useInnerFaces)!=null?c:!1,this.invertTexCoords=(l=n==null?void 0:n.invertTexCoords)!=null?l:!1}clone(){return new Jt(I.clone(this.origin),I.clone(this.direction),I.clone(this.normal),{length:this.length,wrapAngle:this.wrapAngle,useInnerFaces:this.useInnerFaces,invertTexCoords:this.invertTexCoords,ignoreBackFaces:this.ignoreBackFaces,threshold:this.threshold,generatesUVs:this.generatesUVs})}get needsInvertedTexCoords(){return this.useInnerFaces!==this.invertTexCoords}projectUV(t,e){I.sub(O,t,this.origin);let r=I.dot(this.direction,O)*this.invLength-.5,n=I.dot(O,this.direction);I.scaleAndAdd(se,this.origin,this.direction,n),I.sub(se,t,se),I.normalize(se,se),I.cross(v,se,this.normal);let s=Math.atan2(I.dot(v,this.direction),I.dot(se,this.normal))/F+.5;return e&&s<.25?s+=1:!e&&s>.75&&(s-=1),s*=this.uMul,this.needsInvertedTexCoords||(s=1-s),vn.fromValues(s,r)}projectSingle(t,e,r,n,s){let i=t.midpoint;I.sub(O,i,this.origin);let c=I.dot(O,this.direction),l=I.create();I.scaleAndAdd(l,this.origin,this.direction,c),I.sub(l,i,l),I.normalize(l,l),I.cross(v,l,this.normal);let u=Math.atan2(I.dot(v,this.direction),I.dot(l,this.normal));this.ignoreBackFaces&&(this.useInnerFaces&&I.negate(l,l),I.dot(l,t.plane.unsafeNormal)<=0)||super.projectSingleWithExtraData(t,e,r,n,s,u>=0)}applyMatrix(t){I.transformMat4(this.origin,this.origin,t),yn.normalFromMat4(B,t),I.transformMat3(this.direction,this.direction,B),I.normalize(this.direction,this.direction),I.transformMat3(this.normal,this.normal,B),I.normalize(this.normal,this.normal),I.transformMat3(this.binormal,this.binormal,B),I.normalize(this.binormal,this.binormal)}};import{mat3 as xn,vec2 as Pn,vec3 as N}from"gl-matrix";var Ht=class extends ve{constructor(t,e,r,n){var s,i,c;super(n);this.origin=t;this.up=e;this.right=r;this.front=N.create();N.cross(this.front,this.right,this.up),this.uWrapAngle=(s=n==null?void 0:n.uWrapAngle)!=null?s:F,this.vWrapAngle=(i=n==null?void 0:n.vWrapAngle)!=null?i:Math.PI,this.uMul=F/this.uWrapAngle,this.vMul=Math.PI/this.vWrapAngle,this.useInnerFaces=(c=n==null?void 0:n.useInnerFaces)!=null?c:!1}clone(){return new Ht(N.clone(this.origin),N.clone(this.up),N.clone(this.right),{uWrapAngle:this.uWrapAngle,vWrapAngle:this.vWrapAngle,useInnerFaces:this.useInnerFaces,ignoreBackFaces:this.ignoreBackFaces,threshold:this.threshold,generatesUVs:this.generatesUVs})}projectUV(t,e){N.sub(O,t,this.origin),N.normalize(O,O);let r=this.getNormalisedAngle(O,this.up,this.right),n=this.getLatAngle(O,this.up);return!e&&r>.75?r-=1:e&&r<.25&&(r+=1),r*=this.uMul,n*=this.vMul,Pn.fromValues(r,n)}projectSingle(t,e,r,n,s){N.set(v,0,0,0);for(let l of t.vertices)N.add(v,v,l.pos);N.scale(v,v,1/t.vertices.length);let i=N.create();N.sub(i,v,this.origin),N.normalize(i,i);let c=this.getNormalisedAngle(i,this.up,this.right);this.useInnerFaces&&N.negate(i,i),!(N.dot(i,t.plane.unsafeNormal)<=0&&this.ignoreBackFaces)&&super.projectSingleWithExtraData(t,e,r,n,s,c>=.5)}getNormalisedAngle(t,e,r){return N.cross(v,t,r),Math.atan2(N.dot(v,e),N.dot(t,r))/F+.5}getLatAngle(t,e){let r=N.dot(t,e);return r>=0?1-Math.acos(r)/Math.PI:Math.acos(-r)/Math.PI}applyMatrix(t){N.transformMat4(this.origin,this.origin,t),xn.normalFromMat4(B,t),N.transformMat3(this.up,this.up,B),N.normalize(this.up,this.up),N.transformMat3(this.right,this.right,B),N.normalize(this.right,this.right),N.transformMat3(this.front,this.front,B),N.normalize(this.front,this.front)}};import{mat3 as Cn,vec2 as An,vec3 as V}from"gl-matrix";function Io(a,o,t,e){V.sub(O,e,t),V.sub(se,o,t);let r=V.dot(O,se)/V.dot(O,O);return V.scaleAndAdd(a,t,O,r),r}var Yt=class extends ve{constructor(t,e,r){var i,c,l,u,m;super(r);this.positions=t;this.curveFrames=e;this.length=(i=r==null?void 0:r.length)!=null?i:1,this.wrapAngle=(c=r==null?void 0:r.wrapAngle)!=null?c:F,this.uMul=F/this.wrapAngle,this.useInnerFaces=(l=r==null?void 0:r.useInnerFaces)!=null?l:!1,this.invertTexCoords=(u=r==null?void 0:r.invertTexCoords)!=null?u:!1,this.checkRadius=(m=r==null?void 0:r.checkRadius)!=null?m:2;let n=t.length;this.segmentLengthSums=new Array(n),this.segmentLengthSums[0]=0;let s=0;for(let f=1;f<n;f++)s+=V.distance(t[f-1],t[f]),this.segmentLengthSums[f]=s}clone(){return new Yt(this.positions,this.curveFrames,{length:this.length,wrapAngle:this.wrapAngle,useInnerFaces:this.useInnerFaces,invertTexCoords:this.invertTexCoords,ignoreBackFaces:this.ignoreBackFaces,threshold:this.threshold,generatesUVs:this.generatesUVs})}get needsInvertedTexCoords(){return this.useInnerFaces!==this.invertTexCoords}projectUV(t,e){let[r,n]=e,s=this.positions.length-1,i=Math.max(r-this.checkRadius,0),c=Math.min(r+this.checkRadius,s),l=Math.max(c-1,i),u=V.clone(this.positions[l+1]),m=V.squaredDistance(u,t),f=1;for(let x=i;x<c;x++){let w=this.positions[x],D=this.positions[x+1],$=Io(v,t,w,D);if($>=0&&$<=1){let j=V.squaredDistance(v,t);j<m&&(l=x,V.copy(u,v),m=j,f=$)}else{let j=V.squaredDistance(w,t);j<m&&(l=x,V.copy(u,w),m=j,f=0)}}let h=this.segmentLengthSums[l],g=this.segmentLengthSums[l+1]-h,d=(h+g*f)/this.length,y=this.getUNorm(t,u,f,l)/F+.5;return n&&y<.25?y+=1:!n&&y>.75&&(y-=1),y*=this.uMul,this.needsInvertedTexCoords||(y=1-y),An.fromValues(y,d)}getUNorm(t,e,r,n){let s=V.sub(v,t,e);V.normalize(s,s);let[i,c,l]=this.curveFrames[n],[u,m,f]=this.curveFrames[n+1],h=V.lerp(O,i,u,r),g=V.lerp(se,c,m,r),p=V.dot(h,s),d=V.dot(g,s);return Math.atan2(p,d)}projectSingle(t,e,r,n,s){let i=t.midpoint,c=this.positions.length-1,l=c-1,u=V.clone(this.positions[c]),m=V.squaredDistance(u,i),f=1;for(let p=0;p<c;p++){let d=this.positions[p],y=this.positions[p+1],x=Io(v,i,d,y);if(x>=0&&x<=1){let w=V.squaredDistance(v,i);w<m&&(l=p,V.copy(u,v),m=w,f=x)}else{let w=V.squaredDistance(d,i);w<m&&(l=p,V.copy(u,d),m=w,f=0)}}if(this.ignoreBackFaces){let p=V.sub(O,i,u);if(this.useInnerFaces&&V.negate(p,p),V.dot(p,t.plane.unsafeNormal)<=0)return}let g=this.getUNorm(i,u,f,l)>=0;super.projectSingleWithExtraData(t,e,r,n,s,[l,g])}applyMatrix(t){let e=this.positions.length,r=new Array(e),n=new Array(e);for(let s=0;s<e;s++){let i=V.create();V.transformMat4(i,this.positions[s],t),r[s]=i,Cn.normalFromMat4(B,t);let[c,l,u]=this.curveFrames[s],m=V.create();V.transformMat3(m,c,B),V.normalize(m,m);let f=V.create();V.transformMat3(f,l,B),V.normalize(f,f);let h=V.create();V.transformMat3(h,u,B),V.normalize(h,h)}this.positions=r,this.curveFrames=n}};export{te as CSGPrimitive,ut as CSGPrimitiveMaterialAttributes,Sr as Cone,vr as Cube,_e as CubeSphere,mt as Cuboid,Yt as CurveTubeProjector,Ar as Cylinder,Lt as FlatProjector,Mr as Icosahedron,Or as Icosphere,ie as JobError,Ur as JobFailReason,nr as MaterialAttributeStandardType,nt as MaterialAttributeTransform,ke as MaterialAttributeValueType,K as OctreeCSG,Xe as OctreeCSGJobDispatcher,X as Plane,Z as Polygon,$t as Projector,wr as Pyramid,xr as Sphere,Ht as SphereProjector,Gr as Torus,Jt as TubeProjector,Pr as UVSphere,C as Vertex,bt as curveExtrude,Me as isClockwise2DPolygon,wo as linearExtrude,Mo as makeCirclePolyline,Oo as makeCubePolyline,Vo as makeRectanglePolyline,Wt as makeRegularPolyline,Er as makeRotationMinimizingFrames,Do as makeStarPolyline,jt as partition2DPolygon,pn as rotationMinimizingCurveExtrude,Nt as split2DPolygon,_t as triangulate2DPolygon,Et as triangulateConvexPolygon,Bt as triangulateMonotone2DPolygon};
//# sourceMappingURL=OctreeCSG-ea.esm.min.js.map
