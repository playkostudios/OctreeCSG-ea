{
  "version": 3,
  "sources": ["../src/worker/JobError.ts", "../src/math/const-numbers.ts", "../src/math/winding-number.ts", "../src/worker/encode-octree.ts", "../src/math/three-triangle-intersection.ts", "../src/math/Triangle.ts", "../src/math/temp.ts", "../src/math/Plane.ts", "../src/math/Polygon.ts", "../src/math/split-polygon.ts", "../src/math/ray-intersects-triangle.ts", "../src/math/pointRounding.ts", "../src/math/Box3.ts", "../src/math/Ray.ts", "../src/base/TriangleHasher.ts", "../src/base/CSGRule.ts", "../src/base/OctreeCSG.ts", "../src/math/Vertex.ts", "../src/worker/decode-octree.ts", "../src/worker/Job.ts", "../src/worker/OctreeCSGJobDispatcher.ts", "../src/primitives/Cuboid.ts", "../src/primitives/CSGPrimitive.ts", "../src/primitives/Cube.ts", "../src/primitives/CubeSphere.ts", "../src/primitives/Sphere.ts", "../src/primitives/UVSphere.ts", "../src/primitives/Cylinder.ts", "../src/primitives/make-circular-base.ts", "../src/helpers/triangulate-convex-polygon.ts", "../src/primitives/BaseCone.ts", "../src/primitives/Cone.ts", "../src/primitives/Pyramid.ts", "../src/primitives/Icosahedron.ts", "../src/primitives/icosahedron-make-triangles.ts", "../src/primitives/Icosphere.ts", "../src/primitives/Torus.ts", "../src/helpers/linear-extrusion-helper.ts", "../src/helpers/is-clockwise-2d-polygon.ts", "../src/helpers/triangulate-monotone-2d-polygon.ts", "../src/helpers/is-clockwise-2d-triangle.ts", "../src/helpers/sort-2d-indices.ts", "../src/helpers/split-2d-polygon.ts", "../src/helpers/partition-2d-polygon.ts", "../src/helpers/triangulate-2d-polygon.ts", "../src/helpers/curve-extrusion-helper.ts", "../src/helpers/rmf-extrusion-helper.ts", "../src/polylines/regular-polyline.ts", "../src/polylines/circle-polyline.ts", "../src/polylines/cube-polyline.ts", "../src/polylines/rectangle-polyline.ts", "../src/polylines/star-polyline.ts"],
  "sourcesContent": ["export enum JobFailReason {\n    WorkerCreationFailure,\n    OperationFailure,\n    DecodeFailure,\n}\n\nexport class JobError extends Error {\n    constructor(public failReason: JobFailReason, public originalError: string) {\n        let failMessage: string;\n\n        switch(failReason) {\n            case JobFailReason.WorkerCreationFailure:\n                failMessage = 'Job failed (worker creation failed)';\n                break;\n            case JobFailReason.OperationFailure:\n                failMessage = 'Job failed (operation exception)';\n                break;\n            default:\n                failMessage = 'Job failed (decode failure)';\n        }\n\n        super(`${failMessage}: ${originalError}`);\n    }\n\n    static WorkerCreationFailure(originalError: unknown) {\n        return new JobError(JobFailReason.WorkerCreationFailure, '' + originalError);\n    }\n\n    static OperationFailure(originalError: unknown) {\n        return new JobError(JobFailReason.OperationFailure, '' + originalError);\n    }\n\n    static DecodeFailure(originalError: unknown) {\n        return new JobError(JobFailReason.DecodeFailure, '' + originalError);\n    }\n}", "export const EPSILON = 1e-5;\nexport const INV_EPSILON = 1e5;\nexport const THIRD = 1 / 3;\nexport const TAU = Math.PI * 2;\nexport const HALF_PI = Math.PI / 2;", "import { EPSILON } from './const-numbers';\n\nimport type { Polygon } from './Polygon';\n\nimport { mat3, vec3 } from 'gl-matrix';\n\n// Winding Number algorithm adapted from https://github.com/grame-cncm/faust/blob/master-dev/tools/physicalModeling/mesh2faust/vega/libraries/windingNumber/windingNumber.cpp\nconst _wV1 = vec3.create();\nconst _wV2 = vec3.create();\nconst _wV3 = vec3.create();\nconst _wP = vec3.create();\nexport const _wP_EPS_ARR = [\n    vec3.fromValues(EPSILON, 0, 0),\n    vec3.fromValues(0, EPSILON, 0),\n    vec3.fromValues(0, 0, EPSILON),\n    vec3.fromValues(-EPSILON, 0, 0),\n    vec3.fromValues(0, -EPSILON, 0),\n    vec3.fromValues(0, 0, -EPSILON)\n];\n\nconst _matrix3 = mat3.create();\nconst wNPI = 4 * Math.PI;\n\nfunction returnXYZ(arr: Float32Array, index: number): vec3 {\n    return arr.slice(index, index + 3);\n}\n\nfunction calcWindingNumber_buffer(trianglesArr: Float32Array, point: vec3) {\n    let wN = 0;\n\n    const trianglesArrLen = trianglesArr.length;\n    for (let i = 0; i < trianglesArrLen; i += 9) {\n        vec3.sub(_wV1, returnXYZ(trianglesArr, i), point);\n        vec3.sub(_wV2, returnXYZ(trianglesArr, i + 3), point);\n        vec3.sub(_wV3, returnXYZ(trianglesArr, i + 6), point);\n\n        const lenA = vec3.length(_wV1);\n        const lenB = vec3.length(_wV2);\n        const lenC = vec3.length(_wV3);\n\n        mat3.set(\n            _matrix3,\n            _wV1[0], _wV2[0], _wV3[0],\n            _wV1[1], _wV2[1], _wV3[1],\n            _wV1[2], _wV2[2], _wV3[2]\n        );\n\n        wN += 2 * Math.atan2(\n            mat3.determinant(_matrix3),\n            lenA * lenB * lenC\n                + vec3.dot(_wV1, _wV2) * lenC\n                + vec3.dot(_wV2, _wV3) * lenA\n                + vec3.dot(_wV1, _wV3) * lenB\n        );\n    }\n\n    return Math.round(wN / wNPI);\n}\n\nexport function polyInside_WindingNumber_buffer(trianglesArr: Float32Array, point: Readonly<vec3>, coplanar: boolean) {\n    vec3.copy(_wP, point);\n\n    if (calcWindingNumber_buffer(trianglesArr, _wP) !== 0) {\n        return true;\n    } else if (coplanar) {\n        for (const _wP_EPS of _wP_EPS_ARR) {\n            vec3.add(_wP, point, _wP_EPS);\n            if (calcWindingNumber_buffer(trianglesArr, _wP) !== 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nexport function prepareTriangleBuffer(polygons: Polygon[]) {\n    const array = new Float32Array(polygons.length * 3 * 3);\n\n    let bufferIndex = 0;\n    for (const polygon of polygons) {\n        const triangle = polygon.triangle;\n        array.set(triangle.a, bufferIndex);\n        bufferIndex += 3;\n        array.set(triangle.b, bufferIndex);\n        bufferIndex += 3;\n        array.set(triangle.c, bufferIndex);\n        bufferIndex += 3;\n    }\n\n    return array;\n}", "import { prepareTriangleBuffer } from '../math/winding-number';\n\nimport type { EncodedOctreeCSG } from './EncodedOctreeCSGObject';\nimport type OctreeCSG from '../base/OctreeCSG';\nimport type { Polygon } from '../math/Polygon';\n\nfunction prepareNormalBuffer(polygons: Array<Polygon>) {\n    const array = new Float32Array(polygons.length * 3 * 3);\n\n    let bufferIndex = 0;\n    for (const polygon of polygons) {\n        array.set(polygon.vertices[0].normal, bufferIndex);\n        bufferIndex += 3;\n        array.set(polygon.vertices[1].normal, bufferIndex);\n        bufferIndex += 3;\n        array.set(polygon.vertices[2].normal, bufferIndex);\n        bufferIndex += 3;\n    }\n\n    return array;\n}\n\nexport default function encodeOctree(obj: OctreeCSG, transferables: Array<ArrayBuffer>): EncodedOctreeCSG {\n    const polygons = obj.getPolygons();\n    const vertexBuffer = prepareTriangleBuffer(polygons);\n    transferables.push(vertexBuffer.buffer);\n    const normalBuffer = prepareNormalBuffer(polygons);\n    transferables.push(normalBuffer.buffer);\n    return [vertexBuffer, normalBuffer];\n}", "import type Triangle from './Triangle';\nimport type Line from './Line';\n\nimport { vec2, vec3 } from 'gl-matrix';\n\ninterface Additions {\n    coplanar: boolean,\n    source: vec3,\n    target: vec3,\n}\n\ninterface AdditionsN extends Additions {\n    N1: vec3,\n    N2: vec3,\n}\n\nconst _v1 = vec3.create();\nconst _v2 = vec3.create();\nconst _v3 = vec3.create();\n\n// https://github.com/benardp/contours/blob/master/freestyle/view_map/triangle_triangle_intersection.c\nfunction triangleIntersectsTriangle(triangleA: Triangle, triangleB: Triangle, additionsIn: Additions = { coplanar: false, source: vec3.create(), target: vec3.create() }) {\n    const additions = additionsIn as AdditionsN;\n\n    const p1 = triangleA.a;\n    const q1 = triangleA.b;\n    const r1 = triangleA.c;\n\n    const p2 = triangleB.a;\n    const q2 = triangleB.b;\n    const r2 = triangleB.c;\n\n    // Compute distance signs  of p1, q1 and r1\n    // to the plane of triangleB (p2,q2,r2)\n    vec3.sub(_v1, p2, r2);\n    vec3.sub(_v2, q2, r2);\n    const N2 = vec3.cross(vec3.create(), _v1, _v2);\n\n    vec3.sub(_v1, p1, r2);\n    const dp1 = vec3.dot(_v1, N2);\n    vec3.sub(_v1, q1, r2);\n    const dq1 = vec3.dot(_v1, N2);\n    vec3.sub(_v1, r1, r2);\n    const dr1 = vec3.dot(_v1, N2);\n\n    if (dp1 * dq1 > 0 && dp1 * dr1 > 0) {\n        return false;\n    }\n\n    // Compute distance signs  of p2, q2 and r2\n    // to the plane of triangleA (p1,q1,r1)\n    vec3.sub(_v1, q1, p1);\n    vec3.sub(_v2, r1, p1);\n    const N1 = vec3.cross(vec3.create(), _v1, _v2);\n\n    vec3.sub(_v1, p2, r1);\n    const dp2 = vec3.dot(_v1, N1);\n    vec3.sub(_v1, q2, r1);\n    const dq2 = vec3.dot(_v1, N1);\n    vec3.sub(_v1, r2, r1);\n    const dr2 = vec3.dot(_v1, N1);\n\n    if (dp2 * dq2 > 0 && dp2 * dr2 > 0) {\n        return false;\n    }\n\n    additions.N2 = N2;\n    additions.N1 = N1;\n\n    if (dp1 > 0) {\n        if (dq1 > 0) {\n            return tri_tri_intersection(r1, p1, q1, p2, r2, q2, dp2, dr2, dq2, additions);\n        } else if (dr1 > 0) {\n            return tri_tri_intersection(q1, r1, p1, p2, r2, q2, dp2, dr2, dq2, additions);\n        } else {\n            return tri_tri_intersection(p1, q1, r1, p2, q2, r2, dp2, dq2, dr2, additions);\n        }\n    } else if (dp1 < 0) {\n        if (dq1 < 0) {\n            return tri_tri_intersection(r1, p1, q1, p2, q2, r2, dp2, dq2, dr2, additions);\n        } else if (dr1 < 0) {\n            return tri_tri_intersection(q1, r1, p1, p2, q2, r2, dp2, dq2, dr2, additions);\n        } else {\n            return tri_tri_intersection(p1, q1, r1, p2, r2, q2, dp2, dr2, dq2, additions);\n        }\n    } else if (dq1 < 0) {\n        if (dr1 >= 0) {\n            return tri_tri_intersection(q1, r1, p1, p2, r2, q2, dp2, dr2, dq2, additions);\n        } else {\n            return tri_tri_intersection(p1, q1, r1, p2, q2, r2, dp2, dq2, dr2, additions);\n        }\n    } else if (dq1 > 0) {\n        if (dr1 > 0) {\n            return tri_tri_intersection(p1, q1, r1, p2, r2, q2, dp2, dr2, dq2, additions);\n        } else {\n            return tri_tri_intersection(q1, r1, p1, p2, q2, r2, dp2, dq2, dr2, additions);\n        }\n    } else if (dr1 > 0) {\n        return tri_tri_intersection(r1, p1, q1, p2, q2, r2, dp2, dq2, dr2, additions);\n    } else if (dr1 < 0) {\n        return tri_tri_intersection(r1, p1, q1, p2, r2, q2, dp2, dr2, dq2, additions);\n    } else {\n        // triangles are co-planar\n        additions.coplanar = true;\n        return coplanar_tri_tri3d(p1, q1, r1, p2, q2, r2, N1);\n    }\n}\n\nfunction tri_tri_intersection(p1: Readonly<vec3>, q1: Readonly<vec3>, r1: Readonly<vec3>, p2: Readonly<vec3>, q2: Readonly<vec3>, r2: Readonly<vec3>, dp2: number, dq2: number, dr2: number, additions: AdditionsN) {\n    if (dp2 > 0) {\n        if (dq2 > 0) {\n            return construct_intersection(p1, r1, q1, r2, p2, q2, additions);\n        } else if (dr2 > 0) {\n            return construct_intersection(p1, r1, q1, q2, r2, p2, additions);\n        } else {\n            return construct_intersection(p1, q1, r1, p2, q2, r2, additions);\n        }\n    } else if (dp2 < 0) {\n        if (dq2 < 0) {\n            return construct_intersection(p1, q1, r1, r2, p2, q2, additions);\n        } else if (dr2 < 0) {\n            return construct_intersection(p1, q1, r1, q2, r2, p2, additions);\n        } else {\n            return construct_intersection(p1, r1, q1, p2, q2, r2, additions);\n        }\n    } else if (dq2 < 0) {\n        if (dr2 >= 0) {\n            return construct_intersection(p1, r1, q1, q2, r2, p2, additions);\n        } else {\n            return construct_intersection(p1, q1, r1, p2, q2, r2, additions);\n        }\n    } else if (dq2 > 0) {\n        if (dr2 > 0) {\n            return construct_intersection(p1, r1, q1, p2, q2, r2, additions);\n        } else {\n            return construct_intersection(p1, q1, r1, q2, r2, p2, additions);\n        }\n    } else if (dr2 > 0) {\n        return construct_intersection(p1, q1, r1, r2, p2, q2, additions);\n    } else if (dr2 < 0) {\n        return construct_intersection(p1, r1, q1, r2, p2, q2, additions);\n    } else {\n        additions.coplanar = true;\n        return coplanar_tri_tri3d(p1, q1, r1, p2, q2, r2, additions.N1);\n    }\n}\n\nfunction coplanar_tri_tri3d(p1: Readonly<vec3>, q1: Readonly<vec3>, r1: Readonly<vec3>, p2: Readonly<vec3>, q2: Readonly<vec3>, r2: Readonly<vec3>, normal_1: vec3) {\n    const P1 = vec2.create(), Q1 = vec2.create(), R1 = vec2.create(),\n          P2 = vec2.create(), Q2 = vec2.create(), R2 = vec2.create();\n\n    const n_x = normal_1[0] < 0 ? -normal_1[0] : normal_1[0];\n    const n_y = normal_1[1] < 0 ? -normal_1[1] : normal_1[1];\n    const n_z = normal_1[2] < 0 ? -normal_1[2] : normal_1[2];\n\n    /* Projection of the triangles in 3D onto 2D such that the area of\n    the projection is maximized. */\n\n    // TODO maybe use Float32Array.slice if the source is contiguous\n    if (n_x > n_z && n_x >= n_y) { // Project onto plane YZ\n        P1[0] = q1[2], P1[1] = q1[1];\n        Q1[0] = p1[2], Q1[1] = p1[1];\n        R1[0] = r1[2], R1[1] = r1[1];\n\n        P2[0] = q2[2], P2[1] = q2[1];\n        Q2[0] = p2[2], Q2[1] = p2[1];\n        R2[0] = r2[2], R2[1] = r2[1];\n    } else if (n_y > n_z && n_y >= n_x) { // Project onto plane XZ\n        P1[0] = q1[0], P1[1] = q1[2];\n        Q1[0] = p1[0], Q1[1] = p1[2];\n        R1[0] = r1[0], R1[1] = r1[2];\n\n        P2[0] = q2[0], P2[1] = q2[2];\n        Q2[0] = p2[0], Q2[1] = p2[2];\n        R2[0] = r2[0], R2[1] = r2[2];\n    } else { // Project onto plane XY\n        P1[0] = p1[0], P1[1] = p1[1];\n        Q1[0] = q1[0], Q1[1] = q1[1];\n        R1[0] = r1[0], R1[1] = r1[1];\n\n        P2[0] = p2[0], P2[1] = p2[1];\n        Q2[0] = q2[0], Q2[1] = q2[1];\n        R2[0] = r2[0], R2[1] = r2[1];\n    }\n\n    return tri_tri_overlap_test_2d(P1, Q1, R1, P2, Q2, R2);\n}\n\nfunction tri_tri_overlap_test_2d(p1: vec2, q1: vec2, r1: vec2, p2: vec2, q2: vec2, r2: vec2) {\n    if (ORIENT_2D(p1, q1, r1) < 0) {\n        if (ORIENT_2D(p2, q2, r2) < 0) {\n            return ccw_tri_tri_intersection_2d(p1, r1, q1, p2, r2, q2);\n        } else {\n            return ccw_tri_tri_intersection_2d(p1, r1, q1, p2, q2, r2);\n        }\n    } else if (ORIENT_2D(p2, q2, r2) < 0) {\n        return ccw_tri_tri_intersection_2d(p1, q1, r1, p2, r2, q2);\n    } else {\n        return ccw_tri_tri_intersection_2d(p1, q1, r1, p2, q2, r2);\n    }\n}\n\nfunction ORIENT_2D(a: vec2, b: vec2, c: vec2) {\n    return ((a[0] - c[0]) * (b[1] - c[1]) - (a[1] - c[1]) * (b[0] - c[1]));\n}\n\nfunction ccw_tri_tri_intersection_2d(p1: vec2, q1: vec2, r1: vec2, p2: vec2, q2: vec2, r2: vec2) {\n    if (ORIENT_2D(p2, q2, p1) >= 0) {\n        if (ORIENT_2D(q2, r2, p1) >= 0) {\n            if (ORIENT_2D(r2, p2, p1) >= 0) {\n                return true;\n            } else {\n                return intersection_test_edge(p1, q1, r1, p2, r2);\n            }\n        } else if (ORIENT_2D(r2, p2, p1) >= 0) {\n            return intersection_test_edge(p1, q1, r1, r2, q2);\n        } else {\n            return intersection_test_vertex(p1, q1, r1, p2, q2, r2)\n        }\n    } else if (ORIENT_2D(q2, r2, p1) >= 0) {\n        if (ORIENT_2D(r2, p2, p1) >= 0) {\n            return intersection_test_edge(p1, q1, r2, q2, p2);\n        } else {\n            return intersection_test_vertex(p1, q1, r1, q2, r2, p2);\n        }\n    } else {\n        return intersection_test_vertex(p1, q1, r1, r2, p2, q2);\n    }\n}\n\nfunction intersection_test_edge(P1: vec2, Q1: vec2, R1: vec2, P2: vec2, R2: vec2) {\n    if (ORIENT_2D(R2, P2, Q1) >= 0) {\n        if (ORIENT_2D(P1, P2, Q1) >= 0) {\n            return ORIENT_2D(P1, Q1, R2) >= 0;\n        } else if (ORIENT_2D(Q1, R1, P2) >= 0) {\n            return ORIENT_2D(R1, P1, P2) >= 0;\n        }\n    } else if (ORIENT_2D(R2, P2, R1) >= 0 && ORIENT_2D(P1, P2, R1) >= 0) {\n        return ORIENT_2D(P1, R1, R2) >= 0 || ORIENT_2D(Q1, R1, R2) >= 0;\n    }\n\n    return false;\n}\n\nfunction intersection_test_vertex(P1: vec2, Q1: vec2, R1: vec2, P2: vec2, Q2: vec2, R2: vec2) {\n    if (ORIENT_2D(R2, P2, Q1) >= 0) {\n        if (ORIENT_2D(R2, Q2, Q1) <= 0) {\n            if (ORIENT_2D(P1, P2, Q1) > 0) {\n                return ORIENT_2D(P1, Q2, Q1) <= 0;\n            } else if (ORIENT_2D(P1, P2, R1) >= 0) {\n                return ORIENT_2D(Q1, R1, P2) >= 0;\n            }\n        } else if (ORIENT_2D(P1, Q2, Q1) <= 0 && ORIENT_2D(R2, Q2, R1) <= 0) {\n            return ORIENT_2D(Q1, R1, Q2) >= 0;\n        }\n    } else if (ORIENT_2D(R2, P2, R1) >= 0) {\n        if (ORIENT_2D(Q1, R1, R2) >= 0) {\n            return ORIENT_2D(P1, P2, R1) >= 0;\n        } else if (ORIENT_2D(Q1, R1, Q2) >= 0) {\n            return ORIENT_2D(R2, R1, Q2) >= 0;\n        }\n    }\n\n    return false;\n}\n\nfunction construct_intersection(p1: Readonly<vec3>, q1: Readonly<vec3>, r1: Readonly<vec3>, p2: Readonly<vec3>, q2: Readonly<vec3>, r2: Readonly<vec3>, additions: AdditionsN) {\n    let alpha: number;\n    vec3.sub(_v1, q1, p1);\n    vec3.sub(_v2, r2, p1);\n    const N = vec3.cross(vec3.create(), _v1, _v2);\n    vec3.sub(_v3, p2, p1);\n\n    if (vec3.dot(_v3, N) > 0) {\n        vec3.sub(_v1, r1, p1);\n        vec3.cross(N, _v1, _v2);\n\n        if (vec3.dot(_v3, N) <= 0) {\n            vec3.sub(_v2, q2, p1);\n            vec3.cross(N, _v1, _v2);\n\n            if (vec3.dot(_v3, N) > 0) {\n                vec3.sub(_v1, p1, p2);\n                vec3.sub(_v2, p1, r1);\n                alpha = vec3.dot(_v1, additions.N2) / vec3.dot(_v2, additions.N2);\n                vec3.scale(_v1, _v2, alpha);\n                vec3.sub(additions.source, p1, _v1);\n                vec3.sub(_v1, p2, p1);\n                vec3.sub(_v2, p2, r2);\n                alpha = vec3.dot(_v1, additions.N1) / vec3.dot(_v2, additions.N1);\n                vec3.scale(_v1, _v2, alpha);\n                vec3.sub(additions.target, p2, _v1);\n            }\n            else {\n                vec3.sub(_v1, p2, p1);\n                vec3.sub(_v2, p2, q2);\n                alpha = vec3.dot(_v1, additions.N1) / vec3.dot(_v2, additions.N1);\n                vec3.scale(_v1, _v2, alpha);\n                vec3.sub(additions.source, p2, _v1);\n                vec3.sub(_v1, p2, p1);\n                vec3.sub(_v2, p2, r2);\n                alpha = vec3.dot(_v1, additions.N1) / vec3.dot(_v2, additions.N1);\n                vec3.scale(_v1, _v2, alpha);\n                vec3.sub(additions.target, p2, _v1);\n            }\n\n            return true;\n        }\n    }\n    else {\n        vec3.sub(_v2, q2, p1);\n        vec3.cross(N, _v1, _v2);\n\n        if (vec3.dot(_v3, N) >= 0) {\n            vec3.sub(_v1, r1, p1);\n            vec3.cross(N, _v1, _v2);\n            if (vec3.dot(_v3, N) >= 0) {\n                vec3.sub(_v1, p1, p2);\n                vec3.sub(_v2, p1, r1);\n                alpha = vec3.dot(_v1, additions.N2) / vec3.dot(_v2, additions.N2);\n                vec3.scale(_v1, _v2, alpha);\n                vec3.sub(additions.source, p1, _v1);\n                vec3.sub(_v1, p1, p2);\n                vec3.sub(_v2, p1, q1);\n                alpha = vec3.dot(_v1, additions.N2) / vec3.dot(_v2, additions.N2);\n                vec3.scale(_v1, _v2, alpha);\n                vec3.sub(additions.target, p1, _v1);\n            }\n            else {\n                vec3.sub(_v1, p2, p1);\n                vec3.sub(_v2, p2, q2);\n                alpha = vec3.dot(_v1, additions.N1) / vec3.dot(_v2, additions.N1);\n                vec3.scale(_v1, _v2, alpha);\n                vec3.sub(additions.source, p2, _v1);\n                vec3.sub(_v1, p1, p2);\n                vec3.sub(_v2, p1, q1);\n                alpha = vec3.dot(_v1, additions.N2) / vec3.dot(_v2, additions.N2);\n                vec3.scale(_v1, _v2, alpha);\n                vec3.sub(additions.target, p1, _v1);\n            }\n\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction lineIntersects(line1: Line, line2: Line, points?: vec3[]) {\n    const r = vec3.sub(vec3.create(), line1.end, line1.start);\n    const s = vec3.sub(vec3.create(), line2.end, line2.start);\n    const q = vec3.sub(vec3.create(), line1.start, line2.start);\n\n    const dotqr = vec3.dot(q, r);\n    const dotqs = vec3.dot(q, s);\n    const dotrs = vec3.dot(r, s);\n    const dotrr = vec3.dot(r, r);\n    const dotss = vec3.dot(s, s);\n\n    const denom = (dotrr * dotss) - (dotrs * dotrs);\n    const numer = (dotqs * dotrs) - (dotqr * dotss);\n\n    const t = numer / denom;\n    const u = (dotqs + t * dotrs) / dotss;\n\n    const p0 = vec3.scaleAndAdd(r, line1.start, r, t);\n    const p1 = vec3.scaleAndAdd(s, line2.start, s, u);\n\n    let onSegment = false;\n    let intersects = false;\n\n    if (0 <= t && t <= 1 && 0 <= u && u <= 1) {\n        onSegment = true;\n    }\n\n    const p0p1Length = vec3.distance(p0, p1);\n\n    if (p0p1Length <= 1e-5) {\n        intersects = true;\n    }\n\n    if (!(intersects && onSegment)) {\n        return false;\n    }\n\n    if (points) {\n        points.push(p0, p1);\n    }\n\n    return true;\n}\n\nfunction getLines(triangle: Triangle) {\n    return [\n        <Line>{ start: triangle.a, end: triangle.b },\n        <Line>{ start: triangle.b, end: triangle.c },\n        <Line>{ start: triangle.c, end: triangle.a }\n    ];\n}\n\nfunction checkTrianglesIntersection(triangle1: Triangle, triangle2: Triangle, additions: Additions = { coplanar: false, source: vec3.create(), target: vec3.create() }) {\n    const triangleIntersects = triangleIntersectsTriangle(triangle1, triangle2, additions);\n    if (!triangleIntersects && additions.coplanar) {\n        const triangle1Lines = getLines(triangle1);\n        const triangle2Lines = getLines(triangle2);\n\n        for (let i = 0; i < 3; i++) {\n            for (let j = 0; j < 3; j++) {\n                if (lineIntersects(triangle1Lines[i], triangle2Lines[j])) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    return triangleIntersects;\n}\n\nexport { triangleIntersectsTriangle, checkTrianglesIntersection, getLines, lineIntersects };", "import { INV_EPSILON, THIRD } from './const-numbers';\n\nimport { vec3 } from 'gl-matrix';\n\nexport default class Triangle {\n    private _midpoint?: vec3;\n    private _hash?: number;\n\n    constructor(public a: Readonly<vec3>, public b: Readonly<vec3>, public c: Readonly<vec3>) {}\n\n    static copyAuxValues(source: Triangle, destination: Triangle) {\n        if (source._midpoint) {\n            if (destination._midpoint) {\n                vec3.copy(destination._midpoint, source._midpoint);\n            } else {\n                destination._midpoint = vec3.clone(source._midpoint);\n            }\n        }\n\n        if (source._hash) {\n            destination._hash = source._hash;\n        }\n    }\n\n    set(a: Readonly<vec3>, b: Readonly<vec3>, c: Readonly<vec3>) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this._midpoint = undefined;\n        this._hash = undefined;\n    }\n\n    get midpoint(): Readonly<vec3> {\n        // return cached version\n        if (this._midpoint) {\n            return this._midpoint;\n        }\n\n        // no cached version, calculate average point\n        this._midpoint = vec3.clone(this.a);\n        vec3.add(this._midpoint, this._midpoint, this.b);\n        vec3.add(this._midpoint, this._midpoint, this.c);\n        return vec3.scale(this._midpoint, this._midpoint, THIRD);\n    }\n\n    equals(other: Triangle) {\n        return vec3.equals(this.a, other.a) && vec3.equals(this.b, other.b) && vec3.equals(this.c, other.c);\n    }\n\n    private murmur_32_scramble(k: number): number {\n        k *= 0xcc9e2d51;\n        k = (k << 15) | (k >> 17);\n        k *= 0x1b873593;\n        return k & 0xffffffff;\n    }\n\n    private murmur3_32(data: Float32Array, seed: number): number {\n        let h = seed;\n\n        /* Read in groups of 4. */\n        const view = new Uint32Array(data.buffer);\n        for (const key of view) {\n            h ^= this.murmur_32_scramble(key);\n            h = ((h << 13) & 0xffffffff) | (h >> 19);\n            h = (h * 5 + 0xe6546b64) & 0xffffffff;\n        }\n\n        /* Finalize. */\n        h ^= view.byteLength;\n        h ^= h >> 16;\n        h = (h * 0x85ebca6b) & 0xffffffff;\n        h ^= h >> 13;\n        h = (h * 0xc2b2ae35) & 0xffffffff;\n        h ^= h >> 16;\n        return h;\n    }\n\n    get hash(): number {\n        // return cached version\n        if (this._hash !== undefined) {\n            return this._hash;\n        }\n\n        // no cached version, calculate hash\n        const data = new Float32Array([\n            this.a[0] * INV_EPSILON,\n            this.a[1] * INV_EPSILON,\n            this.a[2] * INV_EPSILON,\n            this.b[0] * INV_EPSILON,\n            this.b[1] * INV_EPSILON,\n            this.b[2] * INV_EPSILON,\n            this.c[0] * INV_EPSILON,\n            this.c[1] * INV_EPSILON,\n            this.c[2] * INV_EPSILON\n        ]);\n\n        this._hash = this.murmur3_32(data, 0xea8ed414);\n        return this._hash;\n    }\n}", "import { mat3, mat4, quat, vec2, vec3 } from 'gl-matrix';\n\nexport const tv0 = vec3.create();\nexport const tv1 = vec3.create();\nexport const tv2 = vec3.create();\nexport const tmpm3 = mat3.create();\nexport const tmpm4_0 = mat4.create();\nexport const tmpm4_1 = mat4.create();\nexport const tv0_2 = vec2.create();\nexport const tv1_2 = vec2.create();\nexport const tq0 = quat.create();", "import { tv0, tv1 } from './temp';\n\nimport { vec3, vec4 } from 'gl-matrix';\n\nexport default class Plane {\n    constructor(public buffer: vec4) {}\n\n    static fromNormal(normal: vec3, w: number) {\n        const buffer = vec4.create();\n        vec3.copy(buffer as vec3, normal);\n        buffer[3] = w;\n        return new Plane(buffer);\n    }\n\n    get w(): number {\n        return this.buffer[3];\n    }\n\n    set w(w: number) {\n        this.buffer[3] = w;\n    }\n\n    get unsafeNormal() {\n        // XXX it's unsafe to reuse normals for other purposes. only use this\n        // getter to copy the normal\n        return this.buffer as vec3;\n    }\n\n    clone() {\n        return new Plane(vec4.clone(this.buffer));\n    }\n\n    flip() {\n        vec3.negate(this.buffer as vec3, this.buffer as vec3);\n        this.w = -this.w;\n    }\n\n    delete() {\n        (this.buffer as unknown) = undefined;\n    }\n\n    equals(p: Plane) {\n        return vec4.equals(this.buffer, p.buffer);\n    }\n\n    static calculateNormal(a: Readonly<vec3>, b: Readonly<vec3>, c: Readonly<vec3>): vec3 {\n        vec3.sub(tv0, b, a);\n        vec3.sub(tv1, c, a);\n        vec3.cross(tv0, tv0, tv1);\n        vec3.normalize(tv0, tv0);\n\n        return vec3.clone(tv0);\n    }\n\n    static fromPoints(a: vec3, b: vec3, c: vec3) {\n        const n = Plane.calculateNormal(a, b, c);\n        return Plane.fromNormal(n, vec3.dot(n, a));\n    }\n}", "import Triangle from './Triangle';\nimport { tmpm3 } from './temp';\nimport Plane from './Plane';\n\nimport type Vertex from './Vertex';\n\nimport { mat3, mat4, vec3 } from 'gl-matrix';\n\nlet _polygonID = 0;\n\nexport enum PolygonState {\n    Undecided,\n    Inside,\n    Outside,\n    CoplanarBack,\n    CoplanarFront,\n}\n\nexport class Polygon {\n    id: number;\n    vertices: Vertex[];\n    shared?: number;\n    plane: Plane;\n    triangle: Triangle;\n    intersects = false;\n    state = PolygonState.Undecided;\n    previousState = PolygonState.Undecided;\n    previousStates: PolygonState[] = [];\n    valid = true;\n    coplanar = false;\n    originalValid = false;\n    newPolygon = false;\n\n    constructor(vertices: Vertex[], shared?: number) {\n        this.id = _polygonID++;\n        this.vertices = vertices.map(v => v.clone());\n        this.shared = shared;\n        this.plane = Plane.fromPoints(this.vertices[0].pos, this.vertices[1].pos, this.vertices[2].pos);\n        this.triangle = new Triangle(this.vertices[0].pos, this.vertices[1].pos, this.vertices[2].pos);\n    }\n\n    get midpoint() {\n        return this.triangle.midpoint;\n    }\n\n    applyMatrix(matrix: mat4, normalMatrixIn?: mat3) {\n        const normalMatrix = normalMatrixIn || mat3.normalFromMat4(tmpm3, matrix);\n\n        this.vertices.forEach(v => {\n            vec3.transformMat4(v.pos, v.pos, matrix);\n            vec3.transformMat3(v.normal, v.normal, normalMatrix);\n        });\n\n        this.plane.delete();\n        this.plane = Plane.fromPoints(this.vertices[0].pos, this.vertices[1].pos, this.vertices[2].pos);\n        this.triangle.set(this.vertices[0].pos, this.vertices[1].pos, this.vertices[2].pos);\n    }\n\n    reset(resetOriginal = true) {\n        this.intersects = false;\n        this.state = PolygonState.Undecided;\n        this.previousState = PolygonState.Undecided;\n        this.previousStates.length = 0;\n        this.valid = true;\n        this.coplanar = false;\n        resetOriginal && (this.originalValid = false);\n        this.newPolygon = false;\n    }\n\n    setState(state: PolygonState, keepState?: PolygonState) {\n        if (this.state === keepState) {\n            return;\n        }\n\n        this.previousState = this.state;\n        this.state !== PolygonState.Undecided && this.previousStates.push(this.state);\n        this.state = state;\n    }\n\n    checkAllStates(state: PolygonState) {\n        if (this.state !== state || (this.previousState !== state && this.previousState !== PolygonState.Undecided)) {\n            return false;\n        }\n\n        for (const previousState of this.previousStates) {\n            if (previousState !== state) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    setInvalid() {\n        this.valid = false;\n    }\n\n    setValid() {\n        this.valid = true;\n    }\n\n    clone() {\n        const polygon = new Polygon(this.vertices.map(v => v.clone()), this.shared);\n        polygon.intersects = this.intersects;\n        polygon.valid = this.valid;\n        polygon.coplanar = this.coplanar;\n        polygon.state = this.state;\n        polygon.originalValid = this.originalValid;\n        polygon.newPolygon = this.newPolygon;\n        polygon.previousState = this.previousState;\n        polygon.previousStates = this.previousStates.slice();\n\n        Triangle.copyAuxValues(this.triangle, polygon.triangle);\n\n        return polygon;\n    }\n\n    flip() {\n        this.vertices.reverse().forEach(v => v.flip());\n        const tmp = this.triangle.a;\n        this.triangle.a = this.triangle.c;\n        this.triangle.c = tmp;\n        this.plane.flip();\n    }\n\n    delete() {\n        this.vertices.forEach(v => v.delete());\n        this.vertices.length = 0;\n\n        if (this.plane) {\n            this.plane.delete();\n            (this.plane as unknown) = undefined;\n        }\n\n        (this.triangle as unknown) = undefined;\n        this.shared = undefined;\n        this.setInvalid();\n    }\n}", "import { Polygon, PolygonState } from './Polygon';\nimport { EPSILON } from './const-numbers';\nimport { tv0 } from './temp';\n\nimport type Vertex from './Vertex';\nimport type Plane from './Plane';\n\nimport { vec3 } from 'gl-matrix';\n\nexport enum ReturnPolygonType {\n    Undecided = PolygonState.Undecided,\n    Back,\n    Front,\n    CoplanarBack = PolygonState.CoplanarBack,\n    CoplanarFront = PolygonState.CoplanarFront,\n}\n\ninterface ReturnPolygon {\n    polygon: Polygon,\n    type: ReturnPolygonType\n}\n\nconst COPLANAR = 0;\nconst FRONT = 1;\nconst BACK = 2;\nconst SPANNING = 3;\n\nexport function splitPolygonByPlane(polygon: Polygon, plane: Plane, result: ReturnPolygon[] = []) {\n    const returnPolygon = <ReturnPolygon>{\n        polygon: polygon,\n        type: ReturnPolygonType.Undecided\n    };\n\n    let polygonType = 0;\n    const types = [];\n\n    for (const vertex of polygon.vertices) {\n        const t = vec3.dot(plane.unsafeNormal, vertex.pos) - plane.w;\n        const type = (t < -EPSILON) ? BACK : (t > EPSILON) ? FRONT : COPLANAR;\n        polygonType |= type;\n        types.push(type);\n    }\n\n    switch (polygonType) {\n        case COPLANAR:\n            returnPolygon.type = vec3.dot(plane.unsafeNormal, polygon.plane.unsafeNormal) > 0 ? ReturnPolygonType.CoplanarFront : ReturnPolygonType.CoplanarBack;\n            result.push(returnPolygon);\n            break;\n        case FRONT:\n            returnPolygon.type = ReturnPolygonType.Front;\n            result.push(returnPolygon);\n            break;\n        case BACK:\n            returnPolygon.type = ReturnPolygonType.Back;\n            result.push(returnPolygon);\n            break;\n        case SPANNING:\n        {\n            const f = [];\n            const b = [];\n\n            const vertCount = polygon.vertices.length;\n            for (let i = 0; i < vertCount; i++) {\n                const j = (i + 1) % vertCount;\n                const ti = types[i];\n                const tj = types[j];\n                const vi = polygon.vertices[i];\n                const vj = polygon.vertices[j];\n\n                if (ti !== BACK) {\n                    f.push(vi);\n                }\n\n                if (ti !== FRONT) {\n                    b.push(ti != BACK ? vi.clone() : vi);\n                }\n\n                if ((ti | tj) === SPANNING) {\n                    vec3.sub(tv0, vj.pos, vi.pos);\n                    const t = (plane.w - vec3.dot(plane.unsafeNormal, vi.pos)) / vec3.dot(plane.unsafeNormal, tv0);\n                    const v = vi.interpolate(vj, t);\n                    f.push(v);\n                    b.push(v.clone());\n                }\n            }\n\n            if (f.length > 3) {\n                for (const newPoly of splitPolygonArr(f)) {\n                    result.push({\n                        polygon: new Polygon(newPoly, polygon.shared),\n                        type: ReturnPolygonType.Front\n                    });\n                }\n            } else if (f.length === 3) {\n                result.push({\n                    polygon: new Polygon(f, polygon.shared),\n                    type: ReturnPolygonType.Front\n                });\n            }\n\n            if (b.length > 3) {\n                for (const newPoly of splitPolygonArr(b)) {\n                    result.push({\n                        polygon: new Polygon(newPoly, polygon.shared),\n                        type: ReturnPolygonType.Back\n                    });\n                }\n            } else if (b.length === 3) {\n                result.push({\n                    polygon: new Polygon(b, polygon.shared),\n                    type: ReturnPolygonType.Back\n                });\n            }\n\n            break;\n        }\n    }\n\n    if (result.length == 0) {\n        result.push(returnPolygon);\n    }\n\n    return result;\n}\n\nfunction splitPolygonArr(arr: Vertex[]) {\n    const resultArr = [];\n\n    if (arr.length > 4) {\n        console.warn(`[splitPolygonArr] arr.length (${arr.length}) > 4`);\n        for (let j = 3; j <= arr.length; j++) {\n            resultArr.push([\n                arr[0].clone(), arr[j - 2].clone(), arr[j - 1].clone()\n            ]);\n        }\n    } else if (vec3.squaredDistance(arr[0].pos, arr[2].pos) <= vec3.squaredDistance(arr[1].pos, arr[3].pos)) {\n        resultArr.push(\n            [arr[0].clone(), arr[1].clone(), arr[2].clone()],\n            [arr[0].clone(), arr[2].clone(), arr[3].clone()]\n        );\n    } else {\n        resultArr.push(\n            [arr[0].clone(), arr[1].clone(), arr[3].clone()],\n            [arr[1].clone(), arr[2].clone(), arr[3].clone()]\n        );\n    }\n\n    return resultArr;\n}", "import type Triangle from './Triangle';\nimport type Ray from './Ray';\n\nimport { vec3 } from 'gl-matrix';\n\nconst edge1 = vec3.create();\nconst edge2 = vec3.create();\nconst h = vec3.create();\nconst s = vec3.create();\nconst q = vec3.create();\nconst RAY_EPSILON = 1e-7;\n\nexport default function rayIntersectsTriangle(ray: Ray, triangle: Triangle, target = vec3.create()) {\n    // XXX a big chunk of the computation time is spent here. it would be nice\n    // to have a faster intersection algorithm. for example, we already have\n    // pre-calculated triangle normals. maybe find a way to reuse them?\n\n    // https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm\n    vec3.sub(edge1, triangle.b, triangle.a);\n    vec3.sub(edge2, triangle.c, triangle.a);\n    vec3.cross(h, ray.direction, edge2);\n\n    const a = vec3.dot(edge1, h);\n    if (a > -RAY_EPSILON && a < RAY_EPSILON) {\n        return null; // Ray is parallel to the triangle\n    }\n\n    vec3.sub(s, ray.origin, triangle.a);\n\n    const f = 1 / a;\n    const u = f * vec3.dot(s, h);\n    if (u < 0 || u > 1) {\n        return null;\n    }\n\n    vec3.cross(q, s, edge1);\n\n    const v = f * vec3.dot(ray.direction, q);\n    if (v < 0 || u + v > 1) {\n        return null;\n    }\n\n    // Check where intersection is\n    const t = f * vec3.dot(edge2, q);\n    if (t > RAY_EPSILON) {\n        return vec3.scaleAndAdd(target, ray.origin, ray.direction, t);\n    }\n\n    return null;\n}", "import type { vec3 } from 'gl-matrix';\n\nexport default function pointRounding(point: vec3, num = 15) {\n    point[0] = +point[0].toFixed(num);\n    point[1] = +point[1].toFixed(num);\n    point[2] = +point[2].toFixed(num);\n    return point;\n}", "import Plane from './Plane';\n\nimport type Triangle from './Triangle';\nimport type Ray from './Ray';\n\nimport { vec3 } from 'gl-matrix';\n\nconst _tv1 = vec3.create();\nconst _tv2 = vec3.create();\nconst _tv3 = vec3.create();\n\n// 3 main axis of an AABB\nconst _bxNorm: Readonly<vec3> = vec3.fromValues(1, 0, 0);\nconst _byNorm: Readonly<vec3> = vec3.fromValues(0, 1, 0);\nconst _bzNorm: Readonly<vec3> = vec3.fromValues(0, 0, 1);\n\n// temp variables for box vertices. Up, Down, Left, Right, Back (-z), Front (+z)\nconst _lub = vec3.create();\nconst _rub = vec3.create();\nconst _luf = vec3.create();\nconst _ruf = vec3.create();\nconst _ldb = vec3.create();\nconst _rdb = vec3.create();\nconst _ldf = vec3.create();\nconst _rdf = vec3.create();\n\n// temp variables for triangle edges\nconst _ba = vec3.create();\nconst _cb = vec3.create();\nconst _ac = vec3.create();\n\nexport default class Box3 {\n    constructor(public min = vec3.create(), public max = vec3.create()) {}\n\n    clone(): Box3 {\n        return new Box3(vec3.clone(this.min), vec3.clone(this.max));\n    }\n\n    expandByPoint(point: Readonly<vec3>) {\n        vec3.min(this.min, this.min, point);\n        vec3.max(this.max, this.max, point);\n    }\n\n    expandByScalar(scalar: number) {\n        vec3.set(_tv1, scalar, scalar, scalar);\n        vec3.sub(this.min, this.min, _tv1);\n        vec3.add(this.max, this.max, _tv1);\n    }\n\n    private _project(points: Readonly<Readonly<vec3>[]>, normal: Readonly<vec3>): [min: number, max: number] {\n        const count = points.length;\n        let min = vec3.dot(points[0], normal);\n        let max = min;\n\n        for (let i = 1; i < count; i++) {\n            const dotProd = vec3.dot(points[i], normal);\n            min = Math.min(min, dotProd);\n            max = Math.max(max, dotProd);\n        }\n\n        return [min, max];\n    }\n\n    private _testNormal(boxAxisMin: number, boxAxisMax: number, normal: Readonly<vec3>, vertices: Readonly<Readonly<vec3>[]>): boolean {\n        const [min, max] = this._project(vertices, normal);\n        return max < boxAxisMin || min > boxAxisMax;\n    }\n\n    private _testECP(triEdge: Readonly<vec3>, boxNormal: Readonly<vec3>, triVerts: Readonly<Readonly<vec3>[]>, boxVerts: Readonly<Readonly<vec3>[]>): boolean {\n        const axis = vec3.cross(_tv1, triEdge, boxNormal);\n        const [boxMin, boxMax] = this._project(boxVerts, axis);\n        const [triMin, triMax] = this._project(triVerts, axis);\n        return boxMax < triMin || boxMin > triMax;\n    }\n\n    intersectsTriangle(triangle: Triangle): boolean {\n        // AABB and triangle intersection algorithm from:\n        // https://stackoverflow.com/a/17503268\n        // using fix from:\n        // https://stackoverflow.com/a/23456651\n\n        // test box normals\n        const triVerts = [triangle.a, triangle.b, triangle.c];\n\n        if (\n            this._testNormal(this.min[0], this.max[0], _bxNorm, triVerts) ||\n            this._testNormal(this.min[1], this.max[1], _byNorm, triVerts) ||\n            this._testNormal(this.min[2], this.max[2], _bzNorm, triVerts)\n        ) {\n            return false;\n        }\n\n        // test triangle normal\n        const triNorm = Plane.calculateNormal(triangle.a, triangle.b, triangle.c);\n        const triOffset = vec3.dot(triNorm, triangle.a);\n        const boxVerts = [\n            vec3.set(_lub, this.min[0], this.max[1], this.min[2]),\n            vec3.set(_rub, this.max[0], this.max[1], this.min[2]),\n            vec3.set(_luf, this.min[0], this.max[1], this.max[2]),\n            vec3.set(_ruf, this.max[0], this.max[1], this.max[2]),\n            vec3.set(_ldb, this.min[0], this.min[1], this.min[2]),\n            vec3.set(_rdb, this.max[0], this.min[1], this.min[2]),\n            vec3.set(_ldf, this.min[0], this.min[1], this.max[2]),\n            vec3.set(_rdf, this.max[0], this.min[1], this.max[2])\n        ];\n\n        const [boxMin, boxMax] = this._project(boxVerts, triNorm);\n        if (boxMax < triOffset || boxMin > triOffset) {\n            return false;\n        }\n\n        // test nine edge cross-products\n        vec3.sub(_ba, triangle.a, triangle.b);\n        vec3.sub(_cb, triangle.b, triangle.c);\n        vec3.sub(_ac, triangle.c, triangle.a);\n\n        return !(\n            this._testECP(_ba, _bxNorm, triVerts, boxVerts) ||\n            this._testECP(_ba, _byNorm, triVerts, boxVerts) ||\n            this._testECP(_ba, _bzNorm, triVerts, boxVerts) ||\n            this._testECP(_cb, _bxNorm, triVerts, boxVerts) ||\n            this._testECP(_cb, _byNorm, triVerts, boxVerts) ||\n            this._testECP(_cb, _bzNorm, triVerts, boxVerts) ||\n            this._testECP(_ac, _bxNorm, triVerts, boxVerts) ||\n            this._testECP(_ac, _byNorm, triVerts, boxVerts) ||\n            this._testECP(_ac, _bzNorm, triVerts, boxVerts)\n        );\n    }\n\n    intersectsBox(box: Box3): boolean {\n        return !(\n            this.min[0] > box.max[0] || this.max[0] < box.min[0] ||\n            this.min[1] > box.max[1] || this.max[1] < box.min[1] ||\n            this.min[2] > box.max[2] || this.max[2] < box.min[2]\n        );\n    }\n\n    intersectsRay(ray: Ray): boolean {\n        // AABB and line intersection algorithm from:\n        // https://tavianator.com/2022/ray_box_boundary.html\n        // adapted to handle directional rays instead of bi-directional lines\n\n        // dir_inv\n        vec3.inverse(_tv3, ray.direction);\n\n        // t1\n        vec3.sub(_tv1, this.min, ray.origin);\n        vec3.mul(_tv1, _tv1, _tv3);\n\n        // t2\n        vec3.sub(_tv2, this.max, ray.origin);\n        vec3.mul(_tv2, _tv2, _tv3);\n\n        const tmax = Math.max(_tv1[0], _tv2[0], _tv1[1], _tv2[1], _tv1[2], _tv2[2]);\n        if (tmax < 0) {\n            return false;\n        }\n\n        const tmin = Math.min(_tv1[0], _tv2[0], _tv1[1], _tv2[1], _tv1[2], _tv2[2]);\n        return tmin <= tmax;\n    }\n\n    containsPoint(point: Readonly<vec3>): boolean {\n        return point[0] >= this.min[0] && point[0] <= this.max[0]\n            && point[1] >= this.min[1] && point[1] <= this.max[1]\n            && point[2] >= this.min[2] && point[2] <= this.max[2];\n    }\n\n    makeEmpty() {\n        vec3.set(this.min, 0, 0, 0);\n        vec3.set(this.max, 0, 0, 0);\n    }\n}", "import { vec3 } from 'gl-matrix';\n\nexport default class Ray {\n    origin = vec3.create();\n    direction = vec3.fromValues(0, 0, -1);\n}", "import type Triangle from '../math/Triangle';\n\nexport default class TriangleHasher {\n    buckets = new Map<number, Triangle[]>;\n    // buckets = new Set<string>();\n\n    isUnique(triangle: Triangle) {\n        const hash = triangle.hash;\n        let arr = this.buckets.get(hash);\n\n        if (arr) {\n            for (const other of arr) {\n                if (triangle.equals(other)) {\n                    return false;\n                }\n            }\n\n            arr.push(triangle);\n        } else {\n            arr = [triangle];\n        }\n\n        return true;\n\n        // const hash1 = `{${triangle.a[0]},${triangle.a[1]},${triangle.a[2]}}-{${triangle.b[0]},${triangle.b[1]},${triangle.b[2]}}-{${triangle.c[0]},${triangle.c[1]},${triangle.c[2]}}`;\n\n        // if (this.buckets.has(hash1)) {\n        //     return false;\n        // } else {\n        //     this.buckets.add(hash1);\n        //     return true;\n        // }\n    }\n\n    clear() {\n        this.buckets.clear();\n    }\n}", "import { PolygonState } from '../math/Polygon';\n\ntype CSGRule = {\n    array: true,\n    rule: PolygonState[]\n} | {\n    array: false,\n    rule: PolygonState\n};\n\nexport type CSGRulesArray = CSGRule[];\n\nexport const CSG_Rules = {\n    union: {\n        a: <CSGRulesArray>[\n            {\n                array: true,\n                rule: [PolygonState.Inside, PolygonState.CoplanarBack]\n            },\n            {\n                array: false,\n                rule: PolygonState.Inside\n            }\n        ],\n        b: <CSGRulesArray>[\n            {\n                array: true,\n                rule: [PolygonState.Inside, PolygonState.CoplanarBack]\n            },\n            {\n                array: true,\n                rule: [PolygonState.Inside, PolygonState.CoplanarFront]\n            },\n            {\n                array: false,\n                rule: PolygonState.Inside\n            }\n        ]\n    },\n    subtract: {\n        a: <CSGRulesArray>[\n            {\n                array: true,\n                rule: [PolygonState.Inside, PolygonState.CoplanarBack]\n            },\n            {\n                array: true,\n                rule: [PolygonState.Inside, PolygonState.CoplanarFront]\n            },\n            {\n                array: false,\n                rule: PolygonState.Inside\n            }\n        ],\n        b: <CSGRulesArray>[\n            {\n                array: true,\n                rule: [PolygonState.Outside, PolygonState.CoplanarBack]\n            },\n            {\n                array: true,\n                rule: [PolygonState.Outside, PolygonState.CoplanarFront]\n            },\n            {\n                array: true,\n                rule: [PolygonState.Inside, PolygonState.CoplanarFront]\n            },\n            {\n                array: false,\n                rule: PolygonState.Outside\n            }\n        ]\n    },\n    intersect: {\n        a: <CSGRulesArray>[\n            {\n                array: true,\n                rule: [PolygonState.Inside, PolygonState.CoplanarBack]\n            },\n            {\n                array: true,\n                rule: [PolygonState.Outside, PolygonState.CoplanarFront]\n            },\n            {\n                array: true,\n                rule: [PolygonState.Outside, PolygonState.CoplanarBack]\n            },\n            {\n                array: false,\n                rule: PolygonState.Outside\n            }\n        ],\n        b: <CSGRulesArray>[\n            {\n                array: true,\n                rule: [PolygonState.Inside, PolygonState.CoplanarFront]\n            },\n            {\n                array: true,\n                rule: [PolygonState.Inside, PolygonState.CoplanarBack]\n            },\n            {\n                array: true,\n                rule: [PolygonState.Outside, PolygonState.CoplanarFront]\n            },\n            {\n                array: true,\n                rule: [PolygonState.Outside, PolygonState.CoplanarBack]\n            },\n            {\n                array: false,\n                rule: PolygonState.Outside\n            }\n        ]\n    }\n};", "import { polyInside_WindingNumber_buffer, _wP_EPS_ARR, prepareTriangleBuffer } from '../math/winding-number';\nimport { checkTrianglesIntersection } from '../math/three-triangle-intersection';\nimport { ReturnPolygonType, splitPolygonByPlane } from '../math/split-polygon';\nimport rayIntersectsTriangle from '../math/ray-intersects-triangle';\nimport pointRounding from '../math/pointRounding';\nimport { EPSILON } from '../math/const-numbers';\nimport { PolygonState } from '../math/Polygon';\nimport { tmpm3 } from '../math/temp';\nimport Box3 from '../math/Box3';\nimport Ray from '../math/Ray';\n\nimport type { Polygon } from '../math/Polygon';\nimport type Triangle from '../math/Triangle';\n\nimport { JobError, JobFailReason } from '../worker/JobError';\nimport TriangleHasher from './TriangleHasher';\nimport { CSG_Rules } from './CSGRule';\n\nimport type { OctreeCSGObject } from './OctreeCSGObject';\nimport type { CSGRulesArray } from './CSGRule';\n\nimport { mat3, mat4, vec3 } from 'gl-matrix';\n\nconst _v1 = vec3.create();\nconst _v2 = vec3.create();\nconst _v3 = vec3.create();\n\nconst _ray = new Ray();\nconst _rayDirection = vec3.fromValues(0, 0, 1);\n\ninterface RayIntersect {\n    distance: number,\n    polygon: Polygon,\n    position: vec3\n}\n\nexport default class OctreeCSG {\n    protected polygons: Polygon[];\n    protected replacedPolygons: Polygon[];\n    protected box?: Box3;\n    protected subTrees: OctreeCSG[];\n    protected parent: OctreeCSG | null;\n    protected level: number;\n    protected polygonArrays: Polygon[][];\n\n    static disposeOctree = true;\n    static useWindingNumber = false;\n    static maxLevel = 16;\n    static polygonsPerTree = 100;\n\n    constructor(box?: Box3, parent: OctreeCSG | null = null) {\n        this.polygons = [];\n        this.replacedPolygons = [];\n        this.box = box;\n        this.subTrees = [];\n        this.parent = parent;\n        this.level = 0;\n        this.polygonArrays = [];\n        this.addPolygonsArrayToRoot(this.polygons);\n    }\n\n    clone() {\n        return new OctreeCSG().copy(this);\n    }\n\n    copy(source: OctreeCSG) {\n        this.deletePolygonsArrayFromRoot(this.polygons);\n        this.polygons = source.polygons.map(p => p.clone());\n        this.addPolygonsArrayToRoot(this.polygons);\n\n        this.replacedPolygons = source.replacedPolygons.map(p => p.clone());\n        this.box = source.box?.clone();\n        this.level = source.level;\n\n        for (const subTree of source.subTrees) {\n            this.subTrees.push(new OctreeCSG(undefined, this).copy(subTree));\n        }\n\n        return this;\n    }\n\n    protected addPolygonsArrayToRoot(array: Polygon[]) {\n        if (this.parent) {\n            this.parent.addPolygonsArrayToRoot(array);\n        } else {\n            this.polygonArrays.push(array);\n        }\n    }\n\n    protected deletePolygonsArrayFromRoot(array: Polygon[]) {\n        if (this.parent) {\n            this.parent.deletePolygonsArrayFromRoot(array);\n        } else {\n            const index = this.polygonArrays.indexOf(array);\n\n            if (index > -1) {\n                this.polygonArrays.splice(index, 1);\n            }\n        }\n    }\n\n    isEmpty() {\n        return this.polygons.length === 0;\n    }\n\n    addPolygon(polygon: Polygon, triangleHasher?: TriangleHasher) {\n        const triangle = polygon.triangle;\n\n        if (triangleHasher && !triangleHasher.isUnique(triangle)) {\n            return this;\n        }\n\n        if (this.box) {\n            this.box.min[0] = Math.min(this.box.min[0], triangle.a[0], triangle.b[0], triangle.c[0]);\n            this.box.min[1] = Math.min(this.box.min[1], triangle.a[1], triangle.b[1], triangle.c[1]);\n            this.box.min[2] = Math.min(this.box.min[2], triangle.a[2], triangle.b[2], triangle.c[2]);\n            this.box.max[0] = Math.max(this.box.max[0], triangle.a[0], triangle.b[0], triangle.c[0]);\n            this.box.max[1] = Math.max(this.box.max[1], triangle.a[1], triangle.b[1], triangle.c[1]);\n            this.box.max[2] = Math.max(this.box.max[2], triangle.a[2], triangle.b[2], triangle.c[2]);\n        } else {\n            this.box = new Box3();\n            this.box.min[0] = Math.min(triangle.a[0], triangle.b[0], triangle.c[0]);\n            this.box.min[1] = Math.min(triangle.a[1], triangle.b[1], triangle.c[1]);\n            this.box.min[2] = Math.min(triangle.a[2], triangle.b[2], triangle.c[2]);\n            this.box.max[0] = Math.max(triangle.a[0], triangle.b[0], triangle.c[0]);\n            this.box.max[1] = Math.max(triangle.a[1], triangle.b[1], triangle.c[1]);\n            this.box.max[2] = Math.max(triangle.a[2], triangle.b[2], triangle.c[2]);\n        }\n\n        this.polygons.push(polygon);\n        return this;\n    }\n\n    protected split(level: number) {\n        if (!this.box) {\n            throw new Error('Octree has no box');\n        }\n\n        const subTrees = [];\n        vec3.sub(_v2, this.box.max, this.box.min);\n        const halfsize = vec3.scale(_v2, _v2, 0.5);\n        for (let x = 0; x < 2; x++) {\n            for (let y = 0; y < 2; y++) {\n                for (let z = 0; z < 2; z++) {\n                    const box = new Box3();\n                    const v = vec3.set(_v1, x, y, z);\n\n                    vec3.multiply(_v3, v, halfsize);\n                    vec3.add(box.min, this.box.min, _v3);\n                    vec3.add(box.max, box.min, halfsize);\n                    box.expandByScalar(EPSILON);\n                    subTrees.push(new OctreeCSG(box, this));\n                }\n            }\n        }\n\n        let polygon;\n        while ((polygon = this.polygons.pop())) { // XXX assignment is on purpose\n            let found = false;\n            for (let i = 0; i < subTrees.length; i++) {\n                const subTree = subTrees[i];\n                const subBox = subTree.box;\n\n                if (!subBox) {\n                    throw new Error('Subtree has no box');\n                }\n\n                if (subBox.containsPoint(polygon.midpoint)) {\n                    subTree.polygons.push(polygon);\n                    found = true;\n                }\n            }\n\n            if (!found) {\n                console.error('ERROR: unable to find subtree for:', polygon.triangle);\n                throw new Error(`Unable to find subtree for triangle at level ${level}`);\n            }\n        }\n\n        for (const subTree of subTrees) {\n            subTree.level = level + 1;\n            const len = subTree.polygons.length;\n\n            if (len > OctreeCSG.polygonsPerTree && level < OctreeCSG.maxLevel) {\n                subTree.split(level + 1);\n\n            }\n            this.subTrees.push(subTree);\n        }\n\n        return this;\n    }\n\n    buildTree() {\n        this.split(0);\n        this.processTree();\n\n        return this;\n    }\n\n    protected processTree() {\n        if (!this.isEmpty()) {\n            if (!this.box) {\n                this.box = new Box3();\n            }\n\n            const firstPolygon = this.polygons[0];\n            const firstVertex = firstPolygon.triangle.a;\n            vec3.copy(this.box.min, firstVertex);\n            vec3.copy(this.box.max, firstVertex);\n\n            for (const polygon of this.polygons) {\n                this.box.expandByPoint(polygon.triangle.a);\n                this.box.expandByPoint(polygon.triangle.b);\n                this.box.expandByPoint(polygon.triangle.c);\n            }\n\n            this.expandParentBox();\n        }\n\n        for (const subTree of this.subTrees) {\n            subTree.processTree();\n        }\n    }\n\n    protected expandParentBox() {\n        if (this.parent) {\n            if (!this.box) {\n                throw new Error('Octree has no box');\n            }\n\n            if (!this.parent.box) {\n                throw new Error('Octree\\'s parent has no box');\n            }\n\n            this.parent.box.expandByPoint(this.box.min);\n            this.parent.box.expandByPoint(this.box.max);\n            this.parent.expandParentBox();\n        }\n    }\n\n    getPolygonsIntersectingPolygon(targetPolygon: Polygon, polygons: Polygon[] = []) {\n        if (!this.box) {\n            throw new Error('Octree has no box');\n        }\n\n        if (this.polygons.length > 0 && this.box.intersectsTriangle(targetPolygon.triangle)) {\n            handlePolygonArrayIntersections(targetPolygon, polygons, this.polygons);\n            handlePolygonArrayIntersections(targetPolygon, polygons, this.replacedPolygons);\n        }\n\n        for (const subTree of this.subTrees) {\n            subTree.getPolygonsIntersectingPolygon(targetPolygon, polygons);\n        }\n\n        return polygons;\n    }\n\n    getRayPolygons(ray: Ray, polygons?: Set<Polygon>) {\n        // XXX if the replaced polygons array are not creating a new set, then\n        // using a set is actually slower than using an array and calling\n        // indexOf. when an API such as Set.addAll is added, then using a set\n        // will always be faster than an array. the average case\n\n        if (polygons) {\n            for (const replacedPolygon of this.replacedPolygons) {\n                polygons.add(replacedPolygon);\n            }\n        } else {\n            polygons = new Set(this.replacedPolygons);\n        }\n\n        for (const polygon of this.polygons) {\n            if (polygon.valid && polygon.originalValid) {\n                polygons.add(polygon);\n            }\n        }\n\n        for (const subTree of this.subTrees) {\n            if ((subTree.box as Box3).intersectsRay(ray)) {\n                subTree.getRayPolygons(ray, polygons);\n            }\n        }\n\n        return polygons;\n    }\n\n    rayIntersect(ray: Ray, intersects: RayIntersect[] = []) {\n        if (vec3.squaredLength(ray.direction) === 0) return [];\n\n        let distance = 1e100;\n\n        for (const polygon of this.getRayPolygons(ray)) {\n            // MollerTrumbore\n            const result = rayIntersectsTriangle(ray, polygon.triangle, _v1);\n            if (result) {\n                const newdistance = vec3.distance(result, ray.origin);\n                if (distance > newdistance) {\n                    distance = newdistance;\n                }\n                if (distance < 1e100) {\n                    intersects.push({ distance, polygon, position: vec3.add(vec3.create(), result, ray.origin) });\n                }\n            }\n        }\n\n        intersects.length && intersects.sort(raycastIntersectAscSort);\n        return intersects;\n    }\n\n    getIntersectingPolygons(polygons: Polygon[] = []) {\n        for(const polygonsArray of this.polygonArrays) {\n            for (const polygon of polygonsArray) {\n                if (polygon.valid && polygon.intersects) {\n                    polygons.push(polygon);\n                }\n            }\n        }\n\n        return polygons;\n    }\n\n    getPolygons(polygons: Polygon[] = []) {\n        for(const polygonsArray of this.polygonArrays) {\n            for (const polygon of polygonsArray) {\n                if (polygon.valid && polygons.indexOf(polygon) === -1) {\n                    polygons.push(polygon);\n                }\n            }\n        }\n\n        return polygons;\n    }\n\n    invert() {\n        for(const polygonsArray of this.polygonArrays) {\n            for(const polygon of polygonsArray) {\n                if (polygon.valid) {\n                    polygon.flip();\n                }\n            }\n        }\n    }\n\n    protected replacePolygon(polygon: Polygon, newPolygons: Polygon[] | Polygon) {\n        if (!Array.isArray(newPolygons)) {\n            newPolygons = [newPolygons];\n        }\n\n        if (this.polygons.length > 0) {\n            const polygonIndex = this.polygons.indexOf(polygon);\n            if (polygonIndex > -1) {\n                if (polygon.originalValid) {\n                    this.replacedPolygons.push(polygon);\n                } else {\n                    polygon.setInvalid();\n                }\n\n                this.polygons.splice(polygonIndex, 1, ...newPolygons);\n            }\n        }\n\n        for (const subTree of this.subTrees) {\n            subTree.replacePolygon(polygon, newPolygons);\n        }\n    }\n\n    protected deletePolygonsByStateRules(rulesArr: CSGRulesArray, firstRun = true) {\n        for(const polygonsArray of this.polygonArrays) {\n            if (polygonsArray.length === 0) {\n                continue;\n            }\n\n            for(const polygon of polygonsArray.slice()) {\n                if (!polygon.valid || !polygon.intersects) {\n                    continue;\n                }\n\n                let found = false;\n                for (const rule of rulesArr) {\n                    if (rule.array) {\n                        const states = rule.rule;\n                        if (states.includes(polygon.state) && (((polygon.previousState !== PolygonState.Undecided) && (states.includes(polygon.previousState))) || polygon.previousState === PolygonState.Undecided)) {\n                            found = true;\n                            const missingStates = new Set<PolygonState>();\n\n                            for(const state of states) {\n                                missingStates.add(state);\n                            }\n\n                            missingStates.delete(polygon.state);\n\n                            for (const previousState of polygon.previousStates) {\n                                if (!states.includes(previousState)) { // if previous state not one of provided states (not included in states array), break\n                                    found = false;\n                                    break;\n                                } else {\n                                    missingStates.delete(previousState);\n                                }\n                            }\n\n                            if (found) {\n                                if (missingStates.size > 0) {\n                                    found = false;\n                                } else {\n                                    break;\n                                }\n                            }\n                        }\n                    } else if (polygon.checkAllStates(rule.rule)) {\n                        found = true;\n                        break;\n                    }\n                }\n\n                if (found) {\n                    const polygonIndex = polygonsArray.indexOf(polygon);\n                    if (polygonIndex > -1) {\n                        polygon.setInvalid();\n                        polygonsArray.splice(polygonIndex, 1);\n                    }\n\n                    if (firstRun) {\n                        polygon.delete();\n                    }\n                }\n            }\n        }\n    }\n\n    protected deletePolygonsByIntersection(intersects: boolean, firstRun = true) {\n        for(const polygonsArray of this.polygonArrays) {\n            if (polygonsArray.length === 0) {\n                continue;\n            }\n\n            for(const polygon of polygonsArray.slice()) {\n                if (polygon.valid && polygon.intersects === intersects) {\n                    const polygonIndex = polygonsArray.indexOf(polygon);\n                    if (polygonIndex > -1) {\n                        polygon.setInvalid();\n                        polygonsArray.splice(polygonIndex, 1);\n                    }\n\n                    if (firstRun) {\n                        polygon.delete();\n                    }\n                }\n            }\n        }\n    }\n\n    isPolygonIntersecting(polygon: Polygon) {\n        if (!this.box) {\n            throw new Error('Octree has no box');\n        }\n\n        return this.box.intersectsTriangle(polygon.triangle);\n    }\n\n    protected markIntersectingPolygons(targetOctree: OctreeCSG) {\n        for(const polygonsArray of this.polygonArrays) {\n            for (const polygon of polygonsArray) {\n                polygon.intersects = targetOctree.isPolygonIntersecting(polygon);\n            }\n        }\n    }\n\n    protected resetPolygons(resetOriginal = true) {\n        for(const polygonsArray of this.polygonArrays) {\n            for (const polygon of polygonsArray) {\n                polygon.reset(resetOriginal);\n            }\n        }\n    }\n\n    protected handleIntersectingPolygons(targetOctree: OctreeCSG, targetOctreeBuffer?: Float32Array) {\n        if (OctreeCSG.useWindingNumber && !targetOctreeBuffer) {\n            throw new Error('targetOctreeBuffer must be set if using winding number');\n        }\n\n        if (this.polygons.length > 0) {\n            let polygonStack = this.polygons.filter(polygon => polygon.valid && polygon.intersects && polygon.state === PolygonState.Undecided);\n\n            let currentPolygon;\n            while ((currentPolygon = polygonStack.pop())) { // XXX assignment is on purpose\n                if (currentPolygon.state !== PolygonState.Undecided || !currentPolygon.valid) {\n                    continue;\n                }\n\n                const targetPolygons = targetOctree.getPolygonsIntersectingPolygon(currentPolygon);\n                for (const target of targetPolygons) {\n                    const splitResults = splitPolygonByPlane(currentPolygon, target.plane);\n\n                    if (splitResults.length > 1) {\n                        for (const result of splitResults) {\n                            const polygon = result.polygon;\n                            polygon.intersects = currentPolygon.intersects;\n                            polygon.newPolygon = true;\n                            polygonStack.push(polygon);\n                        }\n\n                        this.replacePolygon(currentPolygon, splitResults.map(result => result.polygon));\n                        break;\n                    } else {\n                        const singleResult = splitResults[0];\n\n                        if (currentPolygon.id !== singleResult.polygon.id) {\n                            singleResult.polygon.intersects = currentPolygon.intersects;\n                            singleResult.polygon.newPolygon = true;\n                            polygonStack.push(singleResult.polygon);\n                            this.replacePolygon(currentPolygon, singleResult.polygon);\n                            break;\n                        } else if (singleResult.type === ReturnPolygonType.CoplanarFront || singleResult.type === ReturnPolygonType.CoplanarBack) {\n                            // XXX conversion from ReturnPolygonType to PolygonState is intentional\n                            // the values of CoplanarFront and CoplanarBack match by definition for both enums\n                            currentPolygon.setState(singleResult.type as unknown as PolygonState);\n                            currentPolygon.coplanar = true;\n                        }\n                    }\n                }\n            }\n\n            polygonStack = this.polygons.filter(polygon => polygon.valid && polygon.intersects);\n            let inside = false;\n\n            while ((currentPolygon = polygonStack.pop())) { // XXX assignment is on purpose\n                if (!currentPolygon.valid) {\n                    continue;\n                }\n\n                if (!targetOctree.box) {\n                    throw new Error('Octree has no box');\n                }\n\n                inside = false;\n                if (targetOctree.box.containsPoint(currentPolygon.midpoint)) {\n                    if (OctreeCSG.useWindingNumber) {\n                        inside = polyInside_WindingNumber_buffer(targetOctreeBuffer as Float32Array, currentPolygon.midpoint, currentPolygon.coplanar);\n                    } else {\n                        const point = pointRounding(vec3.copy(_v2, currentPolygon.midpoint));\n\n                        vec3.copy(_ray.origin, point);\n                        vec3.copy(_rayDirection, currentPolygon.plane.unsafeNormal);\n                        vec3.copy(_ray.direction, currentPolygon.plane.unsafeNormal);\n\n                        let intersects = targetOctree.rayIntersect(_ray);\n                        if (intersects.length > 0 && vec3.dot(_rayDirection, intersects[0].polygon.plane.unsafeNormal) > 0) {\n                            inside = true;\n                        } else if (currentPolygon.coplanar) {\n                            for (const _wP_EPS of _wP_EPS_ARR) {\n                                vec3.add(_ray.origin, point, _wP_EPS);\n                                vec3.copy(_rayDirection, currentPolygon.plane.unsafeNormal);\n                                vec3.copy(_ray.direction, currentPolygon.plane.unsafeNormal);\n\n                                intersects = targetOctree.rayIntersect(_ray);\n                                if (intersects.length > 0 && vec3.dot(_rayDirection, intersects[0].polygon.plane.unsafeNormal) > 0) {\n                                    inside = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                currentPolygon.setState(inside ? PolygonState.Inside : PolygonState.Outside);\n            }\n        }\n\n        for (const subTree of this.subTrees) {\n            subTree.handleIntersectingPolygons(targetOctree, targetOctreeBuffer);\n        }\n    }\n\n    delete(deletePolygons = true) {\n        if (this.polygons.length > 0 && deletePolygons) {\n            for (const polygon of this.polygons) {\n                polygon.delete();\n            }\n\n            this.polygons.length = 0;\n        }\n\n        if (this.replacedPolygons.length > 0 && deletePolygons) {\n            for (const polygon of this.replacedPolygons) {\n                polygon.delete();\n            }\n\n            this.replacedPolygons.length = 0;\n        }\n\n        if (this.polygonArrays) {\n            this.polygonArrays.length = 0;\n        }\n\n        if (this.subTrees.length) {\n            for (const subTree of this.subTrees) {\n                subTree.delete(deletePolygons);\n            }\n\n            this.subTrees.length = 0;\n        }\n\n        this.box = undefined;\n        this.parent = null;\n        this.level = 0;\n    }\n\n    dispose(deletePolygons = true) {\n        this.delete(deletePolygons);\n    }\n\n    protected getPolygonCloneCallback(cbFunc: (polygon: Polygon, triangleHasher: TriangleHasher) => unknown, triangleHasher: TriangleHasher) {\n        for (const polygonsArray of this.polygonArrays) {\n            for (const polygon of polygonsArray) {\n                if (polygon.valid) {\n                    cbFunc(polygon.clone(), triangleHasher);\n                }\n            }\n        }\n    }\n\n    protected deleteReplacedPolygons() {\n        if (this.replacedPolygons.length > 0) {\n            for (const polygon of this.replacedPolygons) {\n                polygon.delete();\n            }\n\n            this.replacedPolygons.length = 0;\n        }\n\n        for (const subTree of this.subTrees) {\n            subTree.deleteReplacedPolygons();\n        }\n    }\n\n    protected markPolygonsAsOriginal() {\n        for(const polygonsArray of this.polygonArrays) {\n            for (const polygon of polygonsArray) {\n                polygon.originalValid = true;\n            }\n        }\n    }\n\n    applyMatrix(matrix: mat4, normalMatrix?: mat3, firstRun = true) {\n        if (this.box) {\n            this.box = undefined;\n        }\n\n        if (!normalMatrix) {\n            normalMatrix = mat3.normalFromMat4(tmpm3, matrix);\n        }\n\n        for (const polygon of this.polygons) {\n            if (polygon.valid) {\n                polygon.applyMatrix(matrix, normalMatrix);\n            }\n        }\n\n        for (const subTree of this.subTrees) {\n            subTree.applyMatrix(matrix, normalMatrix, false);\n        }\n\n        if (firstRun) {\n            this.processTree();\n        }\n    }\n\n    setPolygonIndex(index: number) {\n        if (index === undefined) {\n            return;\n        }\n\n        for(const polygonsArray of this.polygonArrays) {\n            for (const polygon of polygonsArray) {\n                polygon.shared = index;\n            }\n        }\n    }\n\n    // utils from OctreeCSG.extended.js\n    getTriangles(triangles: Triangle[] = []) {\n        for (const polygon of this.getPolygons()) {\n            triangles.push(polygon.triangle)\n        }\n\n        return triangles;\n    }\n\n    getRayTriangles(ray: Ray, triangles: Triangle[] = []) {\n        for (const polygon of this.getRayPolygons(ray)) {\n            triangles.push(polygon.triangle)\n        }\n\n        return triangles;\n    }\n\n    /*\n    Union:\n    1. Delete all polygons in A that are:\n        a. inside and coplanar-back\n        b. inside\n    2. Delete all polygons in B that are:\n        a. inside and coplanar-back\n        b. inside and coplanar-front\n        c. inside\n    */\n    static union(octreeA: OctreeCSG, octreeB: OctreeCSG, buildTargetOctree = true) {\n        if (!octreeA.box) {\n            octreeA.buildTree();\n        }\n\n        if (!octreeB.box) {\n            octreeB.buildTree();\n        }\n\n        const octree = new OctreeCSG();\n        const triangleHasher = new TriangleHasher();\n\n        if ((octreeA.box as Box3).intersectsBox(octreeB.box as Box3)) {\n            octreeA.resetPolygons(false);\n            octreeB.resetPolygons(false);\n\n            octreeA.markIntersectingPolygons(octreeB);\n            octreeB.markIntersectingPolygons(octreeA);\n\n            OctreeCSG.handleIntersectingOctrees(octreeA, octreeB);\n            octreeA.deleteReplacedPolygons();\n            octreeB.deleteReplacedPolygons();\n\n            octreeA.deletePolygonsByStateRules(CSG_Rules.union.a);\n            octreeB.deletePolygonsByStateRules(CSG_Rules.union.b);\n        }\n\n        octreeA.getPolygonCloneCallback(octree.addPolygon.bind(octree), triangleHasher);\n        octreeB.getPolygonCloneCallback(octree.addPolygon.bind(octree), triangleHasher);\n\n        triangleHasher.clear();\n\n        octree.markPolygonsAsOriginal();\n\n        if (buildTargetOctree) {\n            octree.buildTree();\n        }\n\n        return octree;\n    }\n\n    /*\n    Subtract:\n    1. Delete all polygons in A that are:\n        a. inside and coplanar-back\n        b. inside and coplanar-front\n        c. inside\n    2. Delete all polygons in B that are:\n        a. outside and coplanar-back\n        b. outside and coplanar-front\n        c. inside and coplanar-front\n        d. outside\n    */\n    static subtract(octreeA: OctreeCSG, octreeB: OctreeCSG, buildTargetOctree = true) {\n        if (!octreeA.box) {\n            octreeA.buildTree();\n        }\n\n        if (!octreeB.box) {\n            octreeB.buildTree();\n        }\n\n        const octree = new OctreeCSG();\n        const triangleHasher = new TriangleHasher();\n\n        if ((octreeA.box as Box3).intersectsBox(octreeB.box as Box3)) {\n            octreeA.resetPolygons(false);\n            octreeB.resetPolygons(false);\n            octreeA.markIntersectingPolygons(octreeB);\n            octreeB.markIntersectingPolygons(octreeA);\n\n\n            OctreeCSG.handleIntersectingOctrees(octreeA, octreeB);\n            octreeA.deleteReplacedPolygons();\n            octreeB.deleteReplacedPolygons();\n\n            octreeA.deletePolygonsByStateRules(CSG_Rules.subtract.a);\n            octreeB.deletePolygonsByStateRules(CSG_Rules.subtract.b);\n\n\n            octreeB.deletePolygonsByIntersection(false);\n\n            octreeB.invert();\n\n            octreeA.getPolygonCloneCallback(octree.addPolygon.bind(octree), triangleHasher);\n            octreeB.getPolygonCloneCallback(octree.addPolygon.bind(octree), triangleHasher);\n        }\n        else {\n            octreeA.getPolygonCloneCallback(octree.addPolygon.bind(octree), triangleHasher);\n        }\n\n        triangleHasher.clear();\n\n        octree.markPolygonsAsOriginal();\n\n        if (buildTargetOctree) {\n            octree.buildTree();\n        }\n\n        return octree;\n    }\n\n    /*\n    Intersect:\n    1. Delete all polygons in A that are:\n        a. inside and coplanar-back\n        b. outside and coplanar-front\n        c. outside and coplanar-back\n        d. outside\n    2. Delete all polygons in B that are:\n        a. inside and coplanar-front\n        b. inside and coplanar-back\n        c. outside and coplanar-front\n        d. outside and coplanar-back\n        e. outside\n    */\n    static intersect(octreeA: OctreeCSG, octreeB: OctreeCSG, buildTargetOctree = true) {\n        if (!octreeA.box) {\n            octreeA.buildTree();\n        }\n\n        if (!octreeB.box) {\n            octreeB.buildTree();\n        }\n\n        const octree = new OctreeCSG();\n        const triangleHasher = new TriangleHasher();\n\n        if ((octreeA.box as Box3).intersectsBox(octreeB.box as Box3)) {\n            octreeA.resetPolygons(false);\n            octreeB.resetPolygons(false);\n\n            octreeA.markIntersectingPolygons(octreeB);\n            octreeB.markIntersectingPolygons(octreeA);\n\n            OctreeCSG.handleIntersectingOctrees(octreeA, octreeB);\n            octreeA.deleteReplacedPolygons();\n            octreeB.deleteReplacedPolygons();\n\n            octreeA.deletePolygonsByStateRules(CSG_Rules.intersect.a);\n            octreeB.deletePolygonsByStateRules(CSG_Rules.intersect.b);\n\n            octreeA.deletePolygonsByIntersection(false);\n            octreeB.deletePolygonsByIntersection(false);\n\n            octreeA.getPolygonCloneCallback(octree.addPolygon.bind(octree), triangleHasher);\n            octreeB.getPolygonCloneCallback(octree.addPolygon.bind(octree), triangleHasher);\n        }\n\n        triangleHasher.clear();\n\n        octree.markPolygonsAsOriginal();\n\n        if (buildTargetOctree) {\n            octree.buildTree();\n        }\n\n        return octree;\n    }\n\n    static unionArray(objArr: OctreeCSG[], materialIndexMax = Infinity) {\n        return arrayOperation(OctreeCSG.union, objArr, materialIndexMax);\n    }\n\n    static subtractArray(objArr: OctreeCSG[], materialIndexMax = Infinity) {\n        // XXX subtraction is a special case; the leftmost element is subtracted\n        // with everything from the right, which means that:\n        // subtractArray(0 ... N) = subtract(0, union(1 ... N))\n        const objArrCount = objArr.length;\n        if (objArrCount === 0) {\n            throw new Error('Unable to find any result octree');\n        } else if (objArrCount === 1) {\n            return objArr[0];\n        } else if (objArrCount === 2) {\n            return OctreeCSG.subtract(objArr[0], objArr[1]);\n        } else {\n            return OctreeCSG.subtract(objArr[0], OctreeCSG.unionArray(objArr.slice(1), materialIndexMax));\n        }\n    }\n\n    static intersectArray(objArr: OctreeCSG[], materialIndexMax = Infinity) {\n        return arrayOperation(OctreeCSG.intersect, objArr, materialIndexMax);\n    }\n\n    static operation(obj: OctreeCSGObject, buildTargetOctree = true) {\n        let resultOctree: OctreeCSG;\n\n        switch (obj.op) {\n            case 'union':\n            case 'subtract':\n            case 'intersect':\n            {\n                const octreeA = handleObjectForOp(obj.objA, buildTargetOctree);\n                const octreeB = handleObjectForOp(obj.objB, buildTargetOctree);\n\n                switch (obj.op) {\n                    case 'union':\n                        resultOctree = OctreeCSG.union(octreeA, octreeB, buildTargetOctree);\n                        break;\n                    case 'subtract':\n                        resultOctree = OctreeCSG.subtract(octreeA, octreeB, buildTargetOctree);\n                        break;\n                    default:\n                        resultOctree = OctreeCSG.intersect(octreeA, octreeB, buildTargetOctree);\n                }\n\n                disposeOctree(octreeA, octreeB);\n                break;\n            }\n            case 'unionArray':\n            case 'subtractArray':\n            case 'intersectArray':\n            {\n                const octrees = new Array<OctreeCSG>();\n\n                for (const octreeObj of obj.objs) {\n                    octrees.push(handleObjectForOp(octreeObj, buildTargetOctree));\n                }\n\n                // TODO materialIndexMax?\n                switch (obj.op) {\n                    case 'unionArray':\n                        resultOctree = OctreeCSG.unionArray(octrees);\n                        break;\n                    case 'subtractArray':\n                        resultOctree = OctreeCSG.subtractArray(octrees);\n                        break;\n                    default:\n                        resultOctree = OctreeCSG.intersectArray(octrees);\n                }\n\n                disposeOctree(...octrees);\n                break;\n            }\n            default:\n                throw new Error(`Unknown operation: ${(obj as {op: unknown}).op}`);\n        }\n\n        return resultOctree;\n    }\n\n    static async = {\n        batchSize: 100,\n\n        async union(octreeA: OctreeCSG, octreeB: OctreeCSG, buildTargetOctree = true): Promise<OctreeCSG> {\n            return asyncOperation('union', OctreeCSG.union, octreeA, octreeB, buildTargetOctree);\n        },\n\n        subtract(octreeA: OctreeCSG, octreeB: OctreeCSG, buildTargetOctree = true): Promise<OctreeCSG> {\n            return asyncOperation('subtract', OctreeCSG.subtract, octreeA, octreeB, buildTargetOctree);\n        },\n\n        intersect(octreeA: OctreeCSG, octreeB: OctreeCSG, buildTargetOctree = true): Promise<OctreeCSG> {\n            return asyncOperation('intersect', OctreeCSG.intersect, octreeA, octreeB, buildTargetOctree);\n        },\n\n        unionArray(objArr: OctreeCSG[], materialIndexMax = Infinity): Promise<OctreeCSG> {\n            return asyncArrayOperation(OctreeCSG.async.union, OctreeCSG.async.unionArray, objArr, materialIndexMax);\n        },\n\n        async subtractArray(objArr: OctreeCSG[], materialIndexMax = Infinity): Promise<OctreeCSG> {\n            // XXX subtraction is a special case; the leftmost element is\n            // subtracted with everything from the right, which means that:\n            // subtractArray(0 ... N) = subtract(0, union(1 ... N))\n            const objArrCount = objArr.length;\n            if (objArrCount === 0) {\n                throw new Error('Unable to find any result octree');\n            } else if (objArrCount === 1) {\n                return objArr[0];\n            } else if (objArrCount === 2) {\n                return await OctreeCSG.async.subtract(objArr[0], objArr[1]);\n            } else {\n                return await OctreeCSG.async.subtract(objArr[0], await OctreeCSG.async.unionArray(objArr.slice(1), materialIndexMax));\n            }\n        },\n\n        intersectArray(objArr: OctreeCSG[], materialIndexMax = Infinity): Promise<OctreeCSG> {\n            return asyncArrayOperation(OctreeCSG.async.intersect, OctreeCSG.async.intersectArray, objArr, materialIndexMax);\n        },\n\n        operation(obj: OctreeCSGObject, buildTargetOctree = true): Promise<OctreeCSG> {\n            return new Promise((resolve, reject) => {\n                try {\n                    switch (obj.op) {\n                        case 'union':\n                        case 'subtract':\n                        case 'intersect':\n                        {\n                            let octreeA: OctreeCSG, octreeB: OctreeCSG;\n                            const promises = [];\n                            if (obj.objA) {\n                                promises.push(handleObjectForOp_async(obj.objA, buildTargetOctree, 0));\n                            }\n\n                            if (obj.objB) {\n                                promises.push(handleObjectForOp_async(obj.objB, buildTargetOctree, 1));\n                            }\n\n                            Promise.allSettled(promises).then(results => {\n                                for (const result of results) {\n                                    if (result.status === 'fulfilled') {\n                                        const [csg, objIndex] = result.value;\n                                        if (objIndex === 0) {\n                                            octreeA = csg;\n                                        } else if (objIndex === 1) {\n                                            octreeB = csg;\n                                        }\n                                    }\n                                }\n\n                                let resultPromise;\n                                switch (obj.op) {\n                                    case 'union':\n                                        resultPromise = OctreeCSG.async.union(octreeA, octreeB, buildTargetOctree);\n                                        break;\n                                    case 'subtract':\n                                        resultPromise = OctreeCSG.async.subtract(octreeA, octreeB, buildTargetOctree);\n                                        break;\n                                    default:\n                                        resultPromise = OctreeCSG.async.intersect(octreeA, octreeB, buildTargetOctree);\n                                }\n\n                                resultPromise.then(resultOctree => {\n                                    resolve(resultOctree);\n                                    disposeOctree(octreeA, octreeB);\n                                }).catch(e => reject(e));\n                            });\n                            break;\n                        }\n                        case 'unionArray':\n                        case 'subtractArray':\n                        case 'intersectArray':\n                        {\n                            const octrees = new Array<OctreeCSG>();\n\n                            for (const octreeObj of obj.objs) {\n                                octrees.push(handleObjectForOp(octreeObj, buildTargetOctree));\n                            }\n\n                            // TODO materialIndexMax?\n                            let promise;\n                            switch (obj.op) {\n                                case 'unionArray':\n                                    promise = OctreeCSG.async.unionArray(octrees);\n                                    break;\n                                case 'subtractArray':\n                                    promise = OctreeCSG.async.subtractArray(octrees);\n                                    break;\n                                default:\n                                    promise = OctreeCSG.async.intersectArray(octrees);\n                            }\n\n                            disposeOctree(...octrees);\n\n                            promise.then(resultOctree => resolve(resultOctree));\n                            break;\n                        }\n                        default:\n                            throw new Error(`Unknown operation: ${(obj as {op: unknown}).op}`);\n                    }\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        }\n    }\n\n    protected static handleIntersectingOctrees(octreeA: OctreeCSG, octreeB: OctreeCSG, bothOctrees = true, octreeA_buffer?: Float32Array, octreeB_buffer?: Float32Array) {\n        if (OctreeCSG.useWindingNumber) {\n            if (bothOctrees && !octreeA_buffer) {\n                octreeA_buffer = prepareTriangleBuffer(octreeA.getPolygons());\n            }\n\n            if (!octreeB_buffer) {\n                octreeB_buffer = prepareTriangleBuffer(octreeB.getPolygons());\n            }\n        }\n\n        octreeA.handleIntersectingPolygons(octreeB, octreeB_buffer);\n\n        if (bothOctrees) {\n            octreeB.handleIntersectingPolygons(octreeA, octreeA_buffer);\n        }\n\n        if (octreeA_buffer !== undefined) {\n            octreeA_buffer = undefined;\n            octreeB_buffer = undefined;\n        }\n    }\n}\n\nfunction raycastIntersectAscSort(a: RayIntersect, b: RayIntersect) {\n    return a.distance - b.distance;\n}\n\nfunction handleObjectForOp(obj: OctreeCSG | OctreeCSGObject, buildTargetOctree: boolean) {\n    if (obj instanceof OctreeCSG) {\n        return obj;\n    } else if (obj.op) {\n        return OctreeCSG.operation(obj, buildTargetOctree);\n    } else {\n        throw new Error('Invalid OctreeCSG operation object');\n    }\n}\n\nfunction handleObjectForOp_async(obj: OctreeCSG | OctreeCSGObject, buildTargetOctree: boolean, objIndex: number): Promise<[csg: OctreeCSG, objIndex: number]> {\n    return new Promise((resolve, reject) => {\n        try {\n            if (obj instanceof OctreeCSG) {\n                resolve([obj, objIndex]);\n            } else if (obj.op) {\n                OctreeCSG.async.operation(obj, buildTargetOctree).then(returnObj => {\n                    resolve([returnObj, objIndex]);\n                });\n            } else {\n                throw new Error('Invalid OctreeCSG operation object');\n            }\n        }\n        catch (e) {\n            reject(e);\n        }\n    });\n}\n\nfunction disposeOctree(...octrees: OctreeCSG[]) {\n    if (OctreeCSG.disposeOctree) {\n        for (const octree of octrees) {\n            octree.delete();\n        }\n    }\n}\n\nfunction handlePolygonArrayIntersections(targetPolygon: Polygon, outputPolygons: Polygon[], polygons: Polygon[]) {\n    for (const polygon of polygons) {\n        if (polygon.originalValid && polygon.valid && polygon.intersects && checkTrianglesIntersection(targetPolygon.triangle, polygon.triangle)) {\n            outputPolygons.push(polygon);\n        }\n    }\n}\n\nfunction arrayOperation(callback: (octreeA: OctreeCSG, octreeB: OctreeCSG, buildTargetOctree?: boolean) => OctreeCSG, objArr: OctreeCSG[], materialIndexMax: number) {\n    let octreesArray = new Array<OctreeCSG>();\n    const objArrLen = objArr.length;\n\n    for (let i = 0; i < objArrLen; i++) {\n        const tempOctree = objArr[i];\n        tempOctree.setPolygonIndex(i > materialIndexMax ? materialIndexMax : i);\n        octreesArray.push(tempOctree);\n    }\n\n    // XXX minimise the octree bounding box after each operation by applying an\n    // operation to pairs of octrees instead of applying it to the same octree\n    // over and over again (which results in a single octree with a giant\n    // bounding box), and trying to keep the same order. this works best when\n    // each octree in the array is ordered by their position\n    while (octreesArray.length > 1) {\n        const octreeCount = octreesArray.length;\n        const nextOctreeArray = new Array<OctreeCSG>();\n\n        // process pairs\n        let i = 0;\n        for (; i + 1 < octreeCount; i += 2) {\n            const octreeA = octreesArray[i];\n            const octreeB = octreesArray[i + 1];\n            const resultOctree = callback(octreeA, octreeB);\n            disposeOctree(octreeA, octreeB);\n            nextOctreeArray.push(resultOctree);\n        }\n\n        // add leftover octrees\n        if (i < octreeCount) {\n            nextOctreeArray.push(octreesArray[i]);\n        }\n\n        // next iteration array\n        octreesArray = nextOctreeArray;\n    }\n\n    if (octreesArray.length === 0) {\n        throw new Error('Unable to find any result octree');\n    }\n\n    return octreesArray[0];\n}\n\nasync function asyncOperation(op: 'union' | 'subtract' | 'intersect', syncCallback: (octreeA: OctreeCSG, octreeB: OctreeCSG, buildTargetOctree?: boolean) => OctreeCSG, octreeA: OctreeCSG, octreeB: OctreeCSG, buildTargetOctree = true): Promise<OctreeCSG> {\n    // try using async job dispatcher\n    if (globalThis.globalOctreeCSGJobDispatcher) {\n        try {\n            return await globalThis.globalOctreeCSGJobDispatcher.dispatch({\n                op,\n                objA: octreeA,\n                objB: octreeB,\n            })\n        } catch(error) {\n            let rethrow = true;\n            if (error instanceof JobError && error.failReason === JobFailReason.WorkerCreationFailure) {\n                console.warn('Queued job failed due to worker creation failure. Retrying synchronously');\n                rethrow = false;\n            }\n\n            if (rethrow) {\n                throw error;\n            }\n        }\n    }\n\n    // fall back to synchronous implementation\n    const result = syncCallback(octreeA, octreeB, buildTargetOctree);\n    disposeOctree(octreeA, octreeB);\n    return result;\n}\n\nfunction asyncArrayOperation(singleCallback: (octreeA: OctreeCSG, octreeB: OctreeCSG, buildTargetOctree?: boolean) => Promise<OctreeCSG>, arrayCallback: (objArr: OctreeCSG[], materialIndexMax?: number) => Promise<OctreeCSG>, objArr: OctreeCSG[], materialIndexMax: number): Promise<OctreeCSG> {\n    return new Promise((resolve, reject) => {\n        try {\n            const usingBatches = OctreeCSG.async.batchSize > 4 && OctreeCSG.async.batchSize < objArr.length;\n            let mainOctree: OctreeCSG;\n            let mainOctreeUsed = false;\n            const promises = [];\n\n            if (usingBatches) {\n                const batches = [];\n                let currentIndex = 0;\n\n                while (currentIndex < objArr.length) {\n                    batches.push(objArr.slice(currentIndex, currentIndex + OctreeCSG.async.batchSize));\n                    currentIndex += OctreeCSG.async.batchSize;\n                }\n\n                let batch;\n                while ((batch = batches.shift())) { // XXX assignment is on purpose\n                    promises.push(arrayCallback(batch, 0));\n                }\n\n                mainOctreeUsed = true;\n                objArr.length = 0;\n            } else {\n                const octreesArray: OctreeCSG[] = [];\n                const objArrLen = objArr.length;\n                for (let i = 0; i < objArrLen; i++) {\n                    const tempOctree = objArr[i];\n\n                    if (materialIndexMax > -1) {\n                        tempOctree.setPolygonIndex(i > materialIndexMax ? materialIndexMax : i);\n                    }\n\n                    octreesArray.push(tempOctree);\n                }\n\n                mainOctree = octreesArray.shift() as OctreeCSG;\n\n                let leftOverOctree;\n                const octreesArrayLen = octreesArray.length;\n                for (let i = 0; i < octreesArrayLen; i += 2) {\n                    if (i + 1 >= octreesArrayLen) {\n                        leftOverOctree = octreesArray[i];\n                        break;\n                    }\n\n                    promises.push(singleCallback(octreesArray[i], octreesArray[i + 1]));\n                }\n\n                if (leftOverOctree) {\n                    promises.push(singleCallback(mainOctree, leftOverOctree));\n                    mainOctreeUsed = true;\n                }\n            }\n\n            Promise.allSettled(promises).then(results => {\n                const octrees = new Array<OctreeCSG>();\n\n                for (const result of results) {\n                    if (result.status === 'fulfilled') {\n                        octrees.push(result.value);\n                    }\n                }\n\n                if (!mainOctreeUsed) {\n                    octrees.unshift(mainOctree);\n                }\n\n                if (octrees.length <= 0) {\n                    reject('Unable to find any result octree');\n                } else if (octrees.length === 1) {\n                    resolve(octrees[0]);\n                } else if (octrees.length > 3) {\n                    arrayCallback(octrees, usingBatches ? 0 : -1).then(result => {\n                        resolve(result);\n                    }).catch(e => reject(e));\n                } else {\n                    singleCallback(octrees[0], octrees[1]).then(result => {\n                        if (octrees.length === 3) {\n                            singleCallback(result, octrees[2]).then(innerResult => {\n                                resolve(innerResult);\n                            }).catch(e => reject(e));\n                        } else {\n                            resolve(result);\n                        }\n                    }).catch(e => reject(e));\n                }\n            });\n        } catch (e) {\n            reject(e);\n        }\n    });\n}", "import { vec3 } from 'gl-matrix';\n\nexport default class Vertex {\n    constructor(public pos: vec3, public normal: vec3) {}\n\n    clone() {\n        return new Vertex(vec3.clone(this.pos), vec3.clone(this.normal));\n    }\n\n    // Invert all orientation-specific data (e.g. vertex normal). Called when the\n    // orientation of a polygon is flipped.\n    flip() {\n        vec3.negate(this.normal, this.normal);\n    }\n\n    delete() {\n        (this.pos as unknown) = undefined;\n        (this.normal as unknown) = undefined;\n    }\n\n    // Create a new vertex between this vertex and `other` by linearly\n    // interpolating all properties using a parameter of `t`. Subclasses should\n    // override this to interpolate additional properties.\n    interpolate(other: Vertex, t: number) {\n        return new Vertex(\n            vec3.lerp(vec3.create(), this.pos, other.pos, t),\n            vec3.lerp(vec3.create(), this.normal, other.normal, t)\n        );\n    }\n}", "import OctreeCSG from '../base/OctreeCSG';\nimport { Polygon } from '../math/Polygon';\nimport Vertex from '../math/Vertex';\n\nexport default function decodeOctree(vertexBuffer: Float32Array, normalBuffer: Float32Array): OctreeCSG {\n    // sanitise buffer lengths\n    const bufferLen = vertexBuffer.length;\n    if (bufferLen % 9 !== 0) {\n        throw new Error('Vertex buffer length is not a multiple of 9');\n    }\n\n    if (normalBuffer.length % 9 !== 0) {\n        throw new Error('Normal buffer length is not a multiple of 9');\n    }\n\n    // decode octree\n    const octree = new OctreeCSG();\n\n    for (let i = 0; i < bufferLen;) {\n        const a = new Vertex(vertexBuffer.slice(i, i + 3), normalBuffer.slice(i, i + 3));\n        i += 3;\n        const b = new Vertex(vertexBuffer.slice(i, i + 3), normalBuffer.slice(i, i + 3));\n        i += 3;\n        const c = new Vertex(vertexBuffer.slice(i, i + 3), normalBuffer.slice(i, i + 3));\n        i += 3;\n\n        const newPolygon = new Polygon([a, b, c]);\n        newPolygon.originalValid = true;\n        octree.addPolygon(newPolygon);\n    }\n\n    return octree;\n}", "import encodeOctree from './encode-octree';\nimport decodeOctree from './decode-octree';\nimport OctreeCSG from '../base/OctreeCSG';\nimport { JobError } from './JobError';\n\nimport type { EncodedOctreeCSGObject, EncodedOctreeCSGObjectArgument } from './EncodedOctreeCSGObject';\nimport type { OctreeCSGObject } from '../base/OctreeCSGObject';\nimport type WorkerRequest from './WorkerRequest';\n\nfunction encodeOctreeCSGObject(obj: OctreeCSGObject, transferables: Array<ArrayBuffer>): EncodedOctreeCSGObject {\n    switch (obj.op) {\n        case 'union':\n        case 'subtract':\n        case 'intersect':\n        {\n            return <EncodedOctreeCSGObject>{\n                op: obj.op,\n                objA: encodeOctreeCSGObjectOrCSG(obj.objA, transferables),\n                objB: encodeOctreeCSGObjectOrCSG(obj.objB, transferables),\n            }\n        }\n        case 'unionArray':\n        case 'subtractArray':\n        case 'intersectArray':\n        {\n            const encodedObjs = new Array<EncodedOctreeCSGObjectArgument>();\n\n            for (const octreeObj of obj.objs) {\n                encodedObjs.push(encodeOctreeCSGObjectOrCSG(octreeObj, transferables));\n            }\n\n            return <EncodedOctreeCSGObject>{\n                op: obj.op,\n                objs: encodedObjs,\n            }\n        }\n        default:\n            throw new Error(`Unknown operation: ${(obj as {op: unknown}).op}`);\n    }\n}\n\nfunction encodeOctreeCSGObjectOrCSG(obj: OctreeCSGObject | OctreeCSG, transferables: Array<ArrayBuffer>): EncodedOctreeCSGObjectArgument {\n    if (obj instanceof OctreeCSG) {\n        return encodeOctree(obj, transferables);\n    } else {\n        return encodeOctreeCSGObject(obj, transferables);\n    }\n}\n\nexport default class Job {\n    private operation: EncodedOctreeCSGObject | null;\n    private transferables: Array<ArrayBuffer> | null;\n    workerIndex: number | null = null;\n\n    constructor(operation: OctreeCSGObject, private resolveCallback: (octree: OctreeCSG) => void, private rejectCallback: (error: JobError) => void) {\n        // encode operation\n        this.transferables = [];\n        this.operation = encodeOctreeCSGObject(operation, this.transferables);\n    }\n\n    getMessage(workerIndex: number, jobIndex: number): [message: WorkerRequest, transferables: Array<ArrayBuffer>] {\n        if (!(this.operation && this.transferables)) {\n            throw new Error('Message already created');\n        }\n\n        const operation = this.operation;\n        const transferables = this.transferables;\n\n        this.operation = null;\n        this.transferables = null;\n        this.workerIndex = workerIndex;\n\n        const data: [message: WorkerRequest, transferables: Array<ArrayBuffer>] = [\n            <WorkerRequest>{\n                type: 'operation',\n                jobIndex,\n                operation,\n            },\n            transferables,\n        ];\n\n        return data;\n    }\n\n    resolve(vertexBuffer: Float32Array, normalBuffer: Float32Array) {\n        try {\n            this.resolveCallback(decodeOctree(vertexBuffer, normalBuffer));\n        } catch(e) {\n            this.rejectCallback(JobError.DecodeFailure(e));\n        }\n    }\n\n    reject(error: JobError) {\n        this.rejectCallback(error);\n    }\n}\n", "import { JobError } from './JobError';\nimport Job from './Job';\n\nimport type { OctreeCSGObject } from '../base/OctreeCSGObject';\nimport type OctreeCSG from '../base/OctreeCSG';\nimport type JobResult from './JobResult';\n\ndeclare global {\n    // eslint-disable-next-line no-var\n    var globalOctreeCSGJobDispatcher: OctreeCSGJobDispatcher | null | undefined;\n}\n\nconst JOB_REG_MSG = 'OctreeCSG job dispatcher worker creation';\nconst WARN_START = `Skipped ${JOB_REG_MSG}; `;\n\nexport default class OctreeCSGJobDispatcher {\n    private workers: Array<Worker> | null = null;\n    private nextJobIndex = 0;\n    private waitingJobs = new Map<number, Job>();\n    private jobCounts = new Array<number>();\n\n    private initWorker(workers: Array<Worker>, workerPath: string, timeoutMS: number) {\n        return new Promise((resolve: (value: undefined) => void, reject: (reason: Error) => void) => {\n            const timeout = setTimeout(() => {\n                worker.terminate();\n                reject(new Error('Timed out'));\n            }, timeoutMS);\n\n            const worker = new Worker(workerPath, { type: 'classic' });\n            worker.onmessage = (message: MessageEvent<string>) => {\n                clearTimeout(timeout);\n\n                if (message.data === 'initialized') {\n                    const workerIndex = workers.length;\n                    workers.push(worker);\n\n                    worker.onmessage = this.makeMessageHandler(workerIndex);\n                    resolve(undefined); // XXX undefined so typescript shuts up\n                } else {\n                    worker.terminate();\n                    reject(new Error('Unexpected initialization message'));\n                }\n            }\n        });\n    }\n\n    private init(workerPath: string, workerCount: number, timeoutMS: number) {\n        return new Promise((resolve: (value: undefined) => void, reject: (reason: Error) => void) => {\n            const workers = new Array<Worker>();\n            let workersDone = 0;\n\n            for (let i = 0; i < workerCount; i++) {\n                this.initWorker(workers, workerPath, timeoutMS).catch((reason: Error) => {\n                    console.error('Failed to create OctreeCSG worker:', reason.message);\n                }).finally(() => {\n                    if (++workersDone === workerCount) {\n                        const actualWorkerCount = workers.length;\n\n                        if (actualWorkerCount === 0) {\n                            reject(new Error('All OctreeCSG workers failed to be created'));\n                            return;\n                        } else if (actualWorkerCount !== workerCount) {\n                            console.warn(`Some OctreeCSG workers failed to be created. Created ${actualWorkerCount} workers instead of ${workerCount}`);\n                        } else {\n                            console.info(`Created ${actualWorkerCount} OctreeCSG workers`);\n                        }\n\n                        this.workers = workers;\n                        resolve(undefined); // XXX undefined so typescript shuts up\n                    }\n                });\n            }\n        });\n    }\n\n    private makeMessageHandler(workerIndex: number) {\n        // XXX this aliasing is OK here because this changes in the callback\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const dispatcher = this;\n\n        return function(this: Worker, event: MessageEvent<JobResult>) {\n            dispatcher.handleMessage(workerIndex, event);\n        }\n    }\n\n    private handleMessage(workerIndex: number, event: MessageEvent<JobResult>) {\n        // remove job from worker job count\n        this.jobCounts[workerIndex]--;\n\n        // delete from waiting jobs\n        const jobIndex = event.data.jobIndex;\n        const job = this.waitingJobs.get(jobIndex) as Job;\n        this.waitingJobs.delete(jobIndex);\n\n        // finalize promise\n        if (event.data.success) {\n            job.resolve(event.data.vertices, event.data.normals);\n        } else {\n            job.reject(JobError.OperationFailure(event.data.error));\n        }\n    }\n\n    private doDispatch(jobIndex: number, job: Job) {\n        // get worker with least workers (prefer workers with lower indices)\n        let minWorkerIndex = 0;\n        let minJobCount = this.jobCounts[0];\n\n        const workerCount = this.jobCounts.length;\n        for (let workerIndex = 1; workerIndex < workerCount; workerIndex++) {\n            const jobCount = this.jobCounts[workerIndex];\n            if (jobCount < minJobCount) {\n                minWorkerIndex = workerIndex;\n                minJobCount = jobCount;\n            }\n        }\n\n        // dispatch to chosen worker\n        const worker = (this.workers as Array<Worker>)[minWorkerIndex];\n        worker.postMessage(...job.getMessage(minWorkerIndex, jobIndex));\n    }\n\n    dispatch(operation: OctreeCSGObject) {\n        return new Promise((resolve: (octree: OctreeCSG) => void, reject: (error: JobError) => void) => {\n            // create job\n            const job = new Job(operation, resolve, reject)\n            const jobIndex = this.nextJobIndex++;\n            this.waitingJobs.set(jobIndex, job);\n\n            // dispatch to worker if workers are registered\n            if (this.workers) {\n                this.doDispatch(jobIndex, job);\n            }\n        })\n    }\n\n    static async create(workerPath: string, workerCount: number, timeoutMS: number) {\n        if (globalThis.globalOctreeCSGJobDispatcher) {\n            console.warn(`${WARN_START}already created`);\n            return;\n        } else if (globalThis.globalOctreeCSGJobDispatcher === null) {\n            console.warn(`${WARN_START}previous creation failed`);\n            return;\n        }\n\n        let jobDispatcher;\n\n        if (globalThis.Worker) {\n            try {\n                jobDispatcher = new OctreeCSGJobDispatcher();\n                globalThis.globalOctreeCSGJobDispatcher = jobDispatcher;\n                await jobDispatcher.init(workerPath, workerCount, timeoutMS);\n            } catch(e) {\n                console.error(`${JOB_REG_MSG} failed:`, e);\n\n                // reject all jobs with a special reason so that they can recover\n                globalThis.globalOctreeCSGJobDispatcher = null;\n\n                if (jobDispatcher) {\n                    for (const job of jobDispatcher.waitingJobs.values()) {\n                        job.reject(JobError.WorkerCreationFailure(e));\n                    }\n\n                    jobDispatcher.waitingJobs.clear();\n                }\n\n                throw e;\n            }\n\n            for (const [jobIndex, job] of jobDispatcher.waitingJobs) {\n                jobDispatcher.doDispatch(jobIndex, job);\n            }\n        } else {\n            console.warn(`${WARN_START}Worker API not supported`);\n            return;\n        }\n    }\n}", "import { vec3 } from 'gl-matrix';\n\nimport Box3 from '../math/Box3';\nimport Vertex from '../math/Vertex';\nimport { CSGPrimitive } from './CSGPrimitive';\n\nimport type { CSGPrimitiveOptions } from './CSGPrimitive';\n\nfunction addSquare(vertices: Array<Vertex>, index: number, a: vec3, b: vec3, c: vec3, d: vec3, normal: vec3): number {\n    // first triangle\n    vertices[index++] = new Vertex(vec3.clone(a), vec3.clone(normal));\n    vertices[index++] = new Vertex(b, vec3.clone(normal));\n    vertices[index++] = new Vertex(vec3.clone(c), vec3.clone(normal));\n    // second triangle\n    vertices[index++] = new Vertex(c, vec3.clone(normal));\n    vertices[index++] = new Vertex(d, vec3.clone(normal));\n    vertices[index++] = new Vertex(a, normal);\n\n    return index;\n}\n\nexport class Cuboid extends CSGPrimitive {\n    constructor(xLength: number, yLength: number, zLength: number, options?: CSGPrimitiveOptions) {\n        // make bounding box\n        xLength *= 0.5;\n        yLength *= 0.5;\n        zLength *= 0.5;\n\n        const max = vec3.fromValues(xLength, yLength, zLength);\n        const min = vec3.negate(vec3.create(), max);\n\n        // add cuboid triangles\n        const luf = vec3.fromValues(-xLength,  yLength,  zLength);\n        const ruf = vec3.fromValues( xLength,  yLength,  zLength);\n        const lub = vec3.fromValues(-xLength,  yLength, -zLength);\n        const rub = vec3.fromValues( xLength,  yLength, -zLength);\n        const ldf = vec3.fromValues(-xLength, -yLength,  zLength);\n        const rdf = vec3.fromValues( xLength, -yLength,  zLength);\n        const ldb = vec3.fromValues(-xLength, -yLength, -zLength);\n        const rdb = vec3.fromValues( xLength, -yLength, -zLength);\n\n        const vertices = new Array(36);\n        let index = addSquare(vertices, 0, luf, ruf, rub, lub, vec3.fromValues( 0,  1,  0));\n        index = addSquare(vertices, index, ldb, rdb, rdf, ldf, vec3.fromValues( 0, -1,  0));\n        index = addSquare(vertices, index, rub, ruf, rdf, rdb, vec3.fromValues( 1,  0,  0));\n        index = addSquare(vertices, index, ldb, ldf, luf, lub, vec3.fromValues(-1,  0,  0));\n        index = addSquare(vertices, index, rdf, ruf, luf, ldf, vec3.fromValues( 0,  0,  1));\n                addSquare(vertices, index, ldb, lub, rub, rdb, vec3.fromValues( 0,  0, -1));\n\n        super(new Box3(min, max), vertices, options);\n    }\n}", "import { mat4, quat, vec3 } from 'gl-matrix';\nimport OctreeCSG from '../base/OctreeCSG';\nimport { Polygon } from '../math/Polygon';\n\nimport type { mat3 } from 'gl-matrix';\n\nimport type Vertex from '../math/Vertex';\nimport type Box3 from '../math/Box3';\n\nexport type CSGPrimitiveOptions = {\n    matrix: mat4,\n    normalMatrix?: mat3,\n} | {\n    rotation?: quat,\n    translation?: vec3,\n    scale?: vec3,\n};\n\nexport class CSGPrimitive extends OctreeCSG {\n    constructor(box: Box3, triangleVertices: Array<Vertex>, options?: CSGPrimitiveOptions) {\n        const vertexCount = triangleVertices.length;\n        if (vertexCount % 3 !== 0) {\n            throw new Error('Input triangle vertices array has a non-multiple-of-three length');\n        }\n\n        super(box);\n\n        // turn vertex array to triangle array\n        for (let i = 0; i < vertexCount; i += 3) {\n            const polygon = new Polygon(triangleVertices.slice(i, i + 3));\n            polygon.originalValid = true;\n            this.polygons.push(polygon);\n        }\n\n        // transform if necessary\n        if (!options) {\n            return;\n        }\n\n        if ('matrix' in options) {\n            const matrix = options.matrix;\n            this.applyMatrix(matrix, options.normalMatrix);\n        } else if (options.rotation || options.translation || options.scale) {\n            // make transformation matrix\n            const matrix = mat4.create();\n\n            if (options.rotation && options.translation) {\n                if (options.scale) {\n                    // RTS\n                    mat4.fromRotationTranslationScale(matrix, options.rotation, options.translation, options.scale);\n                } else {\n                    // RT\n                    mat4.fromRotationTranslation(matrix, options.rotation, options.translation);\n                }\n            } else if (options.translation) {\n                if (options.scale) {\n                    // TS\n                    mat4.identity(matrix);\n                    mat4.translate(matrix, matrix, options.translation);\n                    mat4.scale(matrix, matrix, options.scale);\n                } else {\n                    // T\n                    mat4.fromTranslation(matrix, options.translation);\n                }\n            } else if (options.rotation) {\n                if (options.scale) {\n                    // RS\n                    mat4.identity(matrix);\n                    const tmpMat = mat4.create();\n                    mat4.fromQuat(tmpMat, options.rotation);\n                    mat4.multiply(matrix, matrix, tmpMat);\n                    mat4.scale(matrix, matrix, options.scale);\n                } else {\n                    // R\n                    mat4.fromQuat(matrix, options.rotation);\n                }\n            } else {\n                // S\n                // XXX for some reason typescript doesn't detect scale as being\n                // a vec3 here but can be safely ignored\n                mat4.fromScaling(matrix, options.scale as vec3);\n            }\n\n            this.applyMatrix(matrix);\n        }\n    }\n}", "import { Cuboid } from './Cuboid';\n\nimport type { CSGPrimitiveOptions } from './CSGPrimitive';\n\nexport class Cube extends Cuboid {\n    constructor(length = 1, options?: CSGPrimitiveOptions) {\n        super(length, length, length, options);\n    }\n}", "import { vec3 } from 'gl-matrix';\n\nimport Box3 from '../math/Box3';\nimport Vertex from '../math/Vertex';\nimport { CSGPrimitive } from './CSGPrimitive';\n\nimport type { CSGPrimitiveOptions } from './CSGPrimitive';\n\nexport type SphereCSGPrimitiveOptions = CSGPrimitiveOptions & {\n    subDivisions?: number,\n};\n\nexport type SpherifyPointFunction = (ip: number, jp: number, radius: number, origin: vec3, right: vec3, up: vec3) => [pos: vec3, normal: vec3];\n\nfunction spherifyFace(spherifyPoint: SpherifyPointFunction, index: number, subDivs: number, radius: number, vertices: Array<Vertex>, origin: vec3, right: vec3, up: vec3): number {\n    // XXX this can be optimised by re-using the previous sub-division's vertex\n    // per axis\n    for (let i = 0; i < subDivs; i++) {\n        const ip = i / subDivs;\n        const inp = (i + 1) / subDivs;\n\n        for (let j = 0; j < subDivs; j++) {\n            const jp = j / subDivs;\n            const jnp = (j + 1) / subDivs;\n\n            const [a, aNorm] = spherifyPoint(ip, jp, radius, origin, right, up);\n            const [b, bNorm] = spherifyPoint(inp, jp, radius, origin, right, up);\n            const [c, cNorm] = spherifyPoint(inp, jnp, radius, origin, right, up);\n            const [d, dNorm] = spherifyPoint(ip, jnp, radius, origin, right, up);\n\n            vertices[index++] = new Vertex(vec3.clone(a), vec3.clone(aNorm));\n            vertices[index++] = new Vertex(b, bNorm);\n            vertices[index++] = new Vertex(vec3.clone(c), vec3.clone(cNorm));\n            vertices[index++] = new Vertex(c, cNorm);\n            vertices[index++] = new Vertex(d, dNorm);\n            vertices[index++] = new Vertex(a, aNorm);\n        }\n    }\n\n    return index;\n}\n\nexport class CubeSphere extends CSGPrimitive {\n    constructor(spherifyPoint: SpherifyPointFunction, diameter = 1, options?: SphereCSGPrimitiveOptions) {\n        // spherify a cube\n        const subDivs = options?.subDivisions ?? 4;\n        const vertexCount = 36 * subDivs * subDivs;\n        const vertices = new Array<Vertex>(vertexCount);\n        const radius = diameter / 2;\n\n        // right\n        let index = spherifyFace(spherifyPoint, 0, subDivs, radius, vertices, [1, -1, 1], [0, 0, -2], [0, 2, 0]);\n        // left\n        index = spherifyFace(spherifyPoint, index, subDivs, radius, vertices, [-1, -1, -1], [0, 0, 2], [0, 2, 0]);\n        // up\n        index = spherifyFace(spherifyPoint, index, subDivs, radius, vertices, [-1, 1, 1], [2, 0, 0], [0, 0, -2]);\n        // down\n        index = spherifyFace(spherifyPoint, index, subDivs, radius, vertices, [1, -1, 1], [-2, 0, 0], [0, 0, -2]);\n        // front\n        index = spherifyFace(spherifyPoint, index, subDivs, radius, vertices, [-1, -1, 1], [2, 0, 0], [0, 2, 0]);\n        // back\n        spherifyFace(spherifyPoint, index, subDivs, radius, vertices, [1, -1, -1], [-2, 0, 0], [0, 2, 0]);\n\n        // make bounding box\n        const max = vec3.fromValues(radius, radius, radius);\n        const min = vec3.negate(vec3.create(), max);\n\n        super(new Box3(min, max), vertices, options);\n    }\n}", "import { vec3 } from 'gl-matrix';\n\nimport { THIRD } from '../math/const-numbers';\nimport { tv0, tv1 } from '../math/temp';\nimport { CubeSphere } from './CubeSphere';\n\nimport type { SphereCSGPrimitiveOptions } from './CubeSphere';\n\nfunction spherifyPoint(ip: number, jp: number, radius: number, origin: vec3, right: vec3, up: vec3): [pos: vec3, normal: vec3] {\n    // algorithm adapted from:\n    // http://mathproofs.blogspot.com/2005/07/mapping-cube-to-sphere.html\n    vec3.copy(tv0, origin);\n    vec3.scaleAndAdd(tv0, tv0, right, ip);\n    vec3.scaleAndAdd(tv0, tv0, up, jp);\n    vec3.multiply(tv1, tv0, tv0);\n\n    const normal = vec3.fromValues(\n        tv0[0] * Math.sqrt(1 - 0.5 * (tv1[1] + tv1[2]) + tv1[1] * tv1[2] * THIRD),\n        tv0[1] * Math.sqrt(1 - 0.5 * (tv1[2] + tv1[0]) + tv1[2] * tv1[0] * THIRD),\n        tv0[2] * Math.sqrt(1 - 0.5 * (tv1[0] + tv1[1]) + tv1[0] * tv1[1] * THIRD),\n    );\n    const pos = vec3.scale(vec3.create(), normal, radius);\n\n    return [pos, normal];\n}\n\nexport class Sphere extends CubeSphere {\n    constructor(diameter = 1, options?: SphereCSGPrimitiveOptions) {\n        super(spherifyPoint, diameter, options);\n    }\n}", "import { vec3 } from 'gl-matrix';\n\nimport { tv0 } from '../math/temp';\nimport { CubeSphere } from './CubeSphere';\n\nimport type { SphereCSGPrimitiveOptions } from './CubeSphere';\n\nfunction spherifyPoint(ip: number, jp: number, radius: number, origin: vec3, right: vec3, up: vec3): [pos: vec3, normal: vec3] {\n    vec3.copy(tv0, origin);\n    vec3.scaleAndAdd(tv0, tv0, right, ip);\n    vec3.scaleAndAdd(tv0, tv0, up, jp);\n    const normal = vec3.normalize(tv0, tv0);\n    const pos = vec3.scale(vec3.create(), normal, radius);\n\n    return [pos, normal];\n}\n\nexport class UVSphere extends CubeSphere {\n    constructor(diameter = 1, options?: SphereCSGPrimitiveOptions) {\n        super(spherifyPoint, diameter, options);\n    }\n}", "import { vec3 } from 'gl-matrix';\n\nimport Box3 from '../math/Box3';\nimport Vertex from '../math/Vertex';\nimport { CSGPrimitive } from './CSGPrimitive';\nimport { makeCircularBase, precalcCircularBase } from './make-circular-base';\n\nimport type CircularBaseCSGPrimitiveOptions from './CircularBaseCSGPrimitiveOptions';\n\nexport class Cylinder extends CSGPrimitive {\n    constructor(diameter = 1, length = 1, options?: CircularBaseCSGPrimitiveOptions) {\n        // pre-calculations\n        const subDivs = options?.subDivisions ?? 12;\n        const vertexCount = (subDivs - 2) * 6 + subDivs * 6;\n        const vertices = new Array<Vertex>(vertexCount);\n        const radius = diameter / 2;\n        const halfLength = length / 2;\n        const xzn = precalcCircularBase(subDivs, radius, true);\n\n        // make bases\n        let index = makeCircularBase(vertices, xzn, halfLength, vec3.fromValues(0, 1, 0), 0, false);\n        index = makeCircularBase(vertices, xzn, -halfLength, vec3.fromValues(0, -1, 0), index, true);\n\n        // make sides\n        for (let i = 0; i < subDivs; i++) {\n            const [x1, z1, normal1] = xzn[i];\n            const [x2, z2, normal2] = xzn[(i + 1) % subDivs];\n\n            vertices[index++] = new Vertex(vec3.fromValues(x2, halfLength, z2), vec3.clone(normal2));\n            vertices[index++] = new Vertex(vec3.fromValues(x1, halfLength, z1), vec3.clone(normal1));\n            vertices[index++] = new Vertex(vec3.fromValues(x1, -halfLength, z1), vec3.clone(normal1));\n\n            vertices[index++] = new Vertex(vec3.fromValues(x1, -halfLength, z1), vec3.clone(normal1));\n            vertices[index++] = new Vertex(vec3.fromValues(x2, -halfLength, z2), vec3.clone(normal2));\n            vertices[index++] = new Vertex(vec3.fromValues(x2, halfLength, z2), vec3.clone(normal2));\n        }\n\n        // make bounding box\n        const max = vec3.fromValues(radius, halfLength, radius);\n        const min = vec3.negate(vec3.create(), max);\n\n        super(new Box3(min, max), vertices, options);\n    }\n}", "import { vec3 } from 'gl-matrix';\n\nimport Vertex from '../math/Vertex';\nimport triangulateConvexPolygon from '../helpers/triangulate-convex-polygon';\nimport { TAU } from '../math/const-numbers';\n\nexport type CircularPrecalcArr = Array<[x: number, z: number, normal?: vec3]>;\nexport type CircularPrecalcArrNoNormal = Array<[x: number, z: number]>;\nexport type CircularPrecalcArrNormal = Array<[x: number, z: number, normal: vec3]>;\n\nexport function makeCircularBase(vertices: Array<Vertex>, xzn: CircularPrecalcArr, y: number, normal: vec3, index: number, flip: boolean): number {\n    // make polyline\n    const segments = xzn.length;\n    const polyline = new Array(segments);\n\n    for (let i = 0; i < segments; i++) {\n        polyline[i] = new Vertex(vec3.fromValues(xzn[i][0], y, xzn[i][1]), vec3.clone(normal));\n    }\n\n    // triangulate\n    return triangulateConvexPolygon(polyline, flip, vertices, index)[1];\n}\n\nexport function precalcCircularBase(subDivs: number, radius: number, generateNormals: false): CircularPrecalcArrNoNormal;\nexport function precalcCircularBase(subDivs: number, radius: number, generateNormals: true): CircularPrecalcArrNormal;\nexport function precalcCircularBase(subDivs: number, radius: number, generateNormals: boolean): CircularPrecalcArr;\nexport function precalcCircularBase(subDivs: number, radius: number, generateNormals: boolean): CircularPrecalcArr {\n    const xzn: CircularPrecalcArr = new Array(subDivs);\n\n    for (let i = 0; i < subDivs; i++) {\n        const angle = TAU * (subDivs - 1 - i) / subDivs;\n        const dx = Math.cos(angle);\n        const dz = Math.sin(angle);\n\n        if (generateNormals) {\n            xzn[i] = [radius * dx, radius * dz, vec3.fromValues(dx, 0, dz)];\n        } else {\n            xzn[i] = [radius * dx, radius * dz];\n        }\n    }\n\n    return xzn;\n}", "import { vec3 } from 'gl-matrix';\nimport Vertex from '../math/Vertex';\n\nexport default function triangulateConvexPolygon(vertices: Array<Vertex>, flip = false, output?: Array<Vertex>, startIndex = 0): [Array<Vertex>, number] {\n    // XXX assume that the vertices in the polyline are already in CCW order\n    const vertexCount = vertices.length;\n\n    // fast paths (and error conditions):\n    if (vertexCount < 3) {\n        throw new Error(`Expected input polyline with 3 or more vertices, got ${vertexCount}`);\n    }\n\n    if (!output) {\n        output = new Array(startIndex + (vertexCount - 2) * 3);\n    }\n\n    if (vertexCount === 3) {\n        // already a triangle, copy it\n        if (flip) {\n            output[startIndex++] = vertices[2].clone();\n            output[startIndex++] = vertices[1].clone();\n            output[startIndex++] = vertices[0].clone();\n        } else {\n            output[startIndex++] = vertices[0].clone();\n            output[startIndex++] = vertices[1].clone();\n            output[startIndex++] = vertices[2].clone();\n        }\n\n        return [output, startIndex];\n    } else if (vertexCount === 4) {\n        // triangulate a square. special case that avoids sliver triangles\n        if (flip) {\n            output[startIndex++] = vertices[2].clone();\n            output[startIndex++] = vertices[1].clone();\n            output[startIndex++] = vertices[0].clone();\n        } else {\n            output[startIndex++] = vertices[0].clone();\n            output[startIndex++] = vertices[1].clone();\n            output[startIndex++] = vertices[2].clone();\n        }\n\n        if (vec3.squaredDistance(vertices[0].pos, vertices[2].pos) <= vec3.squaredDistance(vertices[1].pos, vertices[3].pos)) {\n            output[startIndex++] = vertices[0].clone();\n        } else {\n            output[startIndex++] = vertices[1].clone();\n        }\n\n        if (flip) {\n            output[startIndex++] = vertices[3].clone();\n            output[startIndex++] = vertices[2].clone();\n        } else {\n            output[startIndex++] = vertices[2].clone();\n            output[startIndex++] = vertices[3].clone();\n        }\n\n        return [output, startIndex];\n    }\n\n    // general case: use top-to-bottom scan algorithm\n    // sort vertices by XYZ respectively\n    const indices = Array.from({ length: vertexCount }, (_, i) => i);\n    indices.sort((aIdx, bIdx) => {\n        // if a < b, then -1, if a = b, then 0, if a > b, then 1\n        const a: Vertex = vertices[aIdx];\n        const b: Vertex = vertices[bIdx];\n\n        // compare x\n        if (a.pos[0] < b.pos[0]) {\n            return -1;\n        } else if (a.pos[0] > b.pos[0]) {\n            return 1;\n        } else {\n            // x equal. compare y\n            if (a.pos[1] < b.pos[1]) {\n                return -1;\n            } else if (a.pos[1] > b.pos[1]) {\n                return 1;\n            } else {\n                // y equal. compare z\n                if (a.pos[2] < b.pos[2]) {\n                    return -1;\n                } else if (a.pos[2] > b.pos[2]) {\n                    return 1;\n                } else {\n                    return 0;\n                }\n            }\n        }\n    });\n\n    // scan vertices from \"top\" to \"bottom\" (not really, but by the sorted\n    // order). since the vertices array is a polyline in CCW order, then we can\n    // make a triangle in the correct orientation by connecting the highest\n    // index vertex to the lowest index vertex to the other vertex\n    for (let i = 2; i < vertexCount; i++) {\n        // get indices for this triangle\n        let idxLow = indices[i - 2];\n        let idxMid = indices[i - 1];\n        let idxHigh = indices[i];\n\n        // sort by index number with an unrolled bubble sort. found in:\n        // https://stackoverflow.com/a/16612345\n        if (idxLow > idxMid) {\n            [idxLow, idxMid] = [idxMid, idxLow];\n        }\n        if (idxMid > idxHigh) {\n            [idxMid, idxHigh] = [idxHigh, idxMid];\n            if (idxLow > idxMid) {\n                [idxLow, idxMid] = [idxMid, idxLow];\n            }\n        }\n\n        // flip triangle if necessary\n        if (flip) {\n            [idxHigh, idxLow] = [idxLow, idxHigh];\n        }\n\n        // add triangle to output\n        output[startIndex++] = vertices[idxHigh].clone();\n        output[startIndex++] = vertices[idxLow].clone();\n        output[startIndex++] = vertices[idxMid].clone();\n    }\n\n    return [output, startIndex];\n}", "import { vec3 } from 'gl-matrix';\n\nimport Box3 from '../math/Box3';\nimport Vertex from '../math/Vertex';\nimport { CSGPrimitive } from './CSGPrimitive';\nimport { makeCircularBase, precalcCircularBase } from './make-circular-base';\n\nimport type { CSGPrimitiveOptions } from './CSGPrimitive';\nimport Plane from '../math/Plane';\n\nexport class BaseCone extends CSGPrimitive {\n    constructor(baseVertices: number, smoothNormals: boolean, diameter: number, length: number, options?: CSGPrimitiveOptions) {\n        // pre-calculations\n        const vertexCount = (baseVertices - 2) * 3 + baseVertices * 3;\n        const vertices = new Array<Vertex>(vertexCount);\n        const radius = diameter / 2;\n        const halfLength = length / 2;\n        const tip = vec3.fromValues(0, halfLength, 0);\n        const xzn = precalcCircularBase(baseVertices, radius, smoothNormals);\n\n        // calculate normals to match cone slope\n        if (smoothNormals) {\n            const angle = Math.atan(radius / length);\n            const xNormMul = Math.cos(angle);\n            const yNormVal = Math.sin(angle);\n\n            for (let i = 0; i < baseVertices; i++) {\n                const normal = xzn[i][2] as vec3;\n                normal[0] *= xNormMul;\n                normal[1] = yNormVal;\n                normal[2] *= xNormMul;\n            }\n        }\n\n        // make base\n        let index = makeCircularBase(vertices, xzn, -halfLength, vec3.fromValues(0, -1, 0), 0, true);\n\n        // make sides\n        for (let i = 0; i < baseVertices; i++) {\n            const xzn1 = xzn[i];\n            const xzn2 = xzn[(i + 1) % baseVertices];\n            const [x1, z1] = xzn1;\n            const [x2, z2] = xzn2;\n            const a = vec3.fromValues(x2, -halfLength, z2);\n            const b = vec3.clone(tip);\n            const c = vec3.fromValues(x1, -halfLength, z1);\n\n            let an: vec3, bn: vec3, cn: vec3;\n            if (smoothNormals) {\n                an = xzn1[2] as vec3;\n                // XXX this is counterintuitive, but the cone tip should have a\n                // normal pointing up, instead of pointing at the sloped angle\n                // between the 2 connected vertices\n                bn = vec3.fromValues(0, 1, 0);\n                cn = xzn2[2] as vec3;\n            } else {\n                an = bn = cn = Plane.calculateNormal(a, b, c);\n            }\n\n            vertices[index++] = new Vertex(a, vec3.clone(cn));\n            vertices[index++] = new Vertex(b, bn);\n            vertices[index++] = new Vertex(c, vec3.clone(an));\n        }\n\n        // make bounding box\n        const max = vec3.fromValues(radius, halfLength, radius);\n        const min = vec3.negate(vec3.create(), max);\n\n        super(new Box3(min, max), vertices, options);\n    }\n}", "import { BaseCone } from './BaseCone';\n\nimport type CircularBaseCSGPrimitiveOptions from './CircularBaseCSGPrimitiveOptions';\n\nexport class Cone extends BaseCone {\n    constructor(diameter = 1, length = 1, options?: CircularBaseCSGPrimitiveOptions) {\n        super(options?.subDivisions ?? 12, true, diameter, length, options);\n    }\n}", "import { BaseCone } from './BaseCone';\n\nimport type { CSGPrimitiveOptions } from './CSGPrimitive';\n\nexport class Pyramid extends BaseCone {\n    constructor(sides: number, diameter = 1, length = 1, options?: CSGPrimitiveOptions) {\n        super(sides, false, diameter, length, options);\n    }\n}", "import { vec3 } from 'gl-matrix';\n\nimport Box3 from '../math/Box3';\nimport Vertex from '../math/Vertex';\nimport { CSGPrimitive } from './CSGPrimitive';\nimport Plane from '../math/Plane';\nimport makeIcosahedronTriangles from './icosahedron-make-triangles';\n\nimport type { CSGPrimitiveOptions } from './CSGPrimitive';\n\nfunction addTriangle(vertices: Array<Vertex>, index: number, radius: number, a: Readonly<vec3>, b: Readonly<vec3>, c: Readonly<vec3>) {\n    const normal = Plane.calculateNormal(a, b, c);\n    vertices[index++] = new Vertex(vec3.scale(vec3.create(), a, radius), vec3.clone(normal));\n    vertices[index++] = new Vertex(vec3.scale(vec3.create(), b, radius), vec3.clone(normal));\n    vertices[index++] = new Vertex(vec3.scale(vec3.create(), c, radius), normal);\n    return index;\n}\n\nexport class Icosahedron extends CSGPrimitive {\n    constructor(diameter = 1, options?: CSGPrimitiveOptions) {\n        // make bounding box\n        const radius = diameter / 2;\n\n        const max = vec3.fromValues(radius, radius, radius);\n        const min = vec3.negate(vec3.create(), max);\n\n        // add icosahedron triangles\n        const vertices = new Array(60);\n        makeIcosahedronTriangles(addTriangle, vertices, radius);\n\n        super(new Box3(min, max), vertices, options);\n    }\n}", "import { vec3 } from 'gl-matrix';\n\nimport Vertex from '../math/Vertex';\n\nconst ICO_V: Array<Readonly<vec3>> = [\n    vec3.fromValues( 0       ,  1       ,  0      ),\n    vec3.fromValues( 0.276385,  0.447215, -0.85064),\n    vec3.fromValues(-0.7236  ,  0.447215, -0.52572),\n    vec3.fromValues(-0.7236  ,  0.447215,  0.52572),\n    vec3.fromValues( 0.276385,  0.447215,  0.85064),\n    vec3.fromValues( 0.894425,  0.447215,  0      ),\n    vec3.fromValues(-0.276385, -0.447215, -0.85064),\n    vec3.fromValues(-0.894425, -0.447215,  0      ),\n    vec3.fromValues(-0.276385, -0.447215,  0.85064),\n    vec3.fromValues( 0.7236  , -0.447215,  0.52572),\n    vec3.fromValues( 0.7236  , -0.447215, -0.52572),\n    vec3.fromValues( 0       , -1       ,  0      ),\n];\n\nexport default function makeIcosahedronTriangles(addTriangle: (vertices: Array<Vertex>, index: number, radius: number, a: Readonly<vec3>, b: Readonly<vec3>, c: Readonly<vec3>) => number, vertices: Array<Vertex>, radius: number) {\n    // top triangles\n    let index = addTriangle(vertices, 0, radius, ICO_V[0], ICO_V[1], ICO_V[2]);\n    index = addTriangle(vertices, index, radius, ICO_V[0], ICO_V[2], ICO_V[3]);\n    index = addTriangle(vertices, index, radius, ICO_V[0], ICO_V[3], ICO_V[4]);\n    index = addTriangle(vertices, index, radius, ICO_V[0], ICO_V[4], ICO_V[5]);\n    index = addTriangle(vertices, index, radius, ICO_V[0], ICO_V[5], ICO_V[1]);\n\n    // side triangles\n    index = addTriangle(vertices, index, radius, ICO_V[1], ICO_V[6], ICO_V[2]);\n    index = addTriangle(vertices, index, radius, ICO_V[2], ICO_V[6], ICO_V[7]);\n    index = addTriangle(vertices, index, radius, ICO_V[2], ICO_V[7], ICO_V[3]);\n    index = addTriangle(vertices, index, radius, ICO_V[3], ICO_V[7], ICO_V[8]);\n    index = addTriangle(vertices, index, radius, ICO_V[3], ICO_V[8], ICO_V[4]);\n    index = addTriangle(vertices, index, radius, ICO_V[4], ICO_V[8], ICO_V[9]);\n    index = addTriangle(vertices, index, radius, ICO_V[4], ICO_V[9], ICO_V[5]);\n    index = addTriangle(vertices, index, radius, ICO_V[5], ICO_V[9], ICO_V[10]);\n    index = addTriangle(vertices, index, radius, ICO_V[5], ICO_V[10], ICO_V[1]);\n    index = addTriangle(vertices, index, radius, ICO_V[1], ICO_V[10], ICO_V[6]);\n\n    // bottom triangles\n    index = addTriangle(vertices, index, radius, ICO_V[11], ICO_V[7], ICO_V[6]);\n    index = addTriangle(vertices, index, radius, ICO_V[11], ICO_V[8], ICO_V[7]);\n    index = addTriangle(vertices, index, radius, ICO_V[11], ICO_V[9], ICO_V[8]);\n    index = addTriangle(vertices, index, radius, ICO_V[11], ICO_V[10], ICO_V[9]);\n            addTriangle(vertices, index, radius, ICO_V[11], ICO_V[6], ICO_V[10]);\n}", "import { vec3 } from 'gl-matrix';\n\nimport Box3 from '../math/Box3';\nimport Vertex from '../math/Vertex';\nimport { CSGPrimitive } from './CSGPrimitive';\nimport makeIcosahedronTriangles from './icosahedron-make-triangles';\n\nimport type { CSGPrimitiveOptions } from './CSGPrimitive';\n\nfunction addTriangle(depth: number, vertices: Array<Vertex>, index: number, radius: number, a: Readonly<vec3>, b: Readonly<vec3>, c: Readonly<vec3>) {\n    if (depth <= 0) {\n        // target depth reached, make triangle\n        vertices[index++] = new Vertex(vec3.scale(vec3.create(), a, radius), vec3.clone(a));\n        vertices[index++] = new Vertex(vec3.scale(vec3.create(), b, radius), vec3.clone(b));\n        vertices[index++] = new Vertex(vec3.scale(vec3.create(), c, radius), vec3.clone(c));\n    } else {\n        // target depth not reached, subdivide triangle into 4 triangles\n        const abm = vec3.add(vec3.create(), a, b);\n        vec3.normalize(abm, abm);\n        const bcm = vec3.add(vec3.create(), b, c);\n        vec3.normalize(bcm, bcm);\n        const cam = vec3.add(vec3.create(), c, a);\n        vec3.normalize(cam, cam);\n\n        const nextDepth = depth - 1;\n\n        index = addTriangle(nextDepth, vertices, index, radius, a, abm, cam);\n        index = addTriangle(nextDepth, vertices, index, radius, abm, b, bcm);\n        index = addTriangle(nextDepth, vertices, index, radius, abm, bcm, cam);\n        index = addTriangle(nextDepth, vertices, index, radius, cam, bcm, c);\n    }\n\n    return index;\n}\n\nexport type IcosphereCSGPrimitiveOptions = CSGPrimitiveOptions & {\n    subDivisions?: number,\n};\n\nexport class Icosphere extends CSGPrimitive {\n    constructor(diameter = 1, options?: IcosphereCSGPrimitiveOptions) {\n        // make bounding box\n        const radius = diameter / 2;\n\n        const max = vec3.fromValues(radius, radius, radius);\n        const min = vec3.negate(vec3.create(), max);\n\n        // add icosphere triangles recursively\n        const subDivs = options?.subDivisions ?? 2;\n        const vertices = new Array(60 * 4 ** subDivs);\n        makeIcosahedronTriangles(addTriangle.bind(null, subDivs), vertices, radius);\n\n        super(new Box3(min, max), vertices, options);\n    }\n}", "import { mat4, quat, vec3 } from 'gl-matrix';\n\nimport { CSGPrimitive } from './CSGPrimitive';\nimport Box3 from '../math/Box3';\nimport { TAU } from '../math/const-numbers';\nimport Vertex from '../math/Vertex';\nimport { tmpm4_0, tmpm4_1, tv0 } from '../math/temp';\n\nimport type { CSGPrimitiveOptions } from './CSGPrimitive';\n\nexport type TorusCSGPrimitiveOptions = CSGPrimitiveOptions & {\n    radialSubDivisions?: number,\n    tubularSubDivisions?: number,\n};\n\nexport class Torus extends CSGPrimitive {\n    constructor(outerDiameter = 1, innerDiameter = 0.5, options?: TorusCSGPrimitiveOptions) {\n        // make bounding box\n        const radSubDivs = options?.radialSubDivisions ?? 8;\n        const tubSubDivs = options?.tubularSubDivisions ?? 16;\n        const outerRadius = outerDiameter / 2;\n        const innerRadius = innerDiameter / 2;\n        const tubeRadius = outerRadius - innerRadius;\n\n        const max = vec3.fromValues(outerRadius, tubeRadius, outerRadius);\n        const min = vec3.negate(vec3.create(), max);\n\n        // pre-calculate segment vertices\n        const tubularSegments = new Array<Array<[positions: vec3, normals: vec3]>>(tubSubDivs);\n\n        for (let i = 0; i < tubSubDivs; i++) {\n            const radialSegments = new Array(radSubDivs);\n            tubularSegments[i] = radialSegments;\n\n            // XXX for some reason fromEuler breaks the norm and uses degrees\n            // instead of radians. THIS IS NOT A MISTAKE\n            const tubeRot = quat.fromEuler(quat.create(), 0, 360 * i / tubSubDivs, 0);\n\n            vec3.set(tv0, innerRadius + tubeRadius, 0, 0);\n            mat4.fromTranslation(tmpm4_0, tv0);\n            mat4.fromQuat(tmpm4_1, tubeRot);\n            mat4.multiply(tmpm4_0, tmpm4_1, tmpm4_0);\n\n            for (let j = 0; j < radSubDivs; j++) {\n                const angle = TAU * j / radSubDivs;\n                const x = Math.cos(angle);\n                const y = Math.sin(angle);\n\n                const pos = vec3.fromValues(x * tubeRadius, y * tubeRadius, 0);\n                vec3.transformMat4(pos, pos, tmpm4_0);\n                const normal = vec3.fromValues(x, y, 0);\n                vec3.transformQuat(normal, normal, tubeRot);\n\n                radialSegments[j] = [pos, normal];\n            }\n        }\n\n        // generate torus segments from pre-calculated vertices\n        const vertices = new Array(tubSubDivs * radSubDivs * 6);\n        let index = 0;\n\n        for (let i = 0; i < tubSubDivs; i++) {\n            const segment1 = tubularSegments[i];\n            const segment2 = tubularSegments[(i + 1) % tubSubDivs];\n\n            for (let j = 0; j < radSubDivs; j++) {\n                const jNext = (j + 1) % radSubDivs;\n                const [pos11, normal11] = segment1[j];\n                const [pos21, normal21] = segment2[j];\n                const [pos12, normal12] = segment1[jNext];\n                const [pos22, normal22] = segment2[jNext];\n\n                // first triangle\n                vertices[index++] = new Vertex(vec3.clone(pos12), vec3.clone(normal12));\n                vertices[index++] = new Vertex(pos11, normal11);\n                vertices[index++] = new Vertex(vec3.clone(pos21), vec3.clone(normal21));\n                // second triangle\n                vertices[index++] = new Vertex(vec3.clone(pos21), vec3.clone(normal21));\n                vertices[index++] = new Vertex(vec3.clone(pos22), vec3.clone(normal22));\n                vertices[index++] = new Vertex(pos12, normal12);\n            }\n        }\n\n        super(new Box3(min, max), vertices, options);\n    }\n}", "import { vec3, vec2 } from 'gl-matrix';\n\nimport Plane from '../math/Plane';\nimport Vertex from '../math/Vertex';\nimport OctreeCSG from '../base/OctreeCSG';\nimport { Polygon } from '../math/Polygon';\nimport isClockwise2DPolygon from './is-clockwise-2d-polygon';\nimport triangulateMonotone2DPolygon from './triangulate-monotone-2d-polygon';\nimport partition2DPolygon from './partition-2d-polygon';\n\nexport default function linearExtrude(polyline: Array<vec2>, depth: number, includeBases = true) {\n    // check if polygon is clockwise. if so, the the extrusion will be\n    // inside-out\n    const isClockwise = isClockwise2DPolygon(polyline);\n\n    // make sides of extrusion\n    const polylineLength = polyline.length;\n    const octree = new OctreeCSG();\n\n    for (let i = 0; i < polylineLength; i++) {\n        const j = (i + 1) % polylineLength;\n        const xyi = polyline[i];\n        const xyj = polyline[j];\n\n        const fi = vec3.create();\n        vec2.copy(fi as vec2, xyi);\n        const bi = vec3.fromValues(0, 0, depth);\n        vec2.copy(bi as vec2, xyi);\n        const fj = vec3.create();\n        vec2.copy(fj as vec2, xyj);\n        const bj = vec3.fromValues(0, 0, depth);\n        vec2.copy(bj as vec2, xyj);\n\n        const normal = Plane.calculateNormal(fi, fj, bj);\n\n        // make polygons\n        const polygonA = new Polygon([\n            new Vertex(vec3.clone(fi), vec3.clone(normal)),\n            new Vertex(fj, vec3.clone(normal)),\n            new Vertex(vec3.clone(bj), vec3.clone(normal)),\n        ]);\n        polygonA.originalValid = true;\n        octree.addPolygon(polygonA);\n\n        const polygonB = new Polygon([\n            new Vertex(bj, vec3.clone(normal)),\n            new Vertex(bi, vec3.clone(normal)),\n            new Vertex(fi, normal),\n        ]);\n        polygonB.originalValid = true;\n        octree.addPolygon(polygonB);\n    }\n\n    // make bases of extrusion\n    // XXX note that the input CCW polyline is flipped because the extrusion\n    // happens towards +Z\n    if (includeBases) {\n        // make monotone partitions from polygon\n        const isClockwiseHint = isClockwise2DPolygon(polyline);\n        const partitions = partition2DPolygon(polyline, undefined, isClockwiseHint);\n\n        for (const partition of partitions) {\n            const [triangulated, _endIndex] = triangulateMonotone2DPolygon(partition, undefined, 0, isClockwiseHint);\n            const triVertCount = triangulated.length;\n\n            let normal1 = vec3.fromValues(0, 0, -1);\n            let normal2 = vec3.fromValues(0, 0, 1);\n\n            if (isClockwise) {\n                [normal1, normal2] = [normal2, normal1];\n            }\n\n            for (let i = 0; i < triVertCount;) {\n                // make vertices\n                const a_2d = triangulated[i++];\n                const a1 = new Vertex(vec3.fromValues(a_2d[0], a_2d[1], 0), vec3.clone(normal1));\n                const a2 = new Vertex(vec3.fromValues(a_2d[0], a_2d[1], depth), vec3.clone(normal2));\n                const b_2d = triangulated[i++];\n                const b1 = new Vertex(vec3.fromValues(b_2d[0], b_2d[1], 0), vec3.clone(normal1));\n                const b2 = new Vertex(vec3.fromValues(b_2d[0], b_2d[1], depth), vec3.clone(normal2));\n                const c_2d = triangulated[i++];\n                const c1 = new Vertex(vec3.fromValues(c_2d[0], c_2d[1], 0), vec3.clone(normal1));\n                const c2 = new Vertex(vec3.fromValues(c_2d[0], c_2d[1], depth), vec3.clone(normal2));\n\n                // make polygons\n                const polygonA = new Polygon([c1, b1, a1]);\n                polygonA.originalValid = true;\n                octree.addPolygon(polygonA);\n                const polygonB = new Polygon([a2, b2, c2]);\n                polygonB.originalValid = true;\n                octree.addPolygon(polygonB);\n            }\n        }\n    }\n\n    return octree;\n}", "import type { vec2 } from 'gl-matrix';\n\nexport default function isClockwise2DPolygon(polyline: Array<vec2>): boolean {\n    // sum up all the edges of the polygon to get 2x signed area. if signed area\n    // is positive, then the polygon is clockwise\n    let sum = 0;\n    const vertCount = polyline.length;\n    let last = polyline[vertCount - 1];\n\n    for (const next of polyline) {\n        sum += (next[0] - last[0]) * (next[1] + last[1]);\n        last = next;\n    }\n\n    return sum >= 0;\n}", "import { vec2 } from 'gl-matrix';\nimport { tv0_2, tv1_2 } from '../math/temp';\nimport isClockwise2DPolygon from './is-clockwise-2d-polygon';\nimport isClockwise2DTriangle from './is-clockwise-2d-triangle';\nimport sort2DIndices from './sort-2d-indices';\n\nfunction addTriangle(output: Array<vec2>, index: number, clockwise: boolean, a: vec2, b: vec2, c: vec2): number {\n    output[index++] = a;\n\n    if (isClockwise2DTriangle(a, b, c) === clockwise) {\n        output[index++] = b;\n        output[index++] = c;\n    } else {\n        output[index++] = c;\n        output[index++] = b;\n    }\n\n    return index;\n}\n\nexport default function triangulateMonotone2DPolygon(polyline: Array<vec2>, output?: Array<vec2>, index = 0, isClockwiseHint?: boolean): [triangles: Array<vec2>, lastIndex: number] {\n    const vertexCount = polyline.length;\n\n    // fast paths (and error conditions):\n    if (vertexCount < 3) {\n        throw new Error(`Expected input polyline with 3 or more vertices, got ${vertexCount}`);\n    }\n\n    const outputSize = index + (vertexCount - 2) * 3;\n    if (output) {\n        if (output.length < outputSize) {\n            output.length = outputSize;\n        }\n    } else {\n        output = new Array(outputSize);\n    }\n\n    if (vertexCount === 3) {\n        // already a triangle, copy it\n        output[index++] = vec2.clone(polyline[0]);\n        output[index++] = vec2.clone(polyline[1]);\n        output[index++] = vec2.clone(polyline[2]);\n\n        return [output, index];\n    }\n\n    // XXX don't do a special case for squares since the square may not be\n    // convex and may result in bad triangles\n\n    // general case: using monotone polygon triangulation algorithm from a book:\n    // Computational Geometry: Algorithms and Applications (second edition,\n    // section 3.3), by Mark de Berg, Marc van Krefeld, and Mark Overmars\n\n    // XXX triangle orientation is very chaotic, so it is properly oriented\n    // when inserting each triangle in the output instead of relying of the\n    // algorithm's scan order\n    if (isClockwiseHint === undefined) {\n        isClockwiseHint = isClockwise2DPolygon(polyline);\n    }\n\n    // sort vertices by XY respectively\n    const indices = sort2DIndices(polyline);\n    let stack = [indices[0], indices[1]];\n\n    for (let i = 2; i < vertexCount - 1; i++) {\n        const thisIndex = indices[i];\n        const thisVertex = polyline[thisIndex];\n\n        const stackLen = stack.length;\n        const topIndex = stack[stackLen - 1];\n        const topVertex = polyline[topIndex];\n\n        if ((thisIndex !== (topIndex + 1) % vertexCount) && (topIndex !== (thisIndex + 1) % vertexCount)) {\n            // opposite chains\n            for (let j = 0; j < stackLen - 1; j++) {\n                index = addTriangle(output, index, isClockwiseHint, thisVertex, vec2.clone(polyline[stack[j]]), vec2.clone(polyline[stack[j + 1]]));\n            }\n\n            stack = [indices[i - 1], thisIndex];\n        } else {\n            // same chain\n            let lastPoppedVertex = topVertex;\n            let lastPoppedIndex = stack.pop() as number;\n            while (stack.length > 0) {\n                const nextPoppedIndex = stack[stack.length - 1];\n                const nextPoppedVertex = polyline[nextPoppedIndex];\n\n                // check if diagonal from current vertex to popped vertex is\n                // inside polygon. if not, stop popping\n                // 1. get direction from vertex before popped, to popped\n                const beforePoppedIndex = (((nextPoppedIndex - 1) % vertexCount) + vertexCount) % vertexCount;\n                const beforePoppedVertex = polyline[beforePoppedIndex];\n                const dir = vec2.sub(tv0_2, nextPoppedVertex, beforePoppedVertex);\n\n                // 2. get left of direction (inside direction, since CCW's\n                // inside is to the left)\n                const insideDir = vec2.fromValues(-dir[1], dir[0]);\n\n                // 3. get direction from verted before popped to current vertex\n                const curDir = vec2.sub(tv1_2, thisVertex, beforePoppedVertex);\n\n                // 4. check if to the left of direction (inside). if not, break\n                if (vec2.dot(curDir, insideDir) <= 0) {\n                    break;\n                }\n\n                stack.pop();\n                index = addTriangle(output, index, isClockwiseHint, thisVertex, vec2.clone(lastPoppedVertex), vec2.clone(nextPoppedVertex));\n                lastPoppedIndex = nextPoppedIndex;\n                lastPoppedVertex = nextPoppedVertex;\n            }\n\n            if (lastPoppedIndex !== undefined) {\n                stack.push(lastPoppedIndex);\n            }\n\n            stack.push(thisIndex);\n        }\n    }\n\n    const lastVertex = polyline[indices[vertexCount - 1]];\n    const iterLen = stack.length - 1;\n\n    for (let i = 0; i < iterLen; i++) {\n        index = addTriangle(output, index, isClockwiseHint, vec2.clone(lastVertex), vec2.clone(polyline[stack[i]]), vec2.clone(polyline[stack[i + 1]]));\n    }\n\n    return [output, index];\n}", "import type { vec2 } from 'gl-matrix';\n\nexport default function isClockwise2DTriangle(a: vec2, b: vec2, c: vec2): boolean {\n    // similar to isClockwise2DPolygon, but optimised for 3 points\n    return (\n        (b[0] - a[0]) * (b[1] + a[1]) +\n        (c[0] - b[0]) * (c[1] + b[1]) +\n        (a[0] - c[0]) * (a[1] + c[1])\n    ) >= 0;\n}", "import type { vec2 } from 'gl-matrix';\n\nexport default function sort2DIndices(polyline: Array<vec2>): Array<number> {\n    const indices = Array.from({ length: polyline.length }, (_, i) => i);\n    indices.sort((aIdx, bIdx) => {\n        // if a < b, then -1, if a = b, then 0, if a > b, then 1\n        const a: vec2 = polyline[aIdx];\n        const b: vec2 = polyline[bIdx];\n\n        // compare x\n        if (a[0] < b[0]) {\n            return -1;\n        } else if (a[0] > b[0]) {\n            return 1;\n        } else {\n            // x equal. compare y\n            if (a[1] < b[1]) {\n                return -1;\n            } else if (a[1] > b[1]) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }\n    });\n\n    return indices;\n}", "import { vec2 } from 'gl-matrix';\n\nfunction getPolygonInLoop(indices: Array<number>, start: number, end: number): Array<number> {\n    const indexCount = indices.length;\n    const output: Array<number> = [start];\n\n    for (let i = (indices.indexOf(start) + 1) % indexCount;; i = (i + 1) % indexCount) {\n        const actualIndex = indices[i];\n        output.push(actualIndex);\n\n        if (actualIndex === end) {\n            return output;\n        } else if (actualIndex === start) {\n            throw new Error(`getPolygonInLoop aborted; infinite loop detected due to possibly invalid split diagonal (${start}, ${end})`);\n        }\n    }\n}\n\nfunction splitPolygonTo(polyline: Array<vec2>, indices: Array<number>, diagonals: Array<[number, number]>, output: Array<Array<vec2>>, flip: boolean) {\n    if (diagonals.length > 0) {\n        // split along first diagonal\n        const [start, end] = diagonals[0];\n        const aIndices = getPolygonInLoop(indices, start, end);\n        const bIndices = getPolygonInLoop(indices, end, start);\n\n        // assign other diagonals to one of the partitions\n        const aDiags = new Array<[number, number]>(), bDiags = new Array<[number, number]>();\n        const diagonalCount = diagonals.length;\n        for (let i = 1; i < diagonalCount; i++) {\n            const [oStart, oEnd] = diagonals[i];\n\n            if (aIndices.indexOf(oStart) >= 0 && aIndices.indexOf(oEnd) >= 0) {\n                aDiags.push([oStart, oEnd]);\n            } else if (bIndices.indexOf(oStart) >= 0 && bIndices.indexOf(oEnd) >= 0) {\n                bDiags.push([oStart, oEnd]);\n            } else {\n                throw new Error(`Invalid split diagonal (${oStart}, ${oEnd})`);\n            }\n        }\n\n        // further split\n        splitPolygonTo(polyline, aIndices, aDiags, output, flip);\n        splitPolygonTo(polyline, bIndices, bDiags, output, flip);\n    } else {\n        // no more diagonals, make actual polyline\n        const indexCount = indices.length;\n        const outPolyline = new Array(indexCount);\n\n        if (flip) {\n            for (let i = 0; i < indexCount; i++) {\n                outPolyline[i] = polyline[indices[indexCount - 1 - i]];\n            }\n        } else {\n            for (let i = 0; i < indexCount; i++) {\n                outPolyline[i] = polyline[indices[i]];\n            }\n        }\n\n        output.push(outPolyline);\n    }\n}\n\nexport default function split2DPolygon(polyline: Array<vec2>, diagonals: Array<[number, number]>, output?: Array<Array<vec2>>, flip = false): Array<Array<vec2>> {\n    if (!output) {\n        output = [];\n    }\n\n    splitPolygonTo(polyline, Array.from({ length: polyline.length }, (_, i) => i), diagonals, output, flip);\n    return output;\n}", "import { vec2 } from 'gl-matrix';\nimport { TAU } from '../math/const-numbers';\nimport isClockwise2DPolygon from './is-clockwise-2d-polygon';\nimport sort2DIndices from './sort-2d-indices';\nimport split2DPolygon from './split-2d-polygon';\n\nenum VertexType {\n    Start,\n    End,\n    Regular,\n    Split,\n    Merge\n}\n\nfunction isAbove(p: vec2, q: vec2) {\n    return p[0] < q[0] || (p[0] === q[0] && p[1] < q[1]);\n}\n\nfunction interiorAngle(prev: vec2, cur: vec2, next: vec2) {\n    // XXX angles must be negated due to CCW winding order\n    const prevAngle = -Math.atan2(prev[1] - cur[1], prev[0] - cur[0]);\n    const nextAngle = -Math.atan2(next[1] - cur[1], next[0] - cur[0]);\n    // XXX mod used instead of remainder because angles can be negative\n    return (((nextAngle - prevAngle) % TAU) + TAU) % TAU;\n}\n\nfunction getLeftEdge(polyline: Array<vec2>, status: Set<number>, vertexCount: number, vertex: vec2) {\n    let leftEdge = -1;\n    let leftY = -Infinity;\n\n    for (const lineStartIndex of status) {\n        const lineEndIndex = (lineStartIndex + 1) % vertexCount;\n        const lineStart = polyline[lineStartIndex];\n        const lineEnd = polyline[lineEndIndex];\n\n        let lineMin, lineMax;\n        if (lineStart[0] > lineEnd[0]) {\n            lineMin = lineEnd;\n            lineMax = lineStart;\n        } else {\n            lineMax = lineEnd;\n            lineMin = lineStart;\n        }\n\n        if (vertex[0] >= lineMin[0] && vertex[0] <= lineMax[0]) {\n            // y = mx + c; m = dy / dx; c = y - mx\n            const m = (lineMax[1] - lineMin[1]) / (lineMax[0] - lineMin[0]);\n            const c = lineMin[1] - m * lineMin[0];\n            const y = m * vertex[0] + c;\n\n            if (y <= vertex[1] && y >= leftY) {\n                leftY = y;\n                leftEdge = lineStartIndex;\n            }\n        }\n    }\n\n    if (leftEdge === -1) {\n        throw new Error(`No edge to the left of vertex. Status: ${Array.from(status)}`);\n    }\n\n    return leftEdge;\n}\n\nexport default function partition2DPolygon(polyline: Array<vec2>, output?: Array<Array<vec2>>, isClockwiseHint?: boolean) {\n    // using monotone polygon partitioning algorithm from a book:\n    // Computational Geometry: Algorithms and Applications (second edition,\n    // section 3.2), by Mark de Berg, Marc van Krefeld, and Mark Overmars\n\n    // XXX the algorithm assumes that the input polygon is CCW, but sometimes it\n    // isn't because a uses wants to make, for example, an inverted extrusion.\n    // check for this case\n    if (isClockwiseHint === undefined) {\n        isClockwiseHint = isClockwise2DPolygon(polyline);\n    }\n\n    if (isClockwiseHint) {\n        polyline = polyline.slice().reverse();\n    }\n\n    // sort vertices in polyline. since our triangulation algorithm sweeps from\n    // -X to +X, sort by X values and then Y values, instead of Y then X from\n    // the original algorithm\n    const vertexCount = polyline.length;\n    const helpers = new Map<number, number>();\n    // XXX the original algorithm uses a BST for the status container instead of\n    // a set, but performance has been OK with a set. maybe change in the\n    // future?\n    const status = new Set<number>();\n    const types = new Map<number, VertexType>();\n    const diagonals = new Array<[number, number]>();\n\n    for (const index of sort2DIndices(polyline)) {\n        // get vertex type\n        const prevIndex = ((index - 1 % vertexCount) + vertexCount) % vertexCount;\n        const nextIndex = (index + 1) % vertexCount;\n        const prevVertex = polyline[prevIndex];\n        const vertex = polyline[index];\n        const nextVertex = polyline[nextIndex];\n\n        const abovePrev = isAbove(vertex, prevVertex);\n        const aboveNext = isAbove(vertex, nextVertex);\n\n        if (abovePrev && aboveNext) {\n            // this is either a start or split vertex. check internal angle\n            if (interiorAngle(prevVertex, vertex, nextVertex) < Math.PI) {\n                // start vertex\n                types.set(index, VertexType.Start);\n            } else {\n                // split vertex\n                types.set(index, VertexType.Split);\n\n                const leftEdge = getLeftEdge(polyline, status, vertexCount, vertex);\n                diagonals.push([index, helpers.get(leftEdge) as number]);\n                helpers.set(leftEdge, index);\n            }\n\n            // shared logic\n            status.add(index);\n            helpers.set(index, index);\n\n            continue;\n        } else if (!abovePrev && !aboveNext) {\n            // shared logic\n            const prevHelper = helpers.get(prevIndex);\n            if (prevHelper !== undefined && types.get(prevHelper) === VertexType.Merge) {\n                diagonals.push([index, prevHelper]);\n            }\n\n            status.delete(prevIndex);\n\n            // this is either an end or merge vertex. check internal angle\n            if (interiorAngle(prevVertex, vertex, nextVertex) < Math.PI) {\n                // end vertex\n                types.set(index, VertexType.End);\n            } else {\n                // merge vertex\n                types.set(index, VertexType.Merge);\n\n                const leftEdge = getLeftEdge(polyline, status, vertexCount, vertex);\n                const leftHelper = helpers.get(leftEdge);\n                if (leftHelper !== undefined && types.get(leftHelper) === VertexType.Merge) {\n                    diagonals.push([index, leftHelper]);\n                }\n\n                helpers.set(leftEdge, index);\n            }\n\n            continue;\n        }\n\n        // regular vertex\n        types.set(index, VertexType.Regular);\n\n        // check if interior lies to the right of the vertex. on a CCW polygon,\n        // the polygon interior always lies to the left of an edge, meaning that\n        // the interior lies to the right of a vertex when the edge to the next\n        // vertex is below the vertex\n        if (nextVertex[0] > vertex[0]) {\n            // interior to the right\n            const prevHelper = helpers.get(prevIndex);\n            if (prevHelper !== undefined && types.get(prevHelper) === VertexType.Merge) {\n                diagonals.push([index, prevHelper]);\n            }\n\n            status.delete(prevIndex);\n            status.add(index);\n            helpers.set(index, index);\n        } else {\n            // interior not to the right\n            const leftEdge = getLeftEdge(polyline, status, vertexCount, vertex);\n            const leftHelper = helpers.get(leftEdge);\n            if (leftHelper !== undefined && types.get(leftHelper) === VertexType.Merge) {\n                diagonals.push([index, leftHelper]);\n            }\n\n            helpers.set(leftEdge, index);\n        }\n    }\n\n    // get all partitions by finding all loops in the graph made by the original\n    // polyline and diagonals\n    return split2DPolygon(polyline, diagonals, output, isClockwiseHint);\n}", "import { vec2 } from 'gl-matrix';\nimport isClockwise2DPolygon from './is-clockwise-2d-polygon';\nimport partition2DPolygon from './partition-2d-polygon';\nimport triangulateMonotone2DPolygon from './triangulate-monotone-2d-polygon';\n\nexport default function triangulate2DPolygon(polyline: Array<vec2>, output?: Array<vec2>): Array<vec2> {\n    const isClockwiseHint = isClockwise2DPolygon(polyline);\n    const partitions = partition2DPolygon(polyline, undefined, isClockwiseHint);\n    let outputSize = 0;\n\n    for (const partition of partitions) {\n        outputSize += (partition.length - 2) * 3;\n    }\n\n    if (output) {\n        if (output.length < outputSize) {\n            output.length = outputSize;\n        }\n    } else {\n        output = new Array(outputSize);\n    }\n\n    let index = 0;\n    for (const partition of partitions) {\n        [output, index] = triangulateMonotone2DPolygon(partition, output, index, isClockwiseHint);\n    }\n\n    return output;\n}", "import { mat3, mat4, vec2, vec3, vec4 } from 'gl-matrix';\nimport OctreeCSG from '../base/OctreeCSG';\nimport Plane from '../math/Plane';\nimport { Polygon } from '../math/Polygon';\nimport { tv0 } from '../math/temp';\nimport Vertex from '../math/Vertex';\nimport triangulate2DPolygon from './triangulate-2d-polygon';\n\nfunction makeSlice(output: Array<vec3>, outputMat: mat4, polyline: Array<vec2>, position: vec3, r: vec3, s: vec3, t: vec3) {\n    // r (normal) = +y, s (binormal) = +x, t (tangent) = +z\n    // make matrix from position and frame\n    mat4.set(\n        outputMat,\n        s[0], s[1], s[2], 0,\n        r[0], r[1], r[2], 0,\n        t[0], t[1], t[2], 0,\n        position[0], position[1], position[2], 1\n    );\n\n    // transform polyline to make slice\n    const sliceVerts = polyline.length;\n    for (let i = 0; i < sliceVerts; i++) {\n        const outputVec = output[i];\n        vec2.copy(outputVec as vec2, polyline[i]);\n        outputVec[2] = 0;\n        vec3.transformMat4(outputVec, outputVec, outputMat);\n    }\n}\n\nfunction makeBase(octree: OctreeCSG, triangulatedBase: Array<vec2>, mat: mat4, baseTriVerts: number, flip: boolean) {\n    for (let i = 0; i < baseTriVerts;) {\n        // transform triangle points to match beginning of curve\n        let a = vec3.create();\n        vec2.copy(a as vec2, triangulatedBase[i++]);\n        vec3.transformMat4(a, a, mat);\n        const b = vec3.create();\n        vec2.copy(b as vec2, triangulatedBase[i++]);\n        vec3.transformMat4(b, b, mat);\n        let c = vec3.create();\n        vec2.copy(c as vec2, triangulatedBase[i++]);\n        vec3.transformMat4(c, c, mat);\n\n        if (flip) {\n            [a, c] = [c, a];\n        }\n\n        // calculate normal\n        const normal = Plane.calculateNormal(a, b, c);\n\n        // make vertices\n        const aVert = new Vertex(a, vec3.clone(normal));\n        const bVert = new Vertex(b, vec3.clone(normal));\n        const cVert = new Vertex(c, normal);\n\n        // add to octree\n        const polygon = new Polygon([aVert, bVert, cVert]);\n        polygon.originalValid = true;\n        octree.addPolygon(polygon);\n    }\n}\n\nexport interface CurveExtrusionOptions {\n    includeBases?: boolean;\n    smoothNormals?: boolean;\n}\n\nexport function curveExtrude(polyline: Array<vec2>, positions: Array<vec3>, frames: Array<[r: vec3, s: vec3, t: vec3]>, options?: CurveExtrusionOptions) {\n    // validate curve\n    const pointCount = positions.length;\n\n    if (frames.length !== pointCount) {\n        throw new Error('There must be at least one frame per point');\n    }\n\n    if (pointCount < 2) {\n        throw new Error('There must be at least 1 segment (2 points) in the curve');\n    }\n\n    // output:\n    const octree = new OctreeCSG();\n\n    // pre-calculate first segment's slice (3D polyline)\n    const sliceVertices = polyline.length;\n    let lastSlice = new Array(sliceVertices), curSlice = new Array(sliceVertices);\n\n    for (let i = 0; i < sliceVertices; i++) {\n        lastSlice[i] = vec3.create();\n        curSlice[i] = vec3.create();\n    }\n\n    let lastMat = mat4.create(), lastMatNormal = mat3.create(), curMat = mat4.create(), curMatNormal = mat3.create();\n    makeSlice(curSlice, curMat, polyline, positions[0], ...frames[0]);\n    // XXX don't use normalFromMat4 or you will always get identity matrices\n    mat3.fromMat4(curMatNormal, curMat);\n\n    // pre-calculate untransformed normals of each edge in the polyline\n    const edgeNormals = new Array<vec3>(sliceVertices);\n\n    vec3.set(tv0, 0, 0, 1);\n    for (let i = 0; i < sliceVertices; i++) {\n        const j = (i + 1) % sliceVertices;\n        const iXY = polyline[i];\n        const jXY = polyline[j];\n        const normal = vec3.fromValues(iXY[0] - jXY[0], iXY[1] - jXY[1], 0);\n        edgeNormals[i] = vec3.cross(normal, tv0, normal);\n    }\n\n    // get average normal of connected edges for each vertex in the polyline if\n    // smooth normals are enabled\n    const smoothNormals = options?.smoothNormals ?? false;\n    let vertexNormals: Array<vec3> | undefined;\n\n    if (smoothNormals) {\n        vertexNormals = new Array(sliceVertices);\n\n        for (let i = 0; i < sliceVertices; i++) {\n            let j = i - 1;\n            if (j === -1) {\n                j = sliceVertices - 1;\n            }\n\n            const normal = vec3.add(vec3.create(), edgeNormals[j], edgeNormals[i]);\n            vertexNormals[i] = vec3.normalize(normal, normal);\n        }\n    }\n\n    // triangulate base if necessary\n    let triangulatedBase: Array<vec2> | undefined, baseTriVerts: number | undefined;\n    const includeBases = options?.includeBases ?? true;\n    if (includeBases) {\n        triangulatedBase = triangulate2DPolygon(polyline);\n        baseTriVerts = triangulatedBase.length;\n        // XXX unlike in linear extrusions, the start base is not flipped\n        // because it get's rotated to the correct orientation by a matrix\n        makeBase(octree, triangulatedBase, curMat, baseTriVerts, false);\n    }\n\n    // walk along each curve point/segment\n    const lastSegment = pointCount - 1;\n    for (let i = 1; i < pointCount; i++) {\n        // calculate slice for this point\n        [lastSlice, curSlice, lastMat, curMat, lastMatNormal, curMatNormal] = [curSlice, lastSlice, curMat, lastMat, curMatNormal, lastMatNormal];\n        makeSlice(curSlice, curMat, polyline, positions[i], ...frames[i]);\n        // XXX don't use normalFromMat4 or you will always get identity matrices\n        mat3.fromMat4(curMatNormal, curMat);\n\n        // make segment triangles\n        for (let j = 0; j < sliceVertices; j++) {\n            const k = (j + 1) % sliceVertices;\n\n            // make normals\n            let lastNormalA, lastNormalB, curNormalA, curNormalB;\n\n            if (vertexNormals) {\n                const jNorm = vertexNormals[j];\n                const kNorm = vertexNormals[k];\n                lastNormalA = vec3.clone(jNorm);\n                lastNormalB = vec3.clone(kNorm);\n                curNormalA = vec3.clone(jNorm);\n                curNormalB = vec3.clone(kNorm);\n            } else {\n                const norm = edgeNormals[j];\n                lastNormalA = vec3.clone(norm);\n                lastNormalB = vec3.clone(norm);\n                curNormalA = vec3.clone(norm);\n                curNormalB = vec3.clone(norm);\n            }\n\n            vec3.transformMat3(lastNormalA, lastNormalA, lastMatNormal);\n            vec3.transformMat3(lastNormalB, lastNormalB, lastMatNormal);\n            vec3.transformMat3(curNormalA, curNormalA, curMatNormal);\n            vec3.transformMat3(curNormalB, curNormalB, curMatNormal);\n\n            // make vertices\n            const lastA = new Vertex(lastSlice[j], lastNormalA);\n            const lastB = new Vertex(lastSlice[k], lastNormalB);\n            const curA = new Vertex(vec3.clone(curSlice[j]), curNormalA);\n            const curB = new Vertex(vec3.clone(curSlice[k]), curNormalB);\n\n            // make polygons\n            const polygonA = new Polygon([curB.clone(), lastB, lastA.clone()]);\n            polygonA.originalValid = true;\n            octree.addPolygon(polygonA);\n            const polygonB = new Polygon([lastA, curA, curB]);\n            polygonB.originalValid = true;\n            octree.addPolygon(polygonB);\n        }\n\n        // add ending base if necessary\n        if (includeBases && i === lastSegment) {\n            makeBase(octree, triangulatedBase as Array<vec2>, curMat, baseTriVerts as number, true);\n        }\n    }\n\n    return octree;\n}", "import { quat, vec3 } from 'gl-matrix';\nimport { curveExtrude, CurveExtrusionOptions } from './curve-extrusion-helper';\nimport { tq0, tv0, tv1, tv2 } from '../math/temp';\nimport { HALF_PI, TAU } from '../math/const-numbers';\n\nimport type { vec2 } from 'gl-matrix';\n\nexport interface RMFCurveExtrusionOptions extends CurveExtrusionOptions {\n    // end boundary condition for the RMF curve; the up direction at the end of\n    // the curve\n    endNormal?: vec3;\n    // how many twists should be added to the curve. 0 by default\n    twists?: number;\n}\n\nexport function rotationMinimizingCurveExtrude(polyline: Array<vec2>, positions: Array<vec3>, tangents: Array<vec3>, startNormal: vec3, options?: RMFCurveExtrusionOptions) {\n    // XXX startNormal should be a unit vector pointing up, or if the start is\n    // rotated, then the rotated up unit vector\n\n    // validate curve\n    const pointCount = positions.length;\n\n    if (tangents.length < pointCount) {\n        throw new Error('There must be at least one tangent per point');\n    }\n\n    if (pointCount < 2) {\n        throw new Error('There must be at least 1 segment (2 points) in the curve');\n    }\n\n    // compute rotation minimizing frames. using method from this paper:\n    // https://www.microsoft.com/en-us/research/publication/computation-rotation-minimizing-frames/\n    const frames = new Array<[r: vec3, s: vec3, t: vec3]>(pointCount);\n    const startTangent = tangents[0];\n    const startBinormal = vec3.cross(vec3.create(), startTangent, startNormal);\n    // first frame = (r,s,t); r = normal, s = binormal, t = tangent\n    frames[0] = [startNormal, startBinormal, startTangent];\n\n    for (let i = 0; i < pointCount - 1; i++) {\n        const v_1 = vec3.sub(tv0, positions[i + 1], positions[i]);\n        const c_1 = vec3.dot(v_1, v_1);\n        const r_i = frames[i][0];\n        const t_i = frames[i][2];\n        const temp = -2 / c_1;\n        const r_L_i = vec3.scaleAndAdd(tv1, r_i, v_1, vec3.dot(v_1, r_i) * temp);\n        const t_L_i = vec3.scaleAndAdd(tv2, t_i, v_1, vec3.dot(v_1, t_i) * temp);\n\n        const t_i1 = tangents[i + 1];\n\n        const v_2 = vec3.sub(tv2, t_i1, t_L_i);\n        const c_2 = vec3.dot(v_2, v_2);\n        const r_i1 = vec3.scaleAndAdd(vec3.create(), r_L_i, v_2, vec3.dot(v_2, r_L_i) * -2 / c_2);\n        const s_i1 = vec3.cross(vec3.create(), t_i1, r_i1);\n\n        frames[i + 1] = [r_i1, s_i1, t_i1];\n    }\n\n    const endNormal = options?.endNormal;\n    const twists = options?.twists ?? 0;\n    if (endNormal || twists > 0) {\n        let angleErr = 0;\n\n        if (endNormal) {\n            // end normal included. calculate the error between the computed\n            // normal in the last frame and the wanted normal. convert it to an\n            // angle.\n\n            // this is an extension to the algorithm described in the same paper\n            // as before (section 6.3: variational principles for rmf with\n            // boundary conditions)\n\n            const endTangent = tangents[pointCount - 1];\n            const endBinormal = vec3.cross(vec3.create(), endTangent, endNormal);\n            const actualNormal = frames[pointCount - 1][0];\n\n            const dx = vec3.dot(endBinormal, actualNormal);\n            const dy = vec3.dot(endNormal, actualNormal);\n\n            if (dx !== 0 && dy !== 0) {\n                angleErr = Math.atan2(dy, dx) - HALF_PI;\n            }\n        }\n\n        angleErr += TAU * twists;\n\n        if (angleErr !== 0) {\n            // divide the angle evenly along the curve (angular speed). apply\n            // the angular speed to the whole curve\n            // XXX the technique's article uses a curvature value that is\n            // calculated from the second differential of the curve, however, we\n            // are estimating it by getting the length of each segment instead.\n            // the more segments there are, the more accurate the curvature\n            // value is\n            let totalLength = 0;\n            let lastPos = positions[0];\n            for (let i = 1; i < pointCount; i++) {\n                const curPos = positions[i];\n                totalLength += vec3.distance(lastPos, curPos);\n                lastPos = curPos;\n            }\n\n            let interpLength = 0;\n            lastPos = positions[0];\n            for (let i = 1; i < pointCount; i++) {\n                const [r, s, _t] = frames[i];\n                const curPos = positions[i];\n                interpLength += vec3.distance(lastPos, curPos);\n                lastPos = curPos;\n\n                const thisAngleErr = angleErr * interpLength / totalLength;\n                quat.setAxisAngle(tq0, tangents[i], thisAngleErr);\n                vec3.transformQuat(r, r, tq0);\n                vec3.transformQuat(s, s, tq0);\n            }\n        }\n    }\n\n    return curveExtrude(polyline, positions, frames, options);\n}", "import { vec2 } from 'gl-matrix';\nimport { TAU } from '../math/const-numbers';\n\nexport default function makeRegularPolyline(radius: number, sides: number, clockwise = false): Array<vec2> {\n    if (sides < 3) {\n        throw new Error('There must be at least 3 sides in a regular polyline');\n    }\n\n    const polyline = new Array(sides);\n    const sidesM1 = sides - 1;\n\n    for (let i = 0; i < sides; i++) {\n        const j = clockwise ? i : (sidesM1 - i);\n        const angle = TAU * j / sides;\n        const y = Math.cos(angle) * radius;\n        const x = Math.sin(angle) * radius;\n        polyline[i] = vec2.fromValues(x, y);\n    }\n\n    return polyline;\n}", "import makeRegularPolyline from './regular-polyline';\n\nimport type { vec2 } from 'gl-matrix';\n\nexport default function makeCirclePolyline(radius: number, clockwise = false, subDivisions = 12): Array<vec2> {\n    return makeRegularPolyline(radius, subDivisions, clockwise);\n}", "import { vec2 } from 'gl-matrix';\n\nexport default function makeCubePolyline(length: number, clockwise = false): Array<vec2> {\n    const half = length / 2;\n    return clockwise ? [\n        vec2.fromValues(half, half), vec2.fromValues(half, -half),\n        vec2.fromValues(-half, -half), vec2.fromValues(-half, half)\n    ] : [\n        vec2.fromValues(half, half), vec2.fromValues(-half, half),\n        vec2.fromValues(-half, -half), vec2.fromValues(half, -half)\n    ];\n}", "import { vec2 } from 'gl-matrix';\n\nexport default function makeRectanglePolyline(width: number, height: number, clockwise = false): Array<vec2> {\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n    return clockwise ? [\n        vec2.fromValues(halfWidth, halfHeight), vec2.fromValues(halfWidth, -halfHeight),\n        vec2.fromValues(-halfWidth, -halfHeight), vec2.fromValues(-halfWidth, halfHeight)\n    ] : [\n        vec2.fromValues(halfWidth, halfHeight), vec2.fromValues(-halfWidth, halfHeight),\n        vec2.fromValues(-halfWidth, -halfHeight), vec2.fromValues(halfWidth, -halfHeight)\n    ];\n}", "import { vec2 } from 'gl-matrix';\nimport { TAU } from '../math/const-numbers';\n\nexport default function makeStarPolyline(outerRadius: number, innerRadius: number, sides: number, clockwise = false): Array<vec2> {\n    if (sides < 3) {\n        throw new Error('There must be at least 3 sides in a star polyline');\n    }\n\n    const polyline = new Array(sides * 2);\n    const sidesM1 = sides - 1;\n    const halfAngle = TAU / sides / 2;\n    let k = 0;\n\n    for (let i = 0; i < sides; i++) {\n        const j = clockwise ? i : (sidesM1 - i);\n\n        const outerAngle = TAU * j / sides;\n        const outerY = Math.cos(outerAngle) * outerRadius;\n        const outerX = Math.sin(outerAngle) * outerRadius;\n        const outerPos = vec2.fromValues(outerX, outerY);\n\n        const innerAngle = outerAngle + halfAngle;\n        const innerY = Math.cos(innerAngle) * innerRadius;\n        const innerX = Math.sin(innerAngle) * innerRadius;\n        const innerPos = vec2.fromValues(innerX, innerY);\n\n        if (clockwise) {\n            polyline[k++] = outerPos;\n            polyline[k++] = innerPos;\n        } else {\n            polyline[k++] = innerPos;\n            polyline[k++] = outerPos;\n        }\n    }\n\n    return polyline;\n}"],
  "mappings": "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",
  "names": ["JobFailReason", "JobError", "failReason", "originalError", "failMessage", "THIRD", "TAU", "HALF_PI", "mat3", "vec3", "_wV1", "_wV2", "_wV3", "_wP", "_wP_EPS_ARR", "_matrix3", "wNPI", "returnXYZ", "arr", "index", "calcWindingNumber_buffer", "trianglesArr", "point", "wN", "trianglesArrLen", "i", "lenA", "lenB", "lenC", "polyInside_WindingNumber_buffer", "coplanar", "_wP_EPS", "prepareTriangleBuffer", "polygons", "array", "bufferIndex", "polygon", "triangle", "prepareNormalBuffer", "polygons", "array", "bufferIndex", "polygon", "encodeOctree", "obj", "transferables", "vertexBuffer", "prepareTriangleBuffer", "normalBuffer", "vec2", "vec3", "_v1", "_v2", "_v3", "triangleIntersectsTriangle", "triangleA", "triangleB", "additionsIn", "additions", "p1", "q1", "r1", "p2", "q2", "r2", "N2", "dp1", "dq1", "dr1", "N1", "dp2", "dq2", "dr2", "tri_tri_intersection", "coplanar_tri_tri3d", "construct_intersection", "normal_1", "P1", "Q1", "R1", "P2", "Q2", "R2", "n_x", "n_y", "n_z", "tri_tri_overlap_test_2d", "ORIENT_2D", "ccw_tri_tri_intersection_2d", "a", "b", "c", "intersection_test_edge", "intersection_test_vertex", "alpha", "N", "lineIntersects", "line1", "line2", "points", "r", "s", "q", "dotqr", "dotqs", "dotrs", "dotrr", "dotss", "denom", "t", "u", "p0", "onSegment", "intersects", "getLines", "triangle", "checkTrianglesIntersection", "triangle1", "triangle2", "triangleIntersects", "triangle1Lines", "triangle2Lines", "i", "j", "vec3", "Triangle", "a", "b", "c", "source", "destination", "THIRD", "other", "k", "data", "seed", "h", "view", "key", "mat3", "mat4", "quat", "vec2", "vec3", "tv0", "tv1", "tv2", "tmpm3", "tmpm4_0", "tmpm4_1", "tv0_2", "tv1_2", "tq0", "vec3", "vec4", "Plane", "buffer", "normal", "w", "p", "a", "b", "c", "tv0", "tv1", "n", "mat3", "vec3", "_polygonID", "Polygon", "vertices", "shared", "_polygonID", "v", "Plane", "Triangle", "matrix", "normalMatrixIn", "normalMatrix", "mat3", "tmpm3", "vec3", "resetOriginal", "state", "keepState", "previousState", "polygon", "tmp", "vec3", "ReturnPolygonType", "COPLANAR", "FRONT", "BACK", "SPANNING", "splitPolygonByPlane", "polygon", "plane", "result", "returnPolygon", "polygonType", "types", "vertex", "t", "type", "f", "b", "vertCount", "i", "j", "ti", "tj", "vi", "vj", "tv0", "v", "newPoly", "splitPolygonArr", "Polygon", "arr", "resultArr", "vec3", "edge1", "edge2", "h", "s", "q", "RAY_EPSILON", "rayIntersectsTriangle", "ray", "triangle", "target", "a", "f", "u", "v", "t", "pointRounding", "point", "num", "vec3", "_tv1", "_tv2", "_tv3", "_bxNorm", "_byNorm", "_bzNorm", "_lub", "_rub", "_luf", "_ruf", "_ldb", "_rdb", "_ldf", "_rdf", "_ba", "_cb", "_ac", "Box3", "min", "max", "point", "scalar", "points", "normal", "count", "i", "dotProd", "boxAxisMin", "boxAxisMax", "vertices", "triEdge", "boxNormal", "triVerts", "boxVerts", "axis", "boxMin", "boxMax", "triMin", "triMax", "triangle", "triNorm", "Plane", "triOffset", "box", "ray", "tmax", "vec3", "Ray", "TriangleHasher", "triangle", "hash", "arr", "other", "CSG_Rules", "mat3", "vec3", "_v1", "vec3", "_v2", "_v3", "_ray", "Ray", "_rayDirection", "_a", "_OctreeCSG", "box", "parent", "source", "p", "subTree", "array", "index", "polygon", "triangleHasher", "triangle", "Box3", "level", "subTrees", "halfsize", "x", "y", "z", "v", "found", "subBox", "firstVertex", "targetPolygon", "polygons", "handlePolygonArrayIntersections", "ray", "replacedPolygon", "intersects", "distance", "result", "rayIntersectsTriangle", "newdistance", "raycastIntersectAscSort", "polygonsArray", "newPolygons", "polygonIndex", "rulesArr", "firstRun", "rule", "states", "missingStates", "state", "previousState", "targetOctree", "resetOriginal", "targetOctreeBuffer", "polygonStack", "currentPolygon", "targetPolygons", "target", "splitResults", "splitPolygonByPlane", "singleResult", "ReturnPolygonType", "inside", "polyInside_WindingNumber_buffer", "point", "pointRounding", "_wP_EPS", "_wP_EPS_ARR", "deletePolygons", "cbFunc", "matrix", "normalMatrix", "mat3", "tmpm3", "triangles", "octreeA", "octreeB", "buildTargetOctree", "octree", "TriangleHasher", "CSG_Rules", "objArr", "materialIndexMax", "arrayOperation", "objArrCount", "obj", "resultOctree", "handleObjectForOp", "disposeOctree", "octrees", "octreeObj", "bothOctrees", "octreeA_buffer", "octreeB_buffer", "prepareTriangleBuffer", "OctreeCSG", "__async", "asyncOperation", "asyncArrayOperation", "resolve", "reject", "promises", "handleObjectForOp_async", "results", "csg", "objIndex", "resultPromise", "e", "promise", "a", "b", "returnObj", "outputPolygons", "checkTrianglesIntersection", "callback", "octreesArray", "objArrLen", "i", "tempOctree", "octreeCount", "nextOctreeArray", "op", "syncCallback", "error", "rethrow", "JobError", "singleCallback", "arrayCallback", "usingBatches", "mainOctree", "mainOctreeUsed", "batches", "currentIndex", "batch", "leftOverOctree", "octreesArrayLen", "innerResult", "vec3", "Vertex", "pos", "normal", "other", "t", "decodeOctree", "vertexBuffer", "normalBuffer", "bufferLen", "octree", "OctreeCSG", "i", "a", "Vertex", "b", "c", "newPolygon", "Polygon", "encodeOctreeCSGObject", "obj", "transferables", "encodeOctreeCSGObjectOrCSG", "encodedObjs", "octreeObj", "OctreeCSG", "encodeOctree", "Job", "operation", "resolveCallback", "rejectCallback", "workerIndex", "jobIndex", "vertexBuffer", "normalBuffer", "decodeOctree", "e", "JobError", "error", "JOB_REG_MSG", "WARN_START", "OctreeCSGJobDispatcher", "workers", "workerPath", "timeoutMS", "resolve", "reject", "timeout", "worker", "message", "workerIndex", "workerCount", "workersDone", "i", "reason", "actualWorkerCount", "dispatcher", "event", "jobIndex", "job", "JobError", "minWorkerIndex", "minJobCount", "jobCount", "operation", "Job", "__async", "jobDispatcher", "e", "vec3", "mat4", "CSGPrimitive", "OctreeCSG", "box", "triangleVertices", "options", "vertexCount", "i", "polygon", "Polygon", "matrix", "mat4", "tmpMat", "addSquare", "vertices", "index", "a", "b", "c", "d", "normal", "Vertex", "vec3", "Cuboid", "CSGPrimitive", "xLength", "yLength", "zLength", "options", "max", "min", "luf", "ruf", "lub", "rub", "ldf", "rdf", "ldb", "rdb", "Box3", "Cube", "Cuboid", "length", "options", "vec3", "spherifyFace", "spherifyPoint", "index", "subDivs", "radius", "vertices", "origin", "right", "up", "i", "ip", "inp", "j", "jp", "jnp", "a", "aNorm", "b", "bNorm", "c", "cNorm", "d", "dNorm", "Vertex", "vec3", "CubeSphere", "CSGPrimitive", "diameter", "options", "_a", "vertexCount", "max", "min", "Box3", "vec3", "spherifyPoint", "ip", "jp", "radius", "origin", "right", "up", "vec3", "tv0", "tv1", "normal", "THIRD", "Sphere", "CubeSphere", "diameter", "options", "vec3", "spherifyPoint", "ip", "jp", "radius", "origin", "right", "up", "vec3", "tv0", "normal", "UVSphere", "CubeSphere", "diameter", "options", "vec3", "vec3", "vec3", "triangulateConvexPolygon", "vertices", "flip", "output", "startIndex", "vertexCount", "indices", "_", "aIdx", "bIdx", "a", "b", "i", "idxLow", "idxMid", "idxHigh", "makeCircularBase", "vertices", "xzn", "y", "normal", "index", "flip", "segments", "polyline", "i", "Vertex", "vec3", "triangulateConvexPolygon", "precalcCircularBase", "subDivs", "radius", "generateNormals", "angle", "TAU", "dx", "dz", "Cylinder", "CSGPrimitive", "diameter", "length", "options", "_a", "subDivs", "vertexCount", "vertices", "radius", "halfLength", "xzn", "precalcCircularBase", "index", "makeCircularBase", "vec3", "i", "x1", "z1", "normal1", "x2", "z2", "normal2", "Vertex", "max", "min", "Box3", "vec3", "BaseCone", "CSGPrimitive", "baseVertices", "smoothNormals", "diameter", "length", "options", "vertexCount", "vertices", "radius", "halfLength", "tip", "vec3", "xzn", "precalcCircularBase", "angle", "xNormMul", "yNormVal", "i", "normal", "index", "makeCircularBase", "xzn1", "xzn2", "x1", "z1", "x2", "z2", "a", "b", "c", "an", "bn", "cn", "Plane", "Vertex", "max", "min", "Box3", "Cone", "BaseCone", "diameter", "length", "options", "_a", "Pyramid", "BaseCone", "sides", "diameter", "length", "options", "vec3", "vec3", "ICO_V", "makeIcosahedronTriangles", "addTriangle", "vertices", "radius", "index", "addTriangle", "vertices", "index", "radius", "a", "b", "c", "normal", "Plane", "Vertex", "vec3", "Icosahedron", "CSGPrimitive", "diameter", "options", "max", "min", "makeIcosahedronTriangles", "Box3", "vec3", "addTriangle", "depth", "vertices", "index", "radius", "a", "b", "c", "Vertex", "vec3", "abm", "bcm", "cam", "nextDepth", "Icosphere", "CSGPrimitive", "diameter", "options", "_a", "max", "min", "subDivs", "__pow", "makeIcosahedronTriangles", "Box3", "mat4", "quat", "vec3", "Torus", "CSGPrimitive", "outerDiameter", "innerDiameter", "options", "_a", "_b", "radSubDivs", "tubSubDivs", "outerRadius", "innerRadius", "tubeRadius", "max", "vec3", "min", "tubularSegments", "i", "radialSegments", "tubeRot", "quat", "tv0", "mat4", "tmpm4_0", "tmpm4_1", "j", "angle", "TAU", "x", "y", "pos", "normal", "vertices", "index", "segment1", "segment2", "jNext", "pos11", "normal11", "pos21", "normal21", "pos12", "normal12", "pos22", "normal22", "Vertex", "Box3", "vec3", "vec2", "isClockwise2DPolygon", "polyline", "sum", "vertCount", "last", "next", "vec2", "isClockwise2DTriangle", "a", "b", "c", "sort2DIndices", "polyline", "indices", "_", "i", "aIdx", "bIdx", "a", "b", "addTriangle", "output", "index", "clockwise", "a", "b", "c", "isClockwise2DTriangle", "triangulateMonotone2DPolygon", "polyline", "isClockwiseHint", "vertexCount", "outputSize", "vec2", "isClockwise2DPolygon", "indices", "sort2DIndices", "stack", "i", "thisIndex", "thisVertex", "stackLen", "topIndex", "topVertex", "j", "lastPoppedVertex", "lastPoppedIndex", "nextPoppedIndex", "nextPoppedVertex", "beforePoppedIndex", "beforePoppedVertex", "dir", "tv0_2", "insideDir", "curDir", "tv1_2", "lastVertex", "iterLen", "getPolygonInLoop", "indices", "start", "end", "indexCount", "output", "i", "actualIndex", "splitPolygonTo", "polyline", "diagonals", "flip", "aIndices", "bIndices", "aDiags", "bDiags", "diagonalCount", "oStart", "oEnd", "outPolyline", "split2DPolygon", "_", "isAbove", "p", "q", "interiorAngle", "prev", "cur", "next", "prevAngle", "TAU", "getLeftEdge", "polyline", "status", "vertexCount", "vertex", "leftEdge", "leftY", "lineStartIndex", "lineEndIndex", "lineStart", "lineEnd", "lineMin", "lineMax", "m", "c", "partition2DPolygon", "output", "isClockwiseHint", "isClockwise2DPolygon", "helpers", "types", "diagonals", "index", "sort2DIndices", "prevIndex", "nextIndex", "prevVertex", "nextVertex", "abovePrev", "aboveNext", "prevHelper", "leftHelper", "split2DPolygon", "linearExtrude", "polyline", "depth", "includeBases", "isClockwise", "isClockwise2DPolygon", "polylineLength", "octree", "OctreeCSG", "i", "j", "xyi", "xyj", "fi", "vec3", "vec2", "bi", "fj", "bj", "normal", "Plane", "polygonA", "Polygon", "Vertex", "polygonB", "isClockwiseHint", "partitions", "partition2DPolygon", "partition", "triangulated", "_endIndex", "triangulateMonotone2DPolygon", "triVertCount", "normal1", "normal2", "a_2d", "a1", "a2", "b_2d", "b1", "b2", "c_2d", "c1", "c2", "triangulate2DPolygon", "polyline", "output", "isClockwiseHint", "isClockwise2DPolygon", "partitions", "partition2DPolygon", "outputSize", "partition", "index", "triangulateMonotone2DPolygon", "mat3", "mat4", "vec2", "vec3", "makeSlice", "output", "outputMat", "polyline", "position", "r", "s", "t", "mat4", "sliceVerts", "i", "outputVec", "vec2", "vec3", "makeBase", "octree", "triangulatedBase", "mat", "baseTriVerts", "flip", "b", "normal", "Plane", "aVert", "Vertex", "bVert", "cVert", "polygon", "Polygon", "curveExtrude", "positions", "frames", "options", "_a", "_b", "pointCount", "OctreeCSG", "sliceVertices", "lastSlice", "curSlice", "lastMat", "lastMatNormal", "mat3", "curMat", "curMatNormal", "edgeNormals", "tv0", "j", "iXY", "jXY", "smoothNormals", "vertexNormals", "includeBases", "triangulate2DPolygon", "lastSegment", "k", "lastNormalA", "lastNormalB", "curNormalA", "curNormalB", "jNorm", "kNorm", "norm", "lastA", "lastB", "curA", "curB", "polygonA", "polygonB", "quat", "vec3", "rotationMinimizingCurveExtrude", "polyline", "positions", "tangents", "startNormal", "options", "_a", "pointCount", "frames", "startTangent", "startBinormal", "vec3", "i", "v_1", "tv0", "c_1", "r_i", "t_i", "temp", "r_L_i", "tv1", "t_L_i", "tv2", "t_i1", "v_2", "c_2", "r_i1", "s_i1", "endNormal", "twists", "angleErr", "endTangent", "endBinormal", "actualNormal", "dx", "dy", "HALF_PI", "TAU", "totalLength", "lastPos", "curPos", "interpLength", "r", "s", "_t", "thisAngleErr", "quat", "tq0", "curveExtrude", "vec2", "makeRegularPolyline", "radius", "sides", "clockwise", "polyline", "sidesM1", "i", "j", "angle", "TAU", "y", "x", "vec2", "makeCirclePolyline", "radius", "clockwise", "subDivisions", "makeRegularPolyline", "vec2", "makeCubePolyline", "length", "clockwise", "half", "vec2", "makeRectanglePolyline", "width", "height", "clockwise", "halfWidth", "halfHeight", "vec2", "makeStarPolyline", "outerRadius", "innerRadius", "sides", "clockwise", "polyline", "sidesM1", "halfAngle", "TAU", "k", "i", "j", "outerAngle", "outerY", "outerX", "outerPos", "vec2", "innerAngle", "innerY", "innerX", "innerPos"]
}
