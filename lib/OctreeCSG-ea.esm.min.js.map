{
  "version": 3,
  "sources": ["../src/worker/JobError.ts", "../src/math/const-numbers.ts", "../src/math/winding-number.ts", "../src/math/three-triangle-intersection.ts", "../src/math/Triangle.ts", "../src/math/temp.ts", "../src/math/Plane.ts", "../src/math/Polygon.ts", "../src/base/MaterialDefinition.ts", "../src/math/split-polygon.ts", "../src/math/ray-intersects-triangle.ts", "../src/math/Box3.ts", "../src/math/Ray.ts", "../src/base/OctreeCSG.ts", "../src/worker/get-vertex-property-type-size.ts", "../src/worker/encode-point.ts", "../src/base/TriangleHasher.ts", "../src/base/CSGRule.ts", "../src/worker/count-extra-vertex-bytes.ts", "../src/math/Vertex.ts", "../src/math/lerp.ts", "../src/worker/decode-point.ts", "../src/base/merge-materials.ts", "../src/worker/Job.ts", "../src/worker/OctreeCSGJobDispatcher.ts", "../src/primitives/Cuboid.ts", "../src/primitives/CSGPrimitive.ts", "../src/primitives/CSGPrimitiveMaterialAttributes.ts", "../src/primitives/Cube.ts", "../src/primitives/CubeSphere.ts", "../src/primitives/Sphere.ts", "../src/primitives/UVSphere.ts", "../src/primitives/Cylinder.ts", "../src/primitives/make-circular-base.ts", "../src/helpers/triangulate-convex-polygon.ts", "../src/primitives/BaseCone.ts", "../src/primitives/Cone.ts", "../src/primitives/Pyramid.ts", "../src/primitives/Icosahedron.ts", "../src/primitives/icosahedron-make-triangles.ts", "../src/primitives/Icosphere.ts", "../src/primitives/Torus.ts", "../src/helpers/curve-extrusion-helper.ts", "../src/helpers/is-clockwise-2d-polygon.ts", "../src/helpers/sort-2d-indices.ts", "../src/helpers/split-2d-polygon.ts", "../src/helpers/partition-2d-polygon.ts", "../src/helpers/triangulate-monotone-2d-polygon.ts", "../src/helpers/is-clockwise-2d-triangle.ts", "../src/helpers/triangulate-2d-polygon.ts", "../src/helpers/linear-extrusion-helper.ts", "../src/helpers/make-rotation-minimizing-frames.ts", "../src/helpers/rmf-extrusion-helper.ts", "../src/polylines/regular-polyline.ts", "../src/polylines/circle-polyline.ts", "../src/polylines/cube-polyline.ts", "../src/polylines/rectangle-polyline.ts", "../src/polylines/star-polyline.ts", "../src/projectors/Projector.ts", "../src/projectors/DirectionalProjector.ts", "../src/projectors/FlatProjector.ts", "../src/projectors/TubeProjector.ts", "../src/projectors/SphereProjector.ts", "../src/projectors/CurveTubeProjector.ts"],
  "sourcesContent": ["export enum JobFailReason {\n    WorkerCreationFailure,\n    OperationFailure,\n    DecodeFailure,\n}\n\nexport class JobError extends Error {\n    constructor(public failReason: JobFailReason, public originalError: string) {\n        let failMessage: string;\n\n        switch(failReason) {\n            case JobFailReason.WorkerCreationFailure:\n                failMessage = 'Job failed (worker creation failed)';\n                break;\n            case JobFailReason.OperationFailure:\n                failMessage = 'Job failed (operation exception)';\n                break;\n            default:\n                failMessage = 'Job failed (decode failure)';\n        }\n\n        super(`${failMessage}: ${originalError}`);\n    }\n\n    static WorkerCreationFailure(originalError: unknown) {\n        return new JobError(JobFailReason.WorkerCreationFailure, '' + originalError);\n    }\n\n    static OperationFailure(originalError: unknown) {\n        return new JobError(JobFailReason.OperationFailure, '' + originalError);\n    }\n\n    static DecodeFailure(originalError: unknown) {\n        return new JobError(JobFailReason.DecodeFailure, '' + originalError);\n    }\n}", "export const EPSILON = 1e-5;\nexport const INV_EPSILON = 1e5;\nexport const THIRD = 1 / 3;\nexport const TAU = Math.PI * 2;\nexport const HALF_PI = Math.PI / 2;", "import { EPSILON } from './const-numbers';\n\nimport type { Polygon } from './Polygon';\n\nimport { mat3, vec3 } from 'gl-matrix';\n\n// Winding Number algorithm adapted from https://github.com/grame-cncm/faust/blob/master-dev/tools/physicalModeling/mesh2faust/vega/libraries/windingNumber/windingNumber.cpp\nconst _wV1 = vec3.create();\nconst _wV2 = vec3.create();\nconst _wV3 = vec3.create();\nconst _wP = vec3.create();\nexport const _wP_EPS_ARR = [\n    vec3.fromValues(EPSILON, 0, 0),\n    vec3.fromValues(0, EPSILON, 0),\n    vec3.fromValues(0, 0, EPSILON),\n    vec3.fromValues(-EPSILON, 0, 0),\n    vec3.fromValues(0, -EPSILON, 0),\n    vec3.fromValues(0, 0, -EPSILON)\n];\n\nconst _matrix3 = mat3.create();\nconst wNPI = 4 * Math.PI;\n\nfunction returnXYZ(arr: Float32Array, index: number): vec3 {\n    return arr.slice(index, index + 3);\n}\n\nfunction calcWindingNumber_buffer(trianglesArr: Float32Array, point: vec3) {\n    let wN = 0;\n\n    const trianglesArrLen = trianglesArr.length;\n    for (let i = 0; i < trianglesArrLen; i += 9) {\n        vec3.sub(_wV1, returnXYZ(trianglesArr, i), point);\n        vec3.sub(_wV2, returnXYZ(trianglesArr, i + 3), point);\n        vec3.sub(_wV3, returnXYZ(trianglesArr, i + 6), point);\n\n        const lenA = vec3.length(_wV1);\n        const lenB = vec3.length(_wV2);\n        const lenC = vec3.length(_wV3);\n\n        mat3.set(\n            _matrix3,\n            _wV1[0], _wV2[0], _wV3[0],\n            _wV1[1], _wV2[1], _wV3[1],\n            _wV1[2], _wV2[2], _wV3[2]\n        );\n\n        wN += 2 * Math.atan2(\n            mat3.determinant(_matrix3),\n            lenA * lenB * lenC\n                + vec3.dot(_wV1, _wV2) * lenC\n                + vec3.dot(_wV2, _wV3) * lenA\n                + vec3.dot(_wV1, _wV3) * lenB\n        );\n    }\n\n    return Math.round(wN / wNPI);\n}\n\nexport function polyInside_WindingNumber_buffer(trianglesArr: Float32Array, point: Readonly<vec3>, coplanar: boolean) {\n    vec3.copy(_wP, point);\n\n    if (calcWindingNumber_buffer(trianglesArr, _wP) !== 0) {\n        return true;\n    } else if (coplanar) {\n        for (const _wP_EPS of _wP_EPS_ARR) {\n            vec3.add(_wP, point, _wP_EPS);\n            if (calcWindingNumber_buffer(trianglesArr, _wP) !== 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nexport function prepareTriangleBuffer(polygons: Polygon[]) {\n    const array = new Float32Array(polygons.length * 3 * 3);\n\n    let bufferIndex = 0;\n    for (const polygon of polygons) {\n        const triangle = polygon.triangle;\n        array.set(triangle.a, bufferIndex);\n        bufferIndex += 3;\n        array.set(triangle.b, bufferIndex);\n        bufferIndex += 3;\n        array.set(triangle.c, bufferIndex);\n        bufferIndex += 3;\n    }\n\n    return array;\n}", "import type Triangle from './Triangle';\nimport type Line from './Line';\n\nimport { vec2, vec3 } from 'gl-matrix';\n\ninterface Additions {\n    coplanar: boolean,\n    source: vec3,\n    target: vec3,\n}\n\ninterface AdditionsN extends Additions {\n    N1: vec3,\n    N2: vec3,\n}\n\nconst _v1 = vec3.create();\nconst _v2 = vec3.create();\nconst _v3 = vec3.create();\n\n// https://github.com/benardp/contours/blob/master/freestyle/view_map/triangle_triangle_intersection.c\nfunction triangleIntersectsTriangle(triangleA: Triangle, triangleB: Triangle, additionsIn: Additions = { coplanar: false, source: vec3.create(), target: vec3.create() }) {\n    const additions = additionsIn as AdditionsN;\n\n    const p1 = triangleA.a;\n    const q1 = triangleA.b;\n    const r1 = triangleA.c;\n\n    const p2 = triangleB.a;\n    const q2 = triangleB.b;\n    const r2 = triangleB.c;\n\n    // Compute distance signs  of p1, q1 and r1\n    // to the plane of triangleB (p2,q2,r2)\n    vec3.sub(_v1, p2, r2);\n    vec3.sub(_v2, q2, r2);\n    const N2 = vec3.cross(vec3.create(), _v1, _v2);\n\n    vec3.sub(_v1, p1, r2);\n    const dp1 = vec3.dot(_v1, N2);\n    vec3.sub(_v1, q1, r2);\n    const dq1 = vec3.dot(_v1, N2);\n    vec3.sub(_v1, r1, r2);\n    const dr1 = vec3.dot(_v1, N2);\n\n    if (dp1 * dq1 > 0 && dp1 * dr1 > 0) {\n        return false;\n    }\n\n    // Compute distance signs  of p2, q2 and r2\n    // to the plane of triangleA (p1,q1,r1)\n    vec3.sub(_v1, q1, p1);\n    vec3.sub(_v2, r1, p1);\n    const N1 = vec3.cross(vec3.create(), _v1, _v2);\n\n    vec3.sub(_v1, p2, r1);\n    const dp2 = vec3.dot(_v1, N1);\n    vec3.sub(_v1, q2, r1);\n    const dq2 = vec3.dot(_v1, N1);\n    vec3.sub(_v1, r2, r1);\n    const dr2 = vec3.dot(_v1, N1);\n\n    if (dp2 * dq2 > 0 && dp2 * dr2 > 0) {\n        return false;\n    }\n\n    additions.N2 = N2;\n    additions.N1 = N1;\n\n    if (dp1 > 0) {\n        if (dq1 > 0) {\n            return tri_tri_intersection(r1, p1, q1, p2, r2, q2, dp2, dr2, dq2, additions);\n        } else if (dr1 > 0) {\n            return tri_tri_intersection(q1, r1, p1, p2, r2, q2, dp2, dr2, dq2, additions);\n        } else {\n            return tri_tri_intersection(p1, q1, r1, p2, q2, r2, dp2, dq2, dr2, additions);\n        }\n    } else if (dp1 < 0) {\n        if (dq1 < 0) {\n            return tri_tri_intersection(r1, p1, q1, p2, q2, r2, dp2, dq2, dr2, additions);\n        } else if (dr1 < 0) {\n            return tri_tri_intersection(q1, r1, p1, p2, q2, r2, dp2, dq2, dr2, additions);\n        } else {\n            return tri_tri_intersection(p1, q1, r1, p2, r2, q2, dp2, dr2, dq2, additions);\n        }\n    } else if (dq1 < 0) {\n        if (dr1 >= 0) {\n            return tri_tri_intersection(q1, r1, p1, p2, r2, q2, dp2, dr2, dq2, additions);\n        } else {\n            return tri_tri_intersection(p1, q1, r1, p2, q2, r2, dp2, dq2, dr2, additions);\n        }\n    } else if (dq1 > 0) {\n        if (dr1 > 0) {\n            return tri_tri_intersection(p1, q1, r1, p2, r2, q2, dp2, dr2, dq2, additions);\n        } else {\n            return tri_tri_intersection(q1, r1, p1, p2, q2, r2, dp2, dq2, dr2, additions);\n        }\n    } else if (dr1 > 0) {\n        return tri_tri_intersection(r1, p1, q1, p2, q2, r2, dp2, dq2, dr2, additions);\n    } else if (dr1 < 0) {\n        return tri_tri_intersection(r1, p1, q1, p2, r2, q2, dp2, dr2, dq2, additions);\n    } else {\n        // triangles are co-planar\n        additions.coplanar = true;\n        return coplanar_tri_tri3d(p1, q1, r1, p2, q2, r2, N1);\n    }\n}\n\nfunction tri_tri_intersection(p1: Readonly<vec3>, q1: Readonly<vec3>, r1: Readonly<vec3>, p2: Readonly<vec3>, q2: Readonly<vec3>, r2: Readonly<vec3>, dp2: number, dq2: number, dr2: number, additions: AdditionsN) {\n    if (dp2 > 0) {\n        if (dq2 > 0) {\n            return construct_intersection(p1, r1, q1, r2, p2, q2, additions);\n        } else if (dr2 > 0) {\n            return construct_intersection(p1, r1, q1, q2, r2, p2, additions);\n        } else {\n            return construct_intersection(p1, q1, r1, p2, q2, r2, additions);\n        }\n    } else if (dp2 < 0) {\n        if (dq2 < 0) {\n            return construct_intersection(p1, q1, r1, r2, p2, q2, additions);\n        } else if (dr2 < 0) {\n            return construct_intersection(p1, q1, r1, q2, r2, p2, additions);\n        } else {\n            return construct_intersection(p1, r1, q1, p2, q2, r2, additions);\n        }\n    } else if (dq2 < 0) {\n        if (dr2 >= 0) {\n            return construct_intersection(p1, r1, q1, q2, r2, p2, additions);\n        } else {\n            return construct_intersection(p1, q1, r1, p2, q2, r2, additions);\n        }\n    } else if (dq2 > 0) {\n        if (dr2 > 0) {\n            return construct_intersection(p1, r1, q1, p2, q2, r2, additions);\n        } else {\n            return construct_intersection(p1, q1, r1, q2, r2, p2, additions);\n        }\n    } else if (dr2 > 0) {\n        return construct_intersection(p1, q1, r1, r2, p2, q2, additions);\n    } else if (dr2 < 0) {\n        return construct_intersection(p1, r1, q1, r2, p2, q2, additions);\n    } else {\n        additions.coplanar = true;\n        return coplanar_tri_tri3d(p1, q1, r1, p2, q2, r2, additions.N1);\n    }\n}\n\nfunction coplanar_tri_tri3d(p1: Readonly<vec3>, q1: Readonly<vec3>, r1: Readonly<vec3>, p2: Readonly<vec3>, q2: Readonly<vec3>, r2: Readonly<vec3>, normal_1: vec3) {\n    const P1 = vec2.create(), Q1 = vec2.create(), R1 = vec2.create(),\n          P2 = vec2.create(), Q2 = vec2.create(), R2 = vec2.create();\n\n    const n_x = normal_1[0] < 0 ? -normal_1[0] : normal_1[0];\n    const n_y = normal_1[1] < 0 ? -normal_1[1] : normal_1[1];\n    const n_z = normal_1[2] < 0 ? -normal_1[2] : normal_1[2];\n\n    /* Projection of the triangles in 3D onto 2D such that the area of\n    the projection is maximized. */\n\n    if (n_x > n_z && n_x >= n_y) { // Project onto plane YZ\n        P1[0] = q1[2], P1[1] = q1[1];\n        Q1[0] = p1[2], Q1[1] = p1[1];\n        R1[0] = r1[2], R1[1] = r1[1];\n\n        P2[0] = q2[2], P2[1] = q2[1];\n        Q2[0] = p2[2], Q2[1] = p2[1];\n        R2[0] = r2[2], R2[1] = r2[1];\n    } else if (n_y > n_z && n_y >= n_x) { // Project onto plane XZ\n        P1[0] = q1[0], P1[1] = q1[2];\n        Q1[0] = p1[0], Q1[1] = p1[2];\n        R1[0] = r1[0], R1[1] = r1[2];\n\n        P2[0] = q2[0], P2[1] = q2[2];\n        Q2[0] = p2[0], Q2[1] = p2[2];\n        R2[0] = r2[0], R2[1] = r2[2];\n    } else { // Project onto plane XY\n        P1[0] = p1[0], P1[1] = p1[1];\n        Q1[0] = q1[0], Q1[1] = q1[1];\n        R1[0] = r1[0], R1[1] = r1[1];\n\n        P2[0] = p2[0], P2[1] = p2[1];\n        Q2[0] = q2[0], Q2[1] = q2[1];\n        R2[0] = r2[0], R2[1] = r2[1];\n    }\n\n    return tri_tri_overlap_test_2d(P1, Q1, R1, P2, Q2, R2);\n}\n\nfunction tri_tri_overlap_test_2d(p1: vec2, q1: vec2, r1: vec2, p2: vec2, q2: vec2, r2: vec2) {\n    if (ORIENT_2D(p1, q1, r1) < 0) {\n        if (ORIENT_2D(p2, q2, r2) < 0) {\n            return ccw_tri_tri_intersection_2d(p1, r1, q1, p2, r2, q2);\n        } else {\n            return ccw_tri_tri_intersection_2d(p1, r1, q1, p2, q2, r2);\n        }\n    } else if (ORIENT_2D(p2, q2, r2) < 0) {\n        return ccw_tri_tri_intersection_2d(p1, q1, r1, p2, r2, q2);\n    } else {\n        return ccw_tri_tri_intersection_2d(p1, q1, r1, p2, q2, r2);\n    }\n}\n\nfunction ORIENT_2D(a: vec2, b: vec2, c: vec2) {\n    return ((a[0] - c[0]) * (b[1] - c[1]) - (a[1] - c[1]) * (b[0] - c[1]));\n}\n\nfunction ccw_tri_tri_intersection_2d(p1: vec2, q1: vec2, r1: vec2, p2: vec2, q2: vec2, r2: vec2) {\n    if (ORIENT_2D(p2, q2, p1) >= 0) {\n        if (ORIENT_2D(q2, r2, p1) >= 0) {\n            if (ORIENT_2D(r2, p2, p1) >= 0) {\n                return true;\n            } else {\n                return intersection_test_edge(p1, q1, r1, p2, r2);\n            }\n        } else if (ORIENT_2D(r2, p2, p1) >= 0) {\n            return intersection_test_edge(p1, q1, r1, r2, q2);\n        } else {\n            return intersection_test_vertex(p1, q1, r1, p2, q2, r2)\n        }\n    } else if (ORIENT_2D(q2, r2, p1) >= 0) {\n        if (ORIENT_2D(r2, p2, p1) >= 0) {\n            return intersection_test_edge(p1, q1, r2, q2, p2);\n        } else {\n            return intersection_test_vertex(p1, q1, r1, q2, r2, p2);\n        }\n    } else {\n        return intersection_test_vertex(p1, q1, r1, r2, p2, q2);\n    }\n}\n\nfunction intersection_test_edge(P1: vec2, Q1: vec2, R1: vec2, P2: vec2, R2: vec2) {\n    if (ORIENT_2D(R2, P2, Q1) >= 0) {\n        if (ORIENT_2D(P1, P2, Q1) >= 0) {\n            return ORIENT_2D(P1, Q1, R2) >= 0;\n        } else if (ORIENT_2D(Q1, R1, P2) >= 0) {\n            return ORIENT_2D(R1, P1, P2) >= 0;\n        }\n    } else if (ORIENT_2D(R2, P2, R1) >= 0 && ORIENT_2D(P1, P2, R1) >= 0) {\n        return ORIENT_2D(P1, R1, R2) >= 0 || ORIENT_2D(Q1, R1, R2) >= 0;\n    }\n\n    return false;\n}\n\nfunction intersection_test_vertex(P1: vec2, Q1: vec2, R1: vec2, P2: vec2, Q2: vec2, R2: vec2) {\n    if (ORIENT_2D(R2, P2, Q1) >= 0) {\n        if (ORIENT_2D(R2, Q2, Q1) <= 0) {\n            if (ORIENT_2D(P1, P2, Q1) > 0) {\n                return ORIENT_2D(P1, Q2, Q1) <= 0;\n            } else if (ORIENT_2D(P1, P2, R1) >= 0) {\n                return ORIENT_2D(Q1, R1, P2) >= 0;\n            }\n        } else if (ORIENT_2D(P1, Q2, Q1) <= 0 && ORIENT_2D(R2, Q2, R1) <= 0) {\n            return ORIENT_2D(Q1, R1, Q2) >= 0;\n        }\n    } else if (ORIENT_2D(R2, P2, R1) >= 0) {\n        if (ORIENT_2D(Q1, R1, R2) >= 0) {\n            return ORIENT_2D(P1, P2, R1) >= 0;\n        } else if (ORIENT_2D(Q1, R1, Q2) >= 0) {\n            return ORIENT_2D(R2, R1, Q2) >= 0;\n        }\n    }\n\n    return false;\n}\n\nfunction construct_intersection(p1: Readonly<vec3>, q1: Readonly<vec3>, r1: Readonly<vec3>, p2: Readonly<vec3>, q2: Readonly<vec3>, r2: Readonly<vec3>, additions: AdditionsN) {\n    let alpha: number;\n    vec3.sub(_v1, q1, p1);\n    vec3.sub(_v2, r2, p1);\n    const N = vec3.cross(vec3.create(), _v1, _v2);\n    vec3.sub(_v3, p2, p1);\n\n    if (vec3.dot(_v3, N) > 0) {\n        vec3.sub(_v1, r1, p1);\n        vec3.cross(N, _v1, _v2);\n\n        if (vec3.dot(_v3, N) <= 0) {\n            vec3.sub(_v2, q2, p1);\n            vec3.cross(N, _v1, _v2);\n\n            if (vec3.dot(_v3, N) > 0) {\n                vec3.sub(_v1, p1, p2);\n                vec3.sub(_v2, p1, r1);\n                alpha = vec3.dot(_v1, additions.N2) / vec3.dot(_v2, additions.N2);\n                vec3.scale(_v1, _v2, alpha);\n                vec3.sub(additions.source, p1, _v1);\n                vec3.sub(_v1, p2, p1);\n                vec3.sub(_v2, p2, r2);\n                alpha = vec3.dot(_v1, additions.N1) / vec3.dot(_v2, additions.N1);\n                vec3.scale(_v1, _v2, alpha);\n                vec3.sub(additions.target, p2, _v1);\n            }\n            else {\n                vec3.sub(_v1, p2, p1);\n                vec3.sub(_v2, p2, q2);\n                alpha = vec3.dot(_v1, additions.N1) / vec3.dot(_v2, additions.N1);\n                vec3.scale(_v1, _v2, alpha);\n                vec3.sub(additions.source, p2, _v1);\n                vec3.sub(_v1, p2, p1);\n                vec3.sub(_v2, p2, r2);\n                alpha = vec3.dot(_v1, additions.N1) / vec3.dot(_v2, additions.N1);\n                vec3.scale(_v1, _v2, alpha);\n                vec3.sub(additions.target, p2, _v1);\n            }\n\n            return true;\n        }\n    }\n    else {\n        vec3.sub(_v2, q2, p1);\n        vec3.cross(N, _v1, _v2);\n\n        if (vec3.dot(_v3, N) >= 0) {\n            vec3.sub(_v1, r1, p1);\n            vec3.cross(N, _v1, _v2);\n            if (vec3.dot(_v3, N) >= 0) {\n                vec3.sub(_v1, p1, p2);\n                vec3.sub(_v2, p1, r1);\n                alpha = vec3.dot(_v1, additions.N2) / vec3.dot(_v2, additions.N2);\n                vec3.scale(_v1, _v2, alpha);\n                vec3.sub(additions.source, p1, _v1);\n                vec3.sub(_v1, p1, p2);\n                vec3.sub(_v2, p1, q1);\n                alpha = vec3.dot(_v1, additions.N2) / vec3.dot(_v2, additions.N2);\n                vec3.scale(_v1, _v2, alpha);\n                vec3.sub(additions.target, p1, _v1);\n            }\n            else {\n                vec3.sub(_v1, p2, p1);\n                vec3.sub(_v2, p2, q2);\n                alpha = vec3.dot(_v1, additions.N1) / vec3.dot(_v2, additions.N1);\n                vec3.scale(_v1, _v2, alpha);\n                vec3.sub(additions.source, p2, _v1);\n                vec3.sub(_v1, p1, p2);\n                vec3.sub(_v2, p1, q1);\n                alpha = vec3.dot(_v1, additions.N2) / vec3.dot(_v2, additions.N2);\n                vec3.scale(_v1, _v2, alpha);\n                vec3.sub(additions.target, p1, _v1);\n            }\n\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction lineIntersects(line1: Line, line2: Line, points?: vec3[]) {\n    const r = vec3.sub(vec3.create(), line1.end, line1.start);\n    const s = vec3.sub(vec3.create(), line2.end, line2.start);\n    const q = vec3.sub(vec3.create(), line1.start, line2.start);\n\n    const dotqr = vec3.dot(q, r);\n    const dotqs = vec3.dot(q, s);\n    const dotrs = vec3.dot(r, s);\n    const dotrr = vec3.dot(r, r);\n    const dotss = vec3.dot(s, s);\n\n    const denom = (dotrr * dotss) - (dotrs * dotrs);\n    const numer = (dotqs * dotrs) - (dotqr * dotss);\n\n    const t = numer / denom;\n    const u = (dotqs + t * dotrs) / dotss;\n\n    const p0 = vec3.scaleAndAdd(r, line1.start, r, t);\n    const p1 = vec3.scaleAndAdd(s, line2.start, s, u);\n\n    let onSegment = false;\n    let intersects = false;\n\n    if (0 <= t && t <= 1 && 0 <= u && u <= 1) {\n        onSegment = true;\n    }\n\n    const p0p1Length = vec3.distance(p0, p1);\n\n    if (p0p1Length <= 1e-5) {\n        intersects = true;\n    }\n\n    if (!(intersects && onSegment)) {\n        return false;\n    }\n\n    if (points) {\n        points.push(p0, p1);\n    }\n\n    return true;\n}\n\nfunction getLines(triangle: Triangle) {\n    return [\n        <Line>{ start: triangle.a, end: triangle.b },\n        <Line>{ start: triangle.b, end: triangle.c },\n        <Line>{ start: triangle.c, end: triangle.a }\n    ];\n}\n\nfunction checkTrianglesIntersection(triangle1: Triangle, triangle2: Triangle, additions: Additions = { coplanar: false, source: vec3.create(), target: vec3.create() }) {\n    if (additions.coplanar) {\n        const triangle1Lines = getLines(triangle1);\n        const triangle2Lines = getLines(triangle2);\n\n        for (let i = 0; i < 3; i++) {\n            for (let j = 0; j < 3; j++) {\n                if (lineIntersects(triangle1Lines[i], triangle2Lines[j])) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return triangleIntersectsTriangle(triangle1, triangle2, additions);\n}\n\nexport { triangleIntersectsTriangle, checkTrianglesIntersection, getLines, lineIntersects };", "import { INV_EPSILON, THIRD } from './const-numbers';\n\nimport { vec3 } from 'gl-matrix';\n\nexport default class Triangle {\n    private _midpoint?: vec3;\n    private _hash?: number;\n\n    constructor(public a: Readonly<vec3>, public b: Readonly<vec3>, public c: Readonly<vec3>) {}\n\n    static copyAuxValues(source: Triangle, destination: Triangle) {\n        if (source._midpoint) {\n            if (destination._midpoint) {\n                vec3.copy(destination._midpoint, source._midpoint);\n            } else {\n                destination._midpoint = vec3.clone(source._midpoint);\n            }\n        }\n\n        if (source._hash) {\n            destination._hash = source._hash;\n        }\n    }\n\n    set(a: Readonly<vec3>, b: Readonly<vec3>, c: Readonly<vec3>) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this._midpoint = undefined;\n        this._hash = undefined;\n    }\n\n    get midpoint(): Readonly<vec3> {\n        // return cached version\n        if (this._midpoint) {\n            return this._midpoint;\n        }\n\n        // no cached version, calculate average point\n        this._midpoint = vec3.clone(this.a);\n        vec3.add(this._midpoint, this._midpoint, this.b);\n        vec3.add(this._midpoint, this._midpoint, this.c);\n        return vec3.scale(this._midpoint, this._midpoint, THIRD);\n    }\n\n    equals(other: Triangle) {\n        return vec3.equals(this.a, other.a) && vec3.equals(this.b, other.b) && vec3.equals(this.c, other.c);\n    }\n\n    private murmur_32_scramble(k: number): number {\n        k *= 0xcc9e2d51;\n        k = (k << 15) | (k >> 17);\n        k *= 0x1b873593;\n        return k & 0xffffffff;\n    }\n\n    private murmur3_32(data: Float32Array, seed: number): number {\n        let h = seed;\n\n        /* Read in groups of 4. */\n        const view = new Uint32Array(data.buffer);\n        for (const key of view) {\n            h ^= this.murmur_32_scramble(key);\n            h = ((h << 13) & 0xffffffff) | (h >> 19);\n            h = (h * 5 + 0xe6546b64) & 0xffffffff;\n        }\n\n        /* Finalize. */\n        h ^= view.byteLength;\n        h ^= h >> 16;\n        h = (h * 0x85ebca6b) & 0xffffffff;\n        h ^= h >> 13;\n        h = (h * 0xc2b2ae35) & 0xffffffff;\n        h ^= h >> 16;\n        return h;\n    }\n\n    get hash(): number {\n        // return cached version\n        if (this._hash !== undefined) {\n            return this._hash;\n        }\n\n        // no cached version, calculate hash\n        const data = new Float32Array([\n            this.a[0] * INV_EPSILON,\n            this.a[1] * INV_EPSILON,\n            this.a[2] * INV_EPSILON,\n            this.b[0] * INV_EPSILON,\n            this.b[1] * INV_EPSILON,\n            this.b[2] * INV_EPSILON,\n            this.c[0] * INV_EPSILON,\n            this.c[1] * INV_EPSILON,\n            this.c[2] * INV_EPSILON\n        ]);\n\n        this._hash = this.murmur3_32(data, 0xea8ed414);\n        return this._hash;\n    }\n}", "import { mat3, mat4, quat, vec2, vec3 } from 'gl-matrix';\n\nexport const tv0 = vec3.create();\nexport const tv1 = vec3.create();\nexport const tv2 = vec3.create();\nexport const tmpm3 = mat3.create();\nexport const tmpm4_0 = mat4.create();\nexport const tmpm4_1 = mat4.create();\nexport const tv0_2 = vec2.create();\nexport const tv1_2 = vec2.create();\nexport const tq0 = quat.create();", "import { tv0, tv1 } from './temp';\n\nimport { vec3, vec4 } from 'gl-matrix';\n\nexport default class Plane {\n    constructor(public buffer: vec4) {}\n\n    static fromNormal(normal: vec3, w: number) {\n        const buffer = vec4.create();\n        vec3.copy(buffer as vec3, normal);\n        buffer[3] = w;\n        return new Plane(buffer);\n    }\n\n    get w(): number {\n        return this.buffer[3];\n    }\n\n    set w(w: number) {\n        this.buffer[3] = w;\n    }\n\n    get unsafeNormal() {\n        // XXX it's unsafe to reuse normals for other purposes. only use this\n        // getter to copy the normal\n        return this.buffer as vec3;\n    }\n\n    clone() {\n        return new Plane(vec4.clone(this.buffer));\n    }\n\n    flip() {\n        vec3.negate(this.buffer as vec3, this.buffer as vec3);\n        this.w = -this.w;\n    }\n\n    delete() {\n        (this.buffer as unknown) = undefined;\n    }\n\n    equals(p: Plane) {\n        return vec4.equals(this.buffer, p.buffer);\n    }\n\n    static calculateNormal(a: Readonly<vec3>, b: Readonly<vec3>, c: Readonly<vec3>): vec3 {\n        vec3.sub(tv0, b, a);\n        vec3.sub(tv1, c, a);\n        vec3.cross(tv0, tv0, tv1);\n        vec3.normalize(tv0, tv0);\n\n        return vec3.clone(tv0);\n    }\n\n    static fromPoints(a: vec3, b: vec3, c: vec3) {\n        const n = Plane.calculateNormal(a, b, c);\n        return Plane.fromNormal(n, vec3.dot(n, a));\n    }\n}", "import Triangle from './Triangle';\nimport { tmpm3 } from './temp';\nimport Plane from './Plane';\n\nimport type Vertex from './Vertex';\n\nimport { mat3, mat4, vec3 } from 'gl-matrix';\nimport { MaterialDefinitions, MaterialAttributes, MaterialAttributeTransform } from '../base/MaterialDefinition';\n\nlet _polygonID = 0;\n\nexport enum PolygonState {\n    Undecided,\n    Inside,\n    Outside,\n    CoplanarBack,\n    CoplanarFront,\n}\n\nexport class Polygon {\n    id: number;\n    vertices: Vertex[];\n    shared: number;\n    plane: Plane;\n    triangle: Triangle;\n    intersects = false;\n    state = PolygonState.Undecided;\n    previousState = PolygonState.Undecided;\n    previousStates: PolygonState[] = [];\n    valid = true;\n    coplanar = false;\n    originalValid = false;\n    newPolygon = false;\n\n    constructor(vertices: Vertex[], shared = 0) {\n        this.id = _polygonID++;\n        this.vertices = vertices.map(v => v.clone());\n        this.shared = shared;\n        this.plane = Plane.fromPoints(this.vertices[0].pos, this.vertices[1].pos, this.vertices[2].pos);\n        this.triangle = new Triangle(this.vertices[0].pos, this.vertices[1].pos, this.vertices[2].pos);\n    }\n\n    get midpoint() {\n        return this.triangle.midpoint;\n    }\n\n    applyMatrixNoAuto(attributes: MaterialAttributes | undefined, matrix: mat4, normalMatrix: mat3 | undefined) {\n        this.vertices.forEach(v => {\n            vec3.transformMat4(v.pos, v.pos, matrix);\n\n            if (normalMatrix) {\n                v.applyMatrix(matrix, normalMatrix, attributes);\n            }\n        });\n\n        this.plane.delete();\n        this.plane = Plane.fromPoints(this.vertices[0].pos, this.vertices[1].pos, this.vertices[2].pos);\n        this.triangle.set(this.vertices[0].pos, this.vertices[1].pos, this.vertices[2].pos);\n    }\n\n    applyMatrix(materials: MaterialDefinitions, matrix: mat4, normalMatrixIn?: mat3) {\n        let normalMatrix: undefined | mat3;\n        const attributes = materials.get(this.shared);\n\n        if (attributes) {\n            for (const propDef of attributes) {\n                if (propDef.transformable === MaterialAttributeTransform.Normal) {\n                    normalMatrix = normalMatrixIn || mat3.normalFromMat4(tmpm3, matrix);\n                    break;\n                }\n            }\n        }\n\n        this.applyMatrixNoAuto(attributes, matrix, normalMatrix);\n    }\n\n    reset(resetOriginal = true) {\n        this.intersects = false;\n        this.state = PolygonState.Undecided;\n        this.previousState = PolygonState.Undecided;\n        this.previousStates.length = 0;\n        this.valid = true;\n        this.coplanar = false;\n        resetOriginal && (this.originalValid = false);\n        this.newPolygon = false;\n    }\n\n    setState(state: PolygonState, keepState?: PolygonState) {\n        if (this.state === keepState) {\n            return;\n        }\n\n        this.previousState = this.state;\n        this.state !== PolygonState.Undecided && this.previousStates.push(this.state);\n        this.state = state;\n    }\n\n    checkAllStates(state: PolygonState) {\n        if (this.state !== state || (this.previousState !== state && this.previousState !== PolygonState.Undecided)) {\n            return false;\n        }\n\n        for (const previousState of this.previousStates) {\n            if (previousState !== state) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    setInvalid() {\n        this.valid = false;\n    }\n\n    setValid() {\n        this.valid = true;\n    }\n\n    clone() {\n        const polygon = new Polygon(this.vertices.map(v => v.clone()), this.shared);\n        polygon.intersects = this.intersects;\n        polygon.valid = this.valid;\n        polygon.coplanar = this.coplanar;\n        polygon.state = this.state;\n        polygon.originalValid = this.originalValid;\n        polygon.newPolygon = this.newPolygon;\n        polygon.previousState = this.previousState;\n        polygon.previousStates = this.previousStates.slice();\n\n        Triangle.copyAuxValues(this.triangle, polygon.triangle);\n\n        return polygon;\n    }\n\n    flip(materials: MaterialDefinitions) {\n        const attributes = materials.get(this.shared);\n        this.vertices.reverse().forEach(v => v.flip(attributes));\n        const tmp = this.triangle.a;\n        this.triangle.a = this.triangle.c;\n        this.triangle.c = tmp;\n        this.plane.flip();\n    }\n\n    delete() {\n        this.vertices.forEach(v => v.delete());\n        this.vertices.length = 0;\n\n        if (this.plane) {\n            this.plane.delete();\n            (this.plane as unknown) = undefined;\n        }\n\n        (this.triangle as unknown) = undefined;\n        this.shared = 0;\n        this.setInvalid();\n    }\n}", "import type { vec2, vec3, vec4 } from 'gl-matrix';\n\nexport enum MaterialAttributeValueType {\n    Number,\n    Vec2,\n    Vec3,\n    Vec4,\n}\n\nexport type MaterialAttributeValue = number | vec2 | vec3 | vec4;\n\nexport enum MaterialAttributeTransform {\n    Model = 0,\n    Normal = 1,\n}\n\n// XXX standard vertex attribute types grow down so that attribute IDs can be\n// assigned from 0 onwards\nexport enum MaterialAttributeStandardType {\n    TextureCoordinate = -1,\n    Color = -2,\n    Normal = -3,\n    Tangent = -4,\n}\n\nexport type MaterialAttribute = Readonly<{\n    type: MaterialAttributeStandardType | number,\n    valueType: MaterialAttributeValueType,\n    transformable: null | MaterialAttributeTransform,\n    flippable: boolean,\n}>;\n\nexport type MaterialAttributes = Readonly<Array<MaterialAttribute>>;\n\n// XXX it's valid for a material to have no assigned material attributes. if\n// this is the case, then a vertex will only have a position\nexport type MaterialDefinitions = Map<number, MaterialAttributes>;", "import { Polygon, PolygonState } from './Polygon';\nimport { EPSILON } from './const-numbers';\nimport { tv0 } from './temp';\n\nimport type Vertex from './Vertex';\nimport type Plane from './Plane';\n\nimport { vec3 } from 'gl-matrix';\nimport { MaterialDefinitions } from '../base/MaterialDefinition';\n\nexport enum ReturnPolygonType {\n    Undecided = PolygonState.Undecided,\n    Back,\n    Front,\n    CoplanarBack = PolygonState.CoplanarBack,\n    CoplanarFront = PolygonState.CoplanarFront,\n}\n\ninterface ReturnPolygon {\n    polygon: Polygon,\n    type: ReturnPolygonType\n}\n\nconst COPLANAR = 0;\nconst FRONT = 1;\nconst BACK = 2;\nconst SPANNING = 3;\n\nexport function splitPolygonByPlane(polygon: Polygon, plane: Plane, materials: MaterialDefinitions, result: ReturnPolygon[] = []) {\n    const attributes = materials.get(polygon.shared);\n\n    const returnPolygon = <ReturnPolygon>{\n        polygon: polygon,\n        type: ReturnPolygonType.Undecided\n    };\n\n    let polygonType = 0;\n    const types = [];\n\n    for (const vertex of polygon.vertices) {\n        const t = vec3.dot(plane.unsafeNormal, vertex.pos) - plane.w;\n        const type = (t < -EPSILON) ? BACK : (t > EPSILON) ? FRONT : COPLANAR;\n        polygonType |= type;\n        types.push(type);\n    }\n\n    switch (polygonType) {\n        case COPLANAR:\n            returnPolygon.type = vec3.dot(plane.unsafeNormal, polygon.plane.unsafeNormal) > 0 ? ReturnPolygonType.CoplanarFront : ReturnPolygonType.CoplanarBack;\n            result.push(returnPolygon);\n            break;\n        case FRONT:\n            returnPolygon.type = ReturnPolygonType.Front;\n            result.push(returnPolygon);\n            break;\n        case BACK:\n            returnPolygon.type = ReturnPolygonType.Back;\n            result.push(returnPolygon);\n            break;\n        case SPANNING:\n        {\n            const f = [];\n            const b = [];\n\n            const vertCount = polygon.vertices.length;\n            for (let i = 0; i < vertCount; i++) {\n                const j = (i + 1) % vertCount;\n                const ti = types[i];\n                const tj = types[j];\n                const vi = polygon.vertices[i];\n                const vj = polygon.vertices[j];\n\n                if (ti !== BACK) {\n                    f.push(vi);\n                }\n\n                if (ti !== FRONT) {\n                    b.push(ti != BACK ? vi.clone() : vi);\n                }\n\n                if ((ti | tj) === SPANNING) {\n                    vec3.sub(tv0, vj.pos, vi.pos);\n                    const t = (plane.w - vec3.dot(plane.unsafeNormal, vi.pos)) / vec3.dot(plane.unsafeNormal, tv0);\n                    const v = vi.interpolate(vj, t, attributes);\n                    f.push(v);\n                    b.push(v.clone());\n                }\n            }\n\n            if (f.length > 3) {\n                for (const newPoly of splitPolygonArr(f)) {\n                    result.push({\n                        polygon: new Polygon(newPoly, polygon.shared),\n                        type: ReturnPolygonType.Front\n                    });\n                }\n            } else if (f.length === 3) {\n                result.push({\n                    polygon: new Polygon(f, polygon.shared),\n                    type: ReturnPolygonType.Front\n                });\n            }\n\n            if (b.length > 3) {\n                for (const newPoly of splitPolygonArr(b)) {\n                    result.push({\n                        polygon: new Polygon(newPoly, polygon.shared),\n                        type: ReturnPolygonType.Back\n                    });\n                }\n            } else if (b.length === 3) {\n                result.push({\n                    polygon: new Polygon(b, polygon.shared),\n                    type: ReturnPolygonType.Back\n                });\n            }\n\n            break;\n        }\n    }\n\n    if (result.length == 0) {\n        result.push(returnPolygon);\n    }\n\n    return result;\n}\n\nfunction splitPolygonArr(arr: Vertex[]) {\n    const resultArr = [];\n\n    if (arr.length > 4) {\n        console.warn(`[splitPolygonArr] arr.length (${arr.length}) > 4`);\n        for (let j = 3; j <= arr.length; j++) {\n            resultArr.push([\n                arr[0].clone(), arr[j - 2].clone(), arr[j - 1].clone()\n            ]);\n        }\n    } else if (vec3.squaredDistance(arr[0].pos, arr[2].pos) <= vec3.squaredDistance(arr[1].pos, arr[3].pos)) {\n        resultArr.push(\n            [arr[0].clone(), arr[1].clone(), arr[2].clone()],\n            [arr[0].clone(), arr[2].clone(), arr[3].clone()]\n        );\n    } else {\n        resultArr.push(\n            [arr[0].clone(), arr[1].clone(), arr[3].clone()],\n            [arr[1].clone(), arr[2].clone(), arr[3].clone()]\n        );\n    }\n\n    return resultArr;\n}", "import type Triangle from './Triangle';\nimport type Ray from './Ray';\n\nimport { vec3 } from 'gl-matrix';\n\nconst edge1: vec3 = [0, 0, 0];\nconst edge2: vec3 = [0, 0, 0];\nconst h: vec3 = [0, 0, 0];\nconst s: vec3 = [0, 0, 0];\nconst q: vec3 = [0, 0, 0];\nconst RAY_EPSILON = 1e-8;\n\nexport default function rayIntersectsTriangle(ray: Ray, triangle: Triangle, target = vec3.create()) {\n    // XXX a big chunk of the computation time is spent here. it would be nice\n    // to have a faster intersection algorithm. for example, we already have\n    // pre-calculated triangle normals. maybe find a way to reuse them?\n\n    // https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm\n    vec3.sub(edge1, triangle.b, triangle.a);\n    vec3.sub(edge2, triangle.c, triangle.a);\n    vec3.cross(h, ray.direction, edge2);\n\n    const a = vec3.dot(edge1, h);\n    if (a > -RAY_EPSILON && a < RAY_EPSILON) {\n        return null; // Ray is parallel to the triangle\n    }\n\n    vec3.sub(s, ray.origin, triangle.a);\n\n    const f = 1 / a;\n    const u = f * vec3.dot(s, h);\n    if (u < 0 || u > 1) {\n        return null;\n    }\n\n    vec3.cross(q, s, edge1);\n\n    const v = f * vec3.dot(ray.direction, q);\n    if (v < 0 || u + v > 1) {\n        return null;\n    }\n\n    // Check where intersection is\n    const t = f * vec3.dot(edge2, q);\n    if (t > RAY_EPSILON) {\n        return vec3.scaleAndAdd(target, ray.origin, ray.direction, t);\n    }\n\n    return null;\n}", "import Plane from './Plane';\n\nimport type Triangle from './Triangle';\nimport type Ray from './Ray';\n\nimport { vec3 } from 'gl-matrix';\n\nconst _tv1 = vec3.create();\nconst _tv2 = vec3.create();\nconst _tv3 = vec3.create();\n\n// 3 main axis of an AABB\nconst _bxNorm: Readonly<vec3> = vec3.fromValues(1, 0, 0);\nconst _byNorm: Readonly<vec3> = vec3.fromValues(0, 1, 0);\nconst _bzNorm: Readonly<vec3> = vec3.fromValues(0, 0, 1);\n\n// temp variables for box vertices. Up, Down, Left, Right, Back (-z), Front (+z)\nconst _lub = vec3.create();\nconst _rub = vec3.create();\nconst _luf = vec3.create();\nconst _ruf = vec3.create();\nconst _ldb = vec3.create();\nconst _rdb = vec3.create();\nconst _ldf = vec3.create();\nconst _rdf = vec3.create();\n\n// temp variables for triangle edges\nconst _ba = vec3.create();\nconst _cb = vec3.create();\nconst _ac = vec3.create();\n\n// canonical SSE min/max\nfunction canonMin(x: number, y: number) {\n    return x < y ? x : y;\n}\n\nfunction canonMax(x: number, y: number) {\n    return x > y ? x : y;\n}\n\nexport default class Box3 {\n    constructor(public min = vec3.create(), public max = vec3.create()) {}\n\n    clone(): Box3 {\n        return new Box3(vec3.clone(this.min), vec3.clone(this.max));\n    }\n\n    expandByPoint(point: Readonly<vec3>) {\n        vec3.min(this.min, this.min, point);\n        vec3.max(this.max, this.max, point);\n    }\n\n    expandByScalar(scalar: number) {\n        vec3.set(_tv1, scalar, scalar, scalar);\n        vec3.sub(this.min, this.min, _tv1);\n        vec3.add(this.max, this.max, _tv1);\n    }\n\n    private _project(points: Readonly<Readonly<vec3>[]>, normal: Readonly<vec3>): [min: number, max: number] {\n        const count = points.length;\n        let min = vec3.dot(points[0], normal);\n        let max = min;\n\n        for (let i = 1; i < count; i++) {\n            const dotProd = vec3.dot(points[i], normal);\n            min = Math.min(min, dotProd);\n            max = Math.max(max, dotProd);\n        }\n\n        return [min, max];\n    }\n\n    private _testNormal(boxAxisMin: number, boxAxisMax: number, normal: Readonly<vec3>, vertices: Readonly<Readonly<vec3>[]>): boolean {\n        const [min, max] = this._project(vertices, normal);\n        return max < boxAxisMin || min > boxAxisMax;\n    }\n\n    private _testECP(triEdge: Readonly<vec3>, boxNormal: Readonly<vec3>, triVerts: Readonly<Readonly<vec3>[]>, boxVerts: Readonly<Readonly<vec3>[]>): boolean {\n        const axis = vec3.cross(_tv1, triEdge, boxNormal);\n        const [boxMin, boxMax] = this._project(boxVerts, axis);\n        const [triMin, triMax] = this._project(triVerts, axis);\n        return boxMax < triMin || boxMin > triMax;\n    }\n\n    intersectsTriangle(triangle: Triangle): boolean {\n        // AABB and triangle intersection algorithm from:\n        // https://stackoverflow.com/a/17503268\n        // using fix from:\n        // https://stackoverflow.com/a/23456651\n\n        // test box normals\n        const triVerts = [triangle.a, triangle.b, triangle.c];\n\n        if (\n            this._testNormal(this.min[0], this.max[0], _bxNorm, triVerts) ||\n            this._testNormal(this.min[1], this.max[1], _byNorm, triVerts) ||\n            this._testNormal(this.min[2], this.max[2], _bzNorm, triVerts)\n        ) {\n            return false;\n        }\n\n        // test triangle normal\n        const triNorm = Plane.calculateNormal(triangle.a, triangle.b, triangle.c);\n        const triOffset = vec3.dot(triNorm, triangle.a);\n        const boxVerts = [\n            vec3.set(_lub, this.min[0], this.max[1], this.min[2]),\n            vec3.set(_rub, this.max[0], this.max[1], this.min[2]),\n            vec3.set(_luf, this.min[0], this.max[1], this.max[2]),\n            vec3.set(_ruf, this.max[0], this.max[1], this.max[2]),\n            vec3.set(_ldb, this.min[0], this.min[1], this.min[2]),\n            vec3.set(_rdb, this.max[0], this.min[1], this.min[2]),\n            vec3.set(_ldf, this.min[0], this.min[1], this.max[2]),\n            vec3.set(_rdf, this.max[0], this.min[1], this.max[2])\n        ];\n\n        const [boxMin, boxMax] = this._project(boxVerts, triNorm);\n        if (boxMax < triOffset || boxMin > triOffset) {\n            return false;\n        }\n\n        // test nine edge cross-products\n        vec3.sub(_ba, triangle.a, triangle.b);\n        vec3.sub(_cb, triangle.b, triangle.c);\n        vec3.sub(_ac, triangle.c, triangle.a);\n\n        return !(\n            this._testECP(_ba, _bxNorm, triVerts, boxVerts) ||\n            this._testECP(_ba, _byNorm, triVerts, boxVerts) ||\n            this._testECP(_ba, _bzNorm, triVerts, boxVerts) ||\n            this._testECP(_cb, _bxNorm, triVerts, boxVerts) ||\n            this._testECP(_cb, _byNorm, triVerts, boxVerts) ||\n            this._testECP(_cb, _bzNorm, triVerts, boxVerts) ||\n            this._testECP(_ac, _bxNorm, triVerts, boxVerts) ||\n            this._testECP(_ac, _byNorm, triVerts, boxVerts) ||\n            this._testECP(_ac, _bzNorm, triVerts, boxVerts)\n        );\n    }\n\n    intersectsBox(box: Box3): boolean {\n        return !(\n            this.min[0] > box.max[0] || this.max[0] < box.min[0] ||\n            this.min[1] > box.max[1] || this.max[1] < box.min[1] ||\n            this.min[2] > box.max[2] || this.max[2] < box.min[2]\n        );\n    }\n\n    intersectsRay(ray: Ray): boolean {\n        // AABB and line intersection algorithm from:\n        // https://tavianator.com/2022/ray_box_boundary.html\n        // adapted to handle directional rays instead of bi-directional lines\n        // TODO test whether branchless programming is improving performance\n\n        // dir_inv\n        vec3.inverse(_tv3, ray.direction);\n\n        // t1\n        vec3.sub(_tv1, this.min, ray.origin);\n        vec3.mul(_tv1, _tv1, _tv3);\n\n        // t2\n        vec3.sub(_tv2, this.max, ray.origin);\n        vec3.mul(_tv2, _tv2, _tv3);\n\n        let tmax = Math.max(canonMin(_tv1[0], Infinity), canonMin(_tv2[0], Infinity));\n        tmax = Math.max(canonMin(_tv1[1], tmax), canonMin(_tv2[1], tmax));\n        tmax = Math.max(canonMin(_tv1[2], tmax), canonMin(_tv2[2], tmax));\n        let tmin = Math.min(canonMax(_tv1[0], 0), canonMax(_tv2[0], 0));\n        tmin = Math.min(canonMax(_tv1[1], tmin), canonMax(_tv2[1], tmin));\n        tmin = Math.min(canonMax(_tv1[2], tmin), canonMax(_tv2[2], tmin));\n\n        return tmin < tmax;\n    }\n\n    rayIntersection(ray: Ray, output: vec3): boolean {\n        // XXX similar to intersectsRay, but sets an output vector with the\n        // intersection point\n        // dir_inv\n        vec3.inverse(_tv3, ray.direction);\n\n        // t1\n        vec3.sub(_tv1, this.min, ray.origin);\n        vec3.mul(_tv1, _tv1, _tv3);\n\n        // t2\n        vec3.sub(_tv2, this.max, ray.origin);\n        vec3.mul(_tv2, _tv2, _tv3);\n\n        let tmax = Math.max(canonMin(_tv1[0], Infinity), canonMin(_tv2[0], Infinity));\n        tmax = Math.max(canonMin(_tv1[1], tmax), canonMin(_tv2[1], tmax));\n        tmax = Math.max(canonMin(_tv1[2], tmax), canonMin(_tv2[2], tmax));\n        let tmin = Math.min(canonMax(_tv1[0], 0), canonMax(_tv2[0], 0));\n        tmin = Math.min(canonMax(_tv1[1], tmin), canonMax(_tv2[1], tmin));\n        tmin = Math.min(canonMax(_tv1[2], tmin), canonMax(_tv2[2], tmin));\n\n        if (tmin >= tmax) {\n            return false;\n        }\n\n        vec3.scaleAndAdd(output, ray.origin, ray.direction, tmin < 0 ? tmax : tmin);\n\n        return true;\n    }\n\n    containsPoint(point: Readonly<vec3>): boolean {\n        return point[0] >= this.min[0] && point[0] <= this.max[0]\n            && point[1] >= this.min[1] && point[1] <= this.max[1]\n            && point[2] >= this.min[2] && point[2] <= this.max[2];\n    }\n\n    makeEmpty() {\n        vec3.set(this.min, 0, 0, 0);\n        vec3.set(this.max, 0, 0, 0);\n    }\n}", "import { vec3 } from 'gl-matrix';\n\nexport default class Ray {\n    origin = vec3.create();\n    direction = vec3.fromValues(0, 0, -1);\n}", "import { polyInside_WindingNumber_buffer, _wP_EPS_ARR, prepareTriangleBuffer } from '../math/winding-number';\nimport { checkTrianglesIntersection } from '../math/three-triangle-intersection';\nimport { ReturnPolygonType, splitPolygonByPlane } from '../math/split-polygon';\nimport rayIntersectsTriangle from '../math/ray-intersects-triangle';\nimport { PolygonState } from '../math/Polygon';\nimport { tmpm3, tv0 } from '../math/temp';\nimport Box3 from '../math/Box3';\nimport Ray from '../math/Ray';\nimport { mat3, mat4, vec3 } from 'gl-matrix';\nimport { MaterialDefinitions, MaterialAttributeTransform, MaterialAttributeValueType } from './MaterialDefinition';\nimport { encodePoint, encodePointDatum } from '../worker/encode-point';\nimport { JobError, JobFailReason } from '../worker/JobError';\nimport TriangleHasher from './TriangleHasher';\nimport { CSG_Rules } from './CSGRule';\nimport countExtraVertexBytes from '../worker/count-extra-vertex-bytes';\nimport { decodePoint, decodePointDatum } from '../worker/decode-point';\nimport { Polygon } from '../math/Polygon';\nimport { mergeTwoMaterials } from './merge-materials';\n\nimport type Triangle from '../math/Triangle';\nimport type { OctreeCSGObject } from './OctreeCSGObject';\nimport type { CSGRulesArray } from './CSGRule';\nimport type { EncodedOctreeCSG } from '../worker/EncodedOctreeCSGObject';\n\nconst _v1 = vec3.create();\nconst _v2 = vec3.create();\nconst _v3 = vec3.create();\n\nconst _ray = new Ray();\nconst _rayDirection = vec3.fromValues(0, 0, 1);\n\ninterface RayIntersect {\n    distance: number,\n    polygon: Polygon,\n    position: vec3\n}\n\ntype PolygonCounts = Map<number, number>;\ntype SectionOffsets = Map<number, number>;\n\nconst uint32Max = 2 ** 32 - 1;\nconst defaultUseWindingNumber = false;\nconst defaultBatchSize = 100;\nconst defaultMaxLevel = 16;\nconst defaultPolygonsPerTree = 100;\n\nexport interface OctreeCSGOptions {\n    useWindingNumber?: boolean;\n    maxLevel?: number;\n    polygonsPerTree?: number;\n}\n\nexport interface AsyncOctreeCSGOptions extends OctreeCSGOptions {\n    batchSize?: number;\n}\n\nexport default class OctreeCSG {\n    protected polygons: Polygon[];\n    protected replacedPolygons: Polygon[];\n    protected box?: Box3;\n    protected subTrees: OctreeCSG[];\n    protected parent: OctreeCSG | null;\n    protected level: number;\n    protected polygonArrays: Polygon[][];\n    protected needsRebuild = true;\n\n    static readonly maxSectionID = uint32Max;\n    static readonly maxMaterialID = uint32Max;\n\n    constructor(public materials: Readonly<MaterialDefinitions>, box?: Box3, parent: OctreeCSG | null = null) {\n        this.polygons = [];\n        this.replacedPolygons = [];\n        this.box = box;\n        this.subTrees = [];\n        this.parent = parent;\n        this.level = 0;\n        this.polygonArrays = [];\n        this.addPolygonsArrayToRoot(this.polygons);\n    }\n\n    clone() {\n        return new OctreeCSG(this.materials).copy(this);\n    }\n\n    copy(source: OctreeCSG) {\n        this.deletePolygonsArrayFromRoot(this.polygons);\n        this.polygons = source.polygons.map(p => p.clone());\n        this.addPolygonsArrayToRoot(this.polygons);\n\n        this.replacedPolygons = source.replacedPolygons.map(p => p.clone());\n        this.box = source.box?.clone();\n        this.level = source.level;\n        this.needsRebuild = source.needsRebuild;\n\n        for (const subTree of source.subTrees) {\n            this.subTrees.push(new OctreeCSG(this.materials, undefined, this).copy(subTree));\n        }\n\n        return this;\n    }\n\n    protected addPolygonsArrayToRoot(array: Polygon[]) {\n        if (this.parent) {\n            this.parent.addPolygonsArrayToRoot(array);\n        } else {\n            this.polygonArrays.push(array);\n        }\n    }\n\n    protected deletePolygonsArrayFromRoot(array: Polygon[]) {\n        if (this.parent) {\n            this.parent.deletePolygonsArrayFromRoot(array);\n        } else {\n            const index = this.polygonArrays.indexOf(array);\n\n            if (index > -1) {\n                this.polygonArrays.splice(index, 1);\n            }\n        }\n    }\n\n    isEmpty() {\n        return this.polygons.length === 0;\n    }\n\n    addPolygon(polygon: Polygon, triangleHasher?: TriangleHasher) {\n        const triangle = polygon.triangle;\n\n        if (triangleHasher && !triangleHasher.isUnique(triangle)) {\n            return this;\n        }\n\n        if (this.box) {\n            this.box.min[0] = Math.min(this.box.min[0], triangle.a[0], triangle.b[0], triangle.c[0]);\n            this.box.min[1] = Math.min(this.box.min[1], triangle.a[1], triangle.b[1], triangle.c[1]);\n            this.box.min[2] = Math.min(this.box.min[2], triangle.a[2], triangle.b[2], triangle.c[2]);\n            this.box.max[0] = Math.max(this.box.max[0], triangle.a[0], triangle.b[0], triangle.c[0]);\n            this.box.max[1] = Math.max(this.box.max[1], triangle.a[1], triangle.b[1], triangle.c[1]);\n            this.box.max[2] = Math.max(this.box.max[2], triangle.a[2], triangle.b[2], triangle.c[2]);\n        } else {\n            this.box = new Box3();\n            this.box.min[0] = Math.min(triangle.a[0], triangle.b[0], triangle.c[0]);\n            this.box.min[1] = Math.min(triangle.a[1], triangle.b[1], triangle.c[1]);\n            this.box.min[2] = Math.min(triangle.a[2], triangle.b[2], triangle.c[2]);\n            this.box.max[0] = Math.max(triangle.a[0], triangle.b[0], triangle.c[0]);\n            this.box.max[1] = Math.max(triangle.a[1], triangle.b[1], triangle.c[1]);\n            this.box.max[2] = Math.max(triangle.a[2], triangle.b[2], triangle.c[2]);\n        }\n\n        this.polygons.push(polygon);\n        return this;\n    }\n\n    private getSubtreeIdx(treeMid: Readonly<vec3>, point: Readonly<vec3>): number {\n        return ((point[0] >= treeMid[0]) ? 0b100 : 0) |\n               ((point[1] >= treeMid[1]) ? 0b010 : 0) |\n               ((point[2] >= treeMid[2]) ? 0b001 : 0);\n    }\n\n    protected split(level: number, maxLevel: number, polygonsPerTree: number) {\n        if (this.polygons.length <= polygonsPerTree || level >= maxLevel) {\n            return;\n        }\n\n        if (!this.box) {\n            throw new Error('Octree has no box');\n        }\n\n        const subTrees = [];\n        vec3.sub(_v2, this.box.max, this.box.min);\n        const halfsize = vec3.scale(_v2, _v2, 0.5);\n\n        // subTrees array content:\n        // -x-y-z; -x-y+z; -x+y-z; -x+y+z; +x-y-z; +x-y+z; +x+y-z; +x+y+z\n        for (let x = 0; x < 2; x++) {\n            for (let y = 0; y < 2; y++) {\n                for (let z = 0; z < 2; z++) {\n                    const box = new Box3();\n                    const v = vec3.set(_v1, x, y, z);\n\n                    vec3.multiply(_v3, v, halfsize);\n                    vec3.add(box.min, this.box.min, _v3);\n                    vec3.add(box.max, box.min, halfsize);\n                    subTrees.push(new OctreeCSG(this.materials, box, this));\n                }\n            }\n        }\n\n        const treeMid = vec3.add(_v2, this.box.max, this.box.min);\n        vec3.scale(treeMid, treeMid, 0.5);\n\n        const kept = [];\n        for (const polygon of this.polygons) {\n            const origIdx = this.getSubtreeIdx(treeMid, polygon.midpoint);\n            const candidSubTree = subTrees[origIdx];\n            const candidBox = candidSubTree.box as Box3;\n            const [a, b, c] = polygon.vertices;\n\n            if (candidBox.containsPoint(a.pos) && candidBox.containsPoint(b.pos) && candidBox.containsPoint(c.pos)) {\n                candidSubTree.polygons.push(polygon);\n            } else {\n                // XXX at some point it was decided to split polygons that were\n                // in the boundaries of octrees in the hope that it would be\n                // faster than having polygons in stem nodes of the octree, but\n                // it's actually slower, so it was removed\n                kept.push(polygon);\n            }\n        }\n\n        this.polygons.splice(0, this.polygons.length, ...kept);\n\n        for (const subTree of subTrees) {\n            const nextLevel = level + 1;\n            subTree.level = nextLevel;\n            subTree.split(nextLevel, maxLevel, polygonsPerTree);\n            this.subTrees.push(subTree);\n        }\n\n        return this;\n    }\n\n    buildTree(maxLevel?: number, polygonsPerTree?: number) {\n        if (this.subTrees.length > 0) {\n            console.warn('Octree is already built, but buildTree was called. A rebuild will occur');\n            const polygons = this.getPolygons();\n\n            for (const subTree of this.subTrees) {\n                subTree.delete(false);\n            }\n\n            this.subTrees.length = 0;\n            this.polygons.splice(0, this.polygons.length, ...polygons);\n        }\n\n        this.split(0, maxLevel ?? defaultMaxLevel, polygonsPerTree ?? defaultPolygonsPerTree);\n        this.processTree();\n        this.needsRebuild = false;\n\n        return this;\n    }\n\n    protected processTree() {\n        if (!this.isEmpty()) {\n            if (!this.box) {\n                this.box = new Box3();\n            }\n\n            const firstPolygon = this.polygons[0];\n            const firstVertex = firstPolygon.triangle.a;\n            vec3.copy(this.box.min, firstVertex);\n            vec3.copy(this.box.max, firstVertex);\n\n            for (const polygon of this.polygons) {\n                this.box.expandByPoint(polygon.triangle.a);\n                this.box.expandByPoint(polygon.triangle.b);\n                this.box.expandByPoint(polygon.triangle.c);\n            }\n\n            this.expandParentBox();\n        }\n\n        for (const subTree of this.subTrees) {\n            subTree.processTree();\n        }\n    }\n\n    protected expandParentBox() {\n        if (this.parent) {\n            if (!this.box) {\n                throw new Error('Octree has no box');\n            }\n\n            if (!this.parent.box) {\n                throw new Error('Octree\\'s parent has no box');\n            }\n\n            this.parent.box.expandByPoint(this.box.min);\n            this.parent.box.expandByPoint(this.box.max);\n            this.parent.expandParentBox();\n        }\n    }\n\n    getPolygonsIntersectingPolygon(targetPolygon: Polygon, polygons: Polygon[] = []) {\n        if (!this.box) {\n            throw new Error('Octree has no box');\n        }\n\n        if (this.polygons.length > 0 && this.box.intersectsTriangle(targetPolygon.triangle)) {\n            handlePolygonArrayIntersections(targetPolygon, polygons, this.polygons);\n            handlePolygonArrayIntersections(targetPolygon, polygons, this.replacedPolygons);\n        }\n\n        for (const subTree of this.subTrees) {\n            subTree.getPolygonsIntersectingPolygon(targetPolygon, polygons);\n        }\n\n        return polygons;\n    }\n\n    getRayPolygons(ray: Ray, polygons?: Set<Polygon>) {\n        // XXX if the replaced polygons array are not creating a new set, then\n        // using a set is actually slower than using an array and calling\n        // indexOf. when an API such as Set.addAll is added, then using a set\n        // will always be faster than an array. the average case\n\n        if (polygons) {\n            for (const replacedPolygon of this.replacedPolygons) {\n                polygons.add(replacedPolygon);\n            }\n        } else {\n            polygons = new Set(this.replacedPolygons);\n        }\n\n        for (const polygon of this.polygons) {\n            if (polygon.valid && polygon.originalValid) {\n                polygons.add(polygon);\n            }\n        }\n\n        for (const subTree of this.subTrees) {\n            if ((subTree.box as Box3).intersectsRay(ray)) {\n                subTree.getRayPolygons(ray, polygons);\n            }\n        }\n\n        return polygons;\n    }\n\n    rayIntersect(ray: Ray, intersects: RayIntersect[] = []) {\n        if (vec3.squaredLength(ray.direction) === 0) return [];\n\n        for (const polygon of this.getRayPolygons(ray)) {\n            // MollerTrumbore\n            const result = rayIntersectsTriangle(ray, polygon.triangle, _v1);\n            if (result) {\n                const distance = vec3.distance(result, ray.origin);\n                intersects.push({ distance, polygon, position: vec3.add(vec3.create(), result, ray.origin) });\n            }\n        }\n\n        intersects.length && intersects.sort(raycastIntersectAscSort);\n        return intersects;\n    }\n\n    private handlePolyIntersection(ray: Ray, polygon: Polygon, curInt: RayIntersect | null): RayIntersect | null {\n        const result = rayIntersectsTriangle(ray, polygon.triangle, _v1);\n        if (result) {\n            const distance = vec3.distance(result, ray.origin);\n\n            if (!curInt || distance < curInt.distance) {\n                curInt = { distance, polygon, position: vec3.add(vec3.create(), result, ray.origin) };\n            }\n        }\n\n        return curInt;\n    }\n\n    private marchingClosestRayIntersection(ray: Ray): RayIntersect | null {\n        // get closest intersection in current level\n        let thisIntersection: RayIntersect | null = null;\n\n        for (const polygon of this.replacedPolygons) {\n            thisIntersection = this.handlePolyIntersection(ray, polygon, thisIntersection);\n        }\n\n        for (const polygon of this.polygons) {\n            if (polygon.valid && polygon.originalValid) {\n                thisIntersection = this.handlePolyIntersection(ray, polygon, thisIntersection);\n            }\n        }\n\n        // march lower levels\n        if (this.subTrees.length > 0) {\n            // this isn't a leaf node. get lower-level intersections\n            const intSubTrees = new Array<[octree: OctreeCSG, distance: number]>();\n            let intCount = 0;\n\n            for (const subTree of this.subTrees) {\n                // check if subtree intersects ray and get distance\n                let distance = null;\n                if ((subTree.box as Box3).rayIntersection(ray, tv0)) {\n                    distance = vec3.squaredDistance(ray.origin, tv0);\n\n                    // do insertion sort for subtree\n                    let i = 0;\n                    for (; i < intCount && distance >= intSubTrees[i][1]; i++);\n\n                    intSubTrees.splice(i, 0, [subTree, distance]);\n                    intCount++;\n                }\n            }\n\n            // do ray-marching on intersecting subtrees\n            for (const [subTree, _distance] of intSubTrees) {\n                const intersection = subTree.marchingClosestRayIntersection(ray);\n                if (intersection) {\n                    if (!thisIntersection || thisIntersection.distance > intersection.distance) {\n                        thisIntersection = intersection;\n                    }\n                }\n            }\n        }\n\n        return thisIntersection;\n    }\n\n    closestRayIntersection(ray: Ray): RayIntersect | null {\n        if (this.parent === null) {\n            return this.marchingClosestRayIntersection(ray);\n        } else {\n            return this.parent.closestRayIntersection(ray);\n        }\n    }\n\n    getIntersectingPolygons(polygons: Polygon[] = []) {\n        for(const polygonsArray of this.polygonArrays) {\n            for (const polygon of polygonsArray) {\n                if (polygon.valid && polygon.intersects) {\n                    polygons.push(polygon);\n                }\n            }\n        }\n\n        return polygons;\n    }\n\n    getPolygons(polygons: Polygon[] = []) {\n        for(const polygonsArray of this.polygonArrays) {\n            for (const polygon of polygonsArray) {\n                if (polygon.valid && polygons.indexOf(polygon) === -1) {\n                    polygons.push(polygon);\n                }\n            }\n        }\n\n        return polygons;\n    }\n\n    private *levelPolygonsGen(): Generator<Polygon> {\n        for (const polygon of this.polygons) {\n            if (polygon.valid) {\n                yield polygon;\n            }\n        }\n    }\n\n    get levelPolygons() {\n        return this.levelPolygonsGen();\n    }\n\n    private *treePolygonsGen(): Generator<Polygon> {\n        for (const polygon of this.levelPolygons) {\n            yield polygon;\n        }\n\n        for (const subTree of this.subTrees) {\n            for (const polygon of subTree.treePolygons) {\n                yield polygon;\n            }\n        }\n    }\n\n    get treePolygons() {\n        return this.treePolygonsGen();\n    }\n\n    private *lowerLevelsGen(): Generator<OctreeCSG> {\n        for (const subTree of this.subTrees) {\n            yield subTree;\n        }\n    }\n\n    get lowerLevels() {\n        return this.lowerLevelsGen();\n    }\n\n    invert() {\n        for(const polygonsArray of this.polygonArrays) {\n            for(const polygon of polygonsArray) {\n                if (polygon.valid) {\n                    polygon.flip(this.materials);\n                }\n            }\n        }\n    }\n\n    protected replacePolygon(polygon: Polygon, newPolygons: Polygon[] | Polygon) {\n        if (!Array.isArray(newPolygons)) {\n            newPolygons = [newPolygons];\n        }\n\n        if (this.polygons.length > 0) {\n            const polygonIndex = this.polygons.indexOf(polygon);\n            if (polygonIndex > -1) {\n                if (polygon.originalValid) {\n                    this.replacedPolygons.push(polygon);\n                } else {\n                    polygon.setInvalid();\n                }\n\n                this.polygons.splice(polygonIndex, 1, ...newPolygons);\n            }\n        }\n\n        for (const subTree of this.subTrees) {\n            subTree.replacePolygon(polygon, newPolygons);\n        }\n    }\n\n    protected deletePolygonsByStateRules(rulesArr: CSGRulesArray, firstRun = true) {\n        for(const polygonsArray of this.polygonArrays) {\n            if (polygonsArray.length === 0) {\n                continue;\n            }\n\n            for(const polygon of polygonsArray.slice()) {\n                if (!polygon.valid || !polygon.intersects) {\n                    continue;\n                }\n\n                let found = false;\n                for (const rule of rulesArr) {\n                    if (rule.array) {\n                        const states = rule.rule;\n                        if (states.includes(polygon.state) && (((polygon.previousState !== PolygonState.Undecided) && (states.includes(polygon.previousState))) || polygon.previousState === PolygonState.Undecided)) {\n                            found = true;\n                            const missingStates = new Set<PolygonState>();\n\n                            for(const state of states) {\n                                missingStates.add(state);\n                            }\n\n                            missingStates.delete(polygon.state);\n\n                            for (const previousState of polygon.previousStates) {\n                                if (!states.includes(previousState)) { // if previous state not one of provided states (not included in states array), break\n                                    found = false;\n                                    break;\n                                } else {\n                                    missingStates.delete(previousState);\n                                }\n                            }\n\n                            if (found) {\n                                if (missingStates.size > 0) {\n                                    found = false;\n                                } else {\n                                    break;\n                                }\n                            }\n                        }\n                    } else if (polygon.checkAllStates(rule.rule)) {\n                        found = true;\n                        break;\n                    }\n                }\n\n                if (found) {\n                    const polygonIndex = polygonsArray.indexOf(polygon);\n                    if (polygonIndex > -1) {\n                        polygon.setInvalid();\n                        polygonsArray.splice(polygonIndex, 1);\n                    }\n\n                    if (firstRun) {\n                        polygon.delete();\n                    }\n                }\n            }\n        }\n    }\n\n    protected deletePolygonsByIntersection(intersects: boolean, firstRun = true) {\n        for(const polygonsArray of this.polygonArrays) {\n            if (polygonsArray.length === 0) {\n                continue;\n            }\n\n            for(const polygon of polygonsArray.slice()) {\n                if (polygon.valid && polygon.intersects === intersects) {\n                    const polygonIndex = polygonsArray.indexOf(polygon);\n                    if (polygonIndex > -1) {\n                        polygon.setInvalid();\n                        polygonsArray.splice(polygonIndex, 1);\n                    }\n\n                    if (firstRun) {\n                        polygon.delete();\n                    }\n                }\n            }\n        }\n    }\n\n    isPolygonIntersecting(polygon: Polygon) {\n        if (!this.box) {\n            throw new Error('Octree has no box');\n        }\n\n        return this.box.intersectsTriangle(polygon.triangle);\n    }\n\n    protected markIntersectingPolygons(targetOctree: OctreeCSG) {\n        for(const polygonsArray of this.polygonArrays) {\n            for (const polygon of polygonsArray) {\n                polygon.intersects = targetOctree.isPolygonIntersecting(polygon);\n            }\n        }\n    }\n\n    protected resetPolygons(resetOriginal = true) {\n        for(const polygonsArray of this.polygonArrays) {\n            for (const polygon of polygonsArray) {\n                polygon.reset(resetOriginal);\n            }\n        }\n    }\n\n    protected handleIntersectingPolygons(targetOctree: OctreeCSG, useWindingNumber: boolean, targetOctreeBuffer?: Float32Array) {\n        if (useWindingNumber && !targetOctreeBuffer) {\n            throw new Error('targetOctreeBuffer must be set if using winding number');\n        }\n\n        if (this.polygons.length > 0) {\n            const polygonStack = this.polygons.filter(polygon => polygon.valid && polygon.intersects && polygon.state === PolygonState.Undecided);\n\n            let currentPolygon;\n            while ((currentPolygon = polygonStack.pop())) { // XXX assignment is on purpose\n                if (currentPolygon.state !== PolygonState.Undecided || !currentPolygon.valid) {\n                    continue;\n                }\n\n                const targetPolygons = targetOctree.getPolygonsIntersectingPolygon(currentPolygon);\n                for (const target of targetPolygons) {\n                    const splitResults = splitPolygonByPlane(currentPolygon, target.plane, this.materials);\n\n                    if (splitResults.length > 1) {\n                        for (const result of splitResults) {\n                            const polygon = result.polygon;\n                            polygon.intersects = currentPolygon.intersects;\n                            polygon.newPolygon = true;\n                            polygonStack.push(polygon);\n                        }\n\n                        this.replacePolygon(currentPolygon, splitResults.map(result => result.polygon));\n                        break;\n                    } else {\n                        const singleResult = splitResults[0];\n\n                        if (currentPolygon.id !== singleResult.polygon.id) {\n                            singleResult.polygon.intersects = currentPolygon.intersects;\n                            singleResult.polygon.newPolygon = true;\n                            polygonStack.push(singleResult.polygon);\n                            this.replacePolygon(currentPolygon, singleResult.polygon);\n                            break;\n                        } else if (singleResult.type === ReturnPolygonType.CoplanarFront || singleResult.type === ReturnPolygonType.CoplanarBack) {\n                            // XXX conversion from ReturnPolygonType to PolygonState is intentional\n                            // the values of CoplanarFront and CoplanarBack match by definition for both enums\n                            currentPolygon.setState(singleResult.type as unknown as PolygonState);\n                            currentPolygon.coplanar = true;\n                        }\n                    }\n                }\n            }\n\n            for (const polygon of this.polygons) {\n                if (!polygon.valid || !polygon.intersects) {\n                    continue;\n                }\n\n                if (!targetOctree.box) {\n                    throw new Error('Octree has no box');\n                }\n\n                let inside = false;\n                if (targetOctree.box.containsPoint(polygon.midpoint)) {\n                    if (useWindingNumber) {\n                        inside = polyInside_WindingNumber_buffer(targetOctreeBuffer as Float32Array, polygon.midpoint, polygon.coplanar);\n                    } else {\n                        const point = vec3.copy(_v2, polygon.midpoint);\n\n                        vec3.copy(_ray.origin, point);\n                        vec3.copy(_rayDirection, polygon.plane.unsafeNormal);\n                        vec3.copy(_ray.direction, polygon.plane.unsafeNormal);\n\n                        let closestInt = targetOctree.closestRayIntersection(_ray);\n                        if (closestInt && vec3.dot(_rayDirection, closestInt.polygon.plane.unsafeNormal) > 0) {\n                            inside = true;\n                        } else if (polygon.coplanar) {\n                            for (const _wP_EPS of _wP_EPS_ARR) {\n                                vec3.add(_ray.origin, point, _wP_EPS);\n                                vec3.copy(_rayDirection, polygon.plane.unsafeNormal);\n                                vec3.copy(_ray.direction, polygon.plane.unsafeNormal);\n\n                                closestInt = targetOctree.closestRayIntersection(_ray);\n                                if (closestInt && vec3.dot(_rayDirection, closestInt.polygon.plane.unsafeNormal) > 0) {\n                                    inside = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                polygon.setState(inside ? PolygonState.Inside : PolygonState.Outside);\n            }\n        }\n\n        for (const subTree of this.subTrees) {\n            subTree.handleIntersectingPolygons(targetOctree, useWindingNumber, targetOctreeBuffer);\n        }\n    }\n\n    delete(deletePolygons = true) {\n        if (this.polygons.length > 0 && deletePolygons) {\n            for (const polygon of this.polygons) {\n                polygon.delete();\n            }\n\n            this.polygons.length = 0;\n        }\n\n        if (this.replacedPolygons.length > 0 && deletePolygons) {\n            for (const polygon of this.replacedPolygons) {\n                polygon.delete();\n            }\n\n            this.replacedPolygons.length = 0;\n        }\n\n        if (this.polygonArrays) {\n            this.polygonArrays.length = 0;\n        }\n\n        if (this.subTrees.length) {\n            for (const subTree of this.subTrees) {\n                subTree.delete(deletePolygons);\n            }\n\n            this.subTrees.length = 0;\n        }\n\n        this.box = undefined;\n        this.parent = null;\n        this.level = 0;\n    }\n\n    dispose(deletePolygons = true) {\n        this.delete(deletePolygons);\n    }\n\n    private countEncodingBytes(materials: MaterialDefinitions, octreeOffsets: Map<OctreeCSG, number>, octreePolygonCounts: Map<OctreeCSG, PolygonCounts>, octreeSectionOffsets: Map<OctreeCSG, SectionOffsets>, bytesCount = 0) {\n        octreeOffsets.set(this, bytesCount);\n\n        // count space for octree header (box + flags)\n        // flags and section count\n        bytesCount += 5;\n\n        // box min+max\n        if (this.box) {\n            bytesCount += 24;\n        }\n\n        // count polygons for each material\n        const polygonCounts = new Map<number, number>();\n\n        for (const polygon of this.polygons) {\n            if (!polygon.valid || !polygon.originalValid) {\n                continue;\n            }\n\n            const materialID = polygon.shared;\n\n            if (materialID < 0 || materialID > OctreeCSG.maxMaterialID) {\n                throw new Error(`Invalid material ID (${materialID}) for polygon. Valid range: 0-${OctreeCSG.maxMaterialID}`);\n            }\n\n            const polygonCount = (polygonCounts.get(materialID) ?? 0) + 1;\n            polygonCounts.set(materialID, polygonCount);\n        }\n\n        // allocate buffer and get section offsets\n        const sectionOffsets = new Map<number, number>();\n\n        for (const [materialID, polygonCount] of polygonCounts) {\n            sectionOffsets.set(materialID, bytesCount);\n            const extraBytes = countExtraVertexBytes(materials, materialID);\n            bytesCount += 8 + polygonCount * (12 + extraBytes) * 3;\n        }\n\n        octreePolygonCounts.set(this, polygonCounts);\n        octreeSectionOffsets.set(this, sectionOffsets);\n\n        // count space for subtrees\n        const subTreeCount = this.subTrees.length;\n        if (subTreeCount > 0) {\n            if (subTreeCount !== 8) {\n                throw new Error(`Unexpected sub-tree count. Expected 8, got ${subTreeCount}`);\n            }\n\n            for (const subTree of this.subTrees) {\n                bytesCount = subTree.countEncodingBytes(materials, octreeOffsets, octreePolygonCounts, octreeSectionOffsets, bytesCount);\n            }\n        }\n\n        return bytesCount;\n    }\n\n    private encodeBytes(view: DataView, materials: MaterialDefinitions, octreeOffsets: Map<OctreeCSG, number>, octreePolygonCounts: Map<OctreeCSG, PolygonCounts>, octreeSectionOffsets: Map<OctreeCSG, SectionOffsets>) {\n        let octreeOffset = octreeOffsets.get(this) as number;\n        const polygonCounts = octreePolygonCounts.get(this) as PolygonCounts;\n        const sectionOffsets = octreeSectionOffsets.get(this) as SectionOffsets;\n\n        // populate octree header\n        // flags\n        const sectionCount = polygonCounts.size;\n        view.setUint32(octreeOffset, sectionCount);\n        octreeOffset += 4;\n\n        const hasBox = this.box !== undefined;\n        const flags = (hasBox ? 0b00000001 : 0)\n                    | ((this.subTrees.length > 0) ? 0b00000010 : 0)\n                    | (this.needsRebuild ? 0b00000100 : 0);\n\n        view.setUint8(octreeOffset, flags);\n        octreeOffset++;\n\n        if (hasBox) {\n            const box = this.box as Box3;\n            encodePointDatum(box.min, MaterialAttributeValueType.Vec3, view, octreeOffset);\n            octreeOffset += 12;\n            encodePointDatum(box.max, MaterialAttributeValueType.Vec3, view, octreeOffset);\n        }\n\n        // populate section headers\n        for (const [materialID, polygonCount] of polygonCounts) {\n            let sectionStart = sectionOffsets.get(materialID) as number;\n\n            // material ID uint32\n            view.setUint32(sectionStart, materialID);\n            sectionStart += 4;\n\n            // polygon count uint32\n            view.setUint32(sectionStart, polygonCount);\n            sectionStart += 4;\n\n            sectionOffsets.set(materialID, sectionStart);\n        }\n\n        // encode polygons\n        for (const polygon of this.polygons) {\n            // get material ID of polygon and current offset for section\n            const materialID = polygon.shared;\n            let offset = sectionOffsets.get(materialID) as number;\n\n            // encode position and extra data\n            const attributes = materials.get(materialID);\n            offset = encodePoint(polygon.vertices[0], attributes, view, offset);\n            offset = encodePoint(polygon.vertices[1], attributes, view, offset);\n            offset = encodePoint(polygon.vertices[2], attributes, view, offset);\n            sectionOffsets.set(materialID, offset);\n        }\n\n        // encode subtrees\n        for (const subTree of this.subTrees) {\n            subTree.encodeBytes(view, materials, octreeOffsets, octreePolygonCounts, octreeSectionOffsets);\n        }\n    }\n\n    encode(materials: MaterialDefinitions, transferables: Array<ArrayBuffer>): EncodedOctreeCSG {\n        // XXX: this format is streamable; you don't need the entire encoded data to\n        // start adding polygons, they can be added as they are received, as long as\n        // the messages are received sequentially. this could lead to some\n        // interesting memory optimisations in the future if we ever decide to split\n        // the buffer into smaller ones and essentially stream polygons to the\n        // octree on the worker\n\n        // buffer with all polygon data. polygons are grouped in sections, where one\n        // section contains all polygons for a particular material ID. octree packed\n        // format. octree packed format:\n        //     [bytes] : [value]\n        // 4           : sections count (uint32)\n        // 1           : flags\n        // ; flag bits:\n        // ; - bit 0: has box\n        // ; - bit 1: has subtrees\n        // ; - bit 2: needs rebuild\n        // ; - bit 3-7: unused\n        // 12          : box min (only included if box flag is set) (v3_f32)\n        // 12          : box max (only included if box flag is set) (v3_f32)\n        // (see below) : sections\n        // ?*8         : 8 subtrees' data (only included if subtrees flag is set)\n\n        // section packed format:\n        // ; let N be the polygon count\n        // ; let M be the total extra property bytes per vertex for this material\n        //    [bytes] : [value]\n        // 4          : material ID (uint32)\n        // 4          : polygon count (uint32)\n        // N*(12+M)*3 : polygon data\n        //\n        // material sections are included one after the other, in continuous memory,\n        // but not in a specific order. for example:\n        // [material 0 section data][material 2 section data][material 1 section data]...\n        //\n        // polygon data packed format:\n        // ; let X be the number of extra vertex properties\n        // [bytes] : [value]\n        // 12      : vertex A position (v3_f32)\n        // ??      : vertex A extra attribute 0 (??)\n        // ??      : vertex A extra attribute 1 (??)\n        // ...\n        // ??      : vertex A extra attribute X-1 (??)\n        // 12      : vertex B position (v3_f32)\n        // ??      : vertex B extra attribute 0 (??)\n        // ??      : vertex B extra attribute 1 (??)\n        // ...\n        // ??      : vertex B extra attribute X-1 (??)\n        // 12      : vertex C position (v3_f32)\n        // ??      : vertex C extra attribute 0 (??)\n        // ??      : vertex C extra attribute 1 (??)\n        // ...\n        // ??      : vertex C extra attribute X-1 (??)\n        //\n        // example polygon data format if the extra vertex properties were:\n        // ; attribute 0: vec3 float32 normals\n        // ; attribute 1: vec4 float32 tangents\n        // ; attribute 2: vec2 float32 uvs\n        // ; attribute 3: vec3 float32 colors\n        // [bytes] : [value]\n        // 12      : vertex A position (v3_f32)\n        // 12      : vertex A normal (extra attribute 0) (v3_f32)\n        // 16      : vertex A tangent (extra attribute 1) (v4_f32)\n        // 8       : vertex A uv (extra attribute 2) (v2_f32)\n        // 12      : vertex A color (extra attribute 3) (v3_f32)\n        // 12      : vertex B position (v3_f32)\n        // 12      : vertex B normal (extra attribute 0) (v3_f32)\n        // 16      : vertex B tangent (extra attribute 1) (v4_f32)\n        // 8       : vertex B uv (extra attribute 2) (v2_f32)\n        // 12      : vertex B color (extra attribute 3) (v3_f32)\n        // 12      : vertex C position (v3_f32)\n        // 12      : vertex C normal (extra attribute 0) (v3_f32)\n        // 16      : vertex C tangent (extra attribute 1) (v4_f32)\n        // 8       : vertex C uv (extra attribute 2) (v2_f32)\n        // 12      : vertex C color (extra attribute 3) (v3_f32)\n\n        const octreeOffsets = new Map<OctreeCSG, number>();\n        const octreePolygonCounts = new Map<OctreeCSG, PolygonCounts>();\n        const octreeSectionOffsets = new Map<OctreeCSG, SectionOffsets>();\n\n        const bytesCount = this.countEncodingBytes(materials, octreeOffsets, octreePolygonCounts, octreeSectionOffsets)\n\n        const buffer = new ArrayBuffer(bytesCount);\n        const view = new DataView(buffer);\n\n        this.encodeBytes(view, materials, octreeOffsets, octreePolygonCounts, octreeSectionOffsets);\n\n        transferables.push(buffer);\n        return buffer;\n    }\n\n    private static decodeBytes(view: DataView, byteOffset: number, byteLength: number, parent: OctreeCSG | null, materials: MaterialDefinitions): [octree: OctreeCSG, byteOffset: number] {\n        // validate remaining space for octree header\n        if (byteOffset + 5 > byteLength) {\n            throw new Error(`Invalid octree; expected octree header, but there are not enough bytes left for it`);\n        }\n\n        // make output octree\n        const octree = new OctreeCSG(materials, undefined, parent);\n\n        // decode octree header\n        const sectionsCount = view.getUint32(byteOffset);\n        byteOffset += 4;\n\n        const flags = view.getUint8(byteOffset);\n        byteOffset++;\n\n        const hasBox = (flags & 0b00000001) > 0;\n        const hasSubTrees = (flags & 0b00000010) > 0;\n        octree.needsRebuild = (flags & 0b00000100) > 0;\n\n        if (hasBox) {\n            if (byteOffset + 24 > byteLength) {\n                throw new Error(`Invalid octree; expected octree bounding box in header, but there are not enough bytes left for it`);\n            }\n\n            const min = decodePointDatum(MaterialAttributeValueType.Vec3, view, byteOffset) as vec3;\n            byteOffset += 12;\n            const max = decodePointDatum(MaterialAttributeValueType.Vec3, view, byteOffset) as vec3;\n            byteOffset += 12;\n            octree.box = new Box3(min, max);\n        }\n\n        // decode material sections\n        for (let i = 0; i < sectionsCount; i++) {\n            // check if there's space for the header\n            if (byteOffset + 6 > byteLength) {\n                throw new Error(`Invalid material section; expected material section header, but there are not enough bytes left for it`);\n            }\n\n            // parse header\n            const materialID = view.getUint32(byteOffset);\n            byteOffset += 4;\n            const polygonCount = view.getUint32(byteOffset);\n            byteOffset += 4;\n\n            // calculate polygon size for this material\n            const extraBytes = countExtraVertexBytes(materials, materialID);\n            const vertexBytes = 12 + extraBytes;\n\n            // check if there's space for the polygon data\n            const sectionBytes = polygonCount * vertexBytes * 3;\n            if (sectionBytes === 0) {\n                throw new Error(`Invalid material section; expected at least one polygon, got none`);\n            }\n\n            const sectionEnd = byteOffset + sectionBytes;\n            if (sectionEnd > byteLength) {\n                throw new Error(`Invalid material section; expected material section polygon data, but there are not enough bytes left for it`);\n            }\n\n            // parse polygons (groups of 3 vertices)\n            const attributes = materials === null ? undefined : materials.get(materialID);\n            while (byteOffset < sectionEnd) {\n                const a = decodePoint(attributes, view, byteOffset);\n                byteOffset += vertexBytes;\n                const b = decodePoint(attributes, view, byteOffset);\n                byteOffset += vertexBytes;\n                const c = decodePoint(attributes, view, byteOffset);\n                byteOffset += vertexBytes;\n\n                const polygon = new Polygon([a, b, c], materialID);\n                polygon.originalValid = true;\n                octree.polygons.push(polygon);\n            }\n        }\n\n        // decode subtrees\n        if (hasSubTrees) {\n            for (let i = 0; i < 8; i++) {\n                let subTree;\n                [subTree, byteOffset] = OctreeCSG.decodeBytes(view, byteOffset, byteLength, octree, materials);\n                octree.subTrees.push(subTree);\n            }\n        }\n\n        return [octree, byteOffset];\n    }\n\n    static decode(buffer: ArrayBuffer, materials: MaterialDefinitions): OctreeCSG {\n        const [octree, _byteOffset] = OctreeCSG.decodeBytes(\n            new DataView(buffer), 0, buffer.byteLength, null, materials\n        );\n\n        return octree;\n    }\n\n    protected getPolygonCloneCallback(cbFunc: (polygon: Polygon, triangleHasher: TriangleHasher) => unknown, triangleHasher: TriangleHasher) {\n        for (const polygonsArray of this.polygonArrays) {\n            for (const polygon of polygonsArray) {\n                if (polygon.valid) {\n                    cbFunc(polygon.clone(), triangleHasher);\n                }\n            }\n        }\n    }\n\n    protected deleteReplacedPolygons() {\n        if (this.replacedPolygons.length > 0) {\n            for (const polygon of this.replacedPolygons) {\n                polygon.delete();\n            }\n\n            this.replacedPolygons.length = 0;\n        }\n\n        for (const subTree of this.subTrees) {\n            subTree.deleteReplacedPolygons();\n        }\n    }\n\n    protected markPolygonsAsOriginal() {\n        for(const polygonsArray of this.polygonArrays) {\n            for (const polygon of polygonsArray) {\n                polygon.originalValid = true;\n            }\n        }\n    }\n\n    applyMatrix(matrix: mat4, normalMatrix?: mat3, firstRun = true, needsNormalMatrix = false) {\n        if (this.box) {\n            this.box = undefined;\n        }\n\n        if (firstRun) {\n            if (!needsNormalMatrix) {\n                for (const attributes of this.materials.values()) {\n                    if (attributes) {\n                        for (const attribute of attributes) {\n                            if (attribute.transformable === MaterialAttributeTransform.Normal) {\n                                needsNormalMatrix = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (needsNormalMatrix) {\n                        break;\n                    }\n                }\n            }\n\n            if (needsNormalMatrix && !normalMatrix) {\n                normalMatrix = mat3.normalFromMat4(tmpm3, matrix);\n            }\n        }\n\n        for (const polygon of this.polygons) {\n            if (polygon.valid) {\n                polygon.applyMatrixNoAuto(this.materials.get(polygon.shared), matrix, normalMatrix);\n            }\n        }\n\n        for (const subTree of this.subTrees) {\n            subTree.applyMatrix(matrix, normalMatrix, false, needsNormalMatrix);\n        }\n\n        if (firstRun) {\n            this.processTree();\n        }\n    }\n\n    setPolygonIndex(index: number) {\n        if (index === undefined) {\n            return;\n        }\n\n        for(const polygonsArray of this.polygonArrays) {\n            for (const polygon of polygonsArray) {\n                polygon.shared = index;\n            }\n        }\n    }\n\n    // utils from OctreeCSG.extended.js\n    getTriangles(triangles: Triangle[] = []) {\n        for (const polygon of this.getPolygons()) {\n            triangles.push(polygon.triangle)\n        }\n\n        return triangles;\n    }\n\n    getRayTriangles(ray: Ray, triangles: Triangle[] = []) {\n        for (const polygon of this.getRayPolygons(ray)) {\n            triangles.push(polygon.triangle)\n        }\n\n        return triangles;\n    }\n\n    /*\n    Union:\n    1. Delete all polygons in A that are:\n        a. inside and coplanar-back\n        b. inside\n    2. Delete all polygons in B that are:\n        a. inside and coplanar-back\n        b. inside and coplanar-front\n        c. inside\n    */\n    static union(octreeA: OctreeCSG, octreeB: OctreeCSG, options?: OctreeCSGOptions) {\n        // merge material definitions of both octrees\n        const newMatDefs = mergeTwoMaterials(octreeA.materials, octreeB.materials);\n\n        // build octrees if necessary\n        if (octreeA.needsRebuild || !octreeA.box) {\n            octreeA.buildTree(options?.maxLevel, options?.polygonsPerTree);\n        }\n\n        if (octreeB.needsRebuild || !octreeB.box) {\n            octreeB.buildTree(options?.maxLevel, options?.polygonsPerTree);\n        }\n\n        const octree = new OctreeCSG(newMatDefs);\n        const triangleHasher = new TriangleHasher();\n\n        if ((octreeA.box as Box3).intersectsBox(octreeB.box as Box3)) {\n            octreeA.resetPolygons(false);\n            octreeB.resetPolygons(false);\n\n            octreeA.markIntersectingPolygons(octreeB);\n            octreeB.markIntersectingPolygons(octreeA);\n\n            OctreeCSG.handleIntersectingOctrees(octreeA, octreeB, options?.useWindingNumber ?? defaultUseWindingNumber);\n            octreeA.deleteReplacedPolygons();\n            octreeB.deleteReplacedPolygons();\n\n            octreeA.deletePolygonsByStateRules(CSG_Rules.union.a);\n            octreeB.deletePolygonsByStateRules(CSG_Rules.union.b);\n        }\n\n        octreeA.getPolygonCloneCallback(octree.addPolygon.bind(octree), triangleHasher);\n        octreeB.getPolygonCloneCallback(octree.addPolygon.bind(octree), triangleHasher);\n\n        triangleHasher.clear();\n\n        octree.markPolygonsAsOriginal();\n\n        return octree;\n    }\n\n    /*\n    Subtract:\n    1. Delete all polygons in A that are:\n        a. inside and coplanar-back\n        b. inside and coplanar-front\n        c. inside\n    2. Delete all polygons in B that are:\n        a. outside and coplanar-back\n        b. outside and coplanar-front\n        c. inside and coplanar-front\n        d. outside\n    */\n    static subtract(octreeA: OctreeCSG, octreeB: OctreeCSG, options?: OctreeCSGOptions) {\n        // merge material definitions of both octrees\n        const newMatDefs = mergeTwoMaterials(octreeA.materials, octreeB.materials);\n\n        // build octrees if necessary\n        if (octreeA.needsRebuild || !octreeA.box) {\n            octreeA.buildTree(options?.maxLevel, options?.polygonsPerTree);\n        }\n\n        if (octreeB.needsRebuild || !octreeB.box) {\n            octreeB.buildTree(options?.maxLevel, options?.polygonsPerTree);\n        }\n\n        const octree = new OctreeCSG(newMatDefs);\n        const triangleHasher = new TriangleHasher();\n\n        if ((octreeA.box as Box3).intersectsBox(octreeB.box as Box3)) {\n            octreeA.resetPolygons(false);\n            octreeB.resetPolygons(false);\n            octreeA.markIntersectingPolygons(octreeB);\n            octreeB.markIntersectingPolygons(octreeA);\n\n\n            OctreeCSG.handleIntersectingOctrees(octreeA, octreeB, options?.useWindingNumber ?? defaultUseWindingNumber);\n            octreeA.deleteReplacedPolygons();\n            octreeB.deleteReplacedPolygons();\n\n            octreeA.deletePolygonsByStateRules(CSG_Rules.subtract.a);\n            octreeB.deletePolygonsByStateRules(CSG_Rules.subtract.b);\n\n\n            octreeB.deletePolygonsByIntersection(false);\n\n            octreeB.invert();\n\n            octreeA.getPolygonCloneCallback(octree.addPolygon.bind(octree), triangleHasher);\n            octreeB.getPolygonCloneCallback(octree.addPolygon.bind(octree), triangleHasher);\n        }\n        else {\n            octreeA.getPolygonCloneCallback(octree.addPolygon.bind(octree), triangleHasher);\n        }\n\n        triangleHasher.clear();\n\n        octree.markPolygonsAsOriginal();\n\n        return octree;\n    }\n\n    /*\n    Intersect:\n    1. Delete all polygons in A that are:\n        a. inside and coplanar-back\n        b. outside and coplanar-front\n        c. outside and coplanar-back\n        d. outside\n    2. Delete all polygons in B that are:\n        a. inside and coplanar-front\n        b. inside and coplanar-back\n        c. outside and coplanar-front\n        d. outside and coplanar-back\n        e. outside\n    */\n    static intersect(octreeA: OctreeCSG, octreeB: OctreeCSG, options?: OctreeCSGOptions) {\n        // merge material definitions of both octrees\n        const newMatDefs = mergeTwoMaterials(octreeA.materials, octreeB.materials);\n\n        // build octrees if necessary\n        if (octreeA.needsRebuild || !octreeA.box) {\n            octreeA.buildTree(options?.maxLevel, options?.polygonsPerTree);\n        }\n\n        if (octreeB.needsRebuild || !octreeB.box) {\n            octreeB.buildTree(options?.maxLevel, options?.polygonsPerTree);\n        }\n\n        const octree = new OctreeCSG(newMatDefs);\n        const triangleHasher = new TriangleHasher();\n\n        if ((octreeA.box as Box3).intersectsBox(octreeB.box as Box3)) {\n            octreeA.resetPolygons(false);\n            octreeB.resetPolygons(false);\n\n            octreeA.markIntersectingPolygons(octreeB);\n            octreeB.markIntersectingPolygons(octreeA);\n\n            OctreeCSG.handleIntersectingOctrees(octreeA, octreeB, options?.useWindingNumber ?? defaultUseWindingNumber);\n            octreeA.deleteReplacedPolygons();\n            octreeB.deleteReplacedPolygons();\n\n            octreeA.deletePolygonsByStateRules(CSG_Rules.intersect.a);\n            octreeB.deletePolygonsByStateRules(CSG_Rules.intersect.b);\n\n            octreeA.deletePolygonsByIntersection(false);\n            octreeB.deletePolygonsByIntersection(false);\n\n            octreeA.getPolygonCloneCallback(octree.addPolygon.bind(octree), triangleHasher);\n            octreeB.getPolygonCloneCallback(octree.addPolygon.bind(octree), triangleHasher);\n        }\n\n        triangleHasher.clear();\n\n        octree.markPolygonsAsOriginal();\n\n        return octree;\n    }\n\n    static unionArray(objArr: OctreeCSG[], options?: OctreeCSGOptions) {\n        return arrayOperation(OctreeCSG.union, objArr, options);\n    }\n\n    static subtractArray(objArr: OctreeCSG[], options?: OctreeCSGOptions) {\n        // XXX subtraction is a special case; the leftmost element is subtracted\n        // with everything from the right, which means that:\n        // subtractArray(0 ... N) = subtract(0, union(1 ... N))\n        const objArrCount = objArr.length;\n        if (objArrCount === 0) {\n            throw new Error('Unable to find any result octree');\n        } else if (objArrCount === 1) {\n            return objArr[0];\n        } else if (objArrCount === 2) {\n            return OctreeCSG.subtract(objArr[0], objArr[1], options);\n        } else {\n            return OctreeCSG.subtract(objArr[0], OctreeCSG.unionArray(objArr.slice(1), options), options);\n        }\n    }\n\n    static intersectArray(objArr: OctreeCSG[], options?: OctreeCSGOptions) {\n        return arrayOperation(OctreeCSG.intersect, objArr, options);\n    }\n\n    static operation(obj: OctreeCSGObject, options?: OctreeCSGOptions) {\n        let resultOctree: OctreeCSG;\n\n        switch (obj.op) {\n            case 'union':\n            case 'subtract':\n            case 'intersect':\n            {\n                const octreeA = handleObjectForOp(obj.objA, options);\n                const octreeB = handleObjectForOp(obj.objB, options);\n\n                switch (obj.op) {\n                    case 'union':\n                        resultOctree = OctreeCSG.union(octreeA, octreeB, options);\n                        break;\n                    case 'subtract':\n                        resultOctree = OctreeCSG.subtract(octreeA, octreeB, options);\n                        break;\n                    default:\n                        resultOctree = OctreeCSG.intersect(octreeA, octreeB, options);\n                }\n\n                disposeOctree(octreeA, octreeB);\n                break;\n            }\n            case 'unionArray':\n            case 'subtractArray':\n            case 'intersectArray':\n            {\n                const octrees = new Array<OctreeCSG>();\n\n                for (const octreeObj of obj.objs) {\n                    octrees.push(handleObjectForOp(octreeObj, options));\n                }\n\n                switch (obj.op) {\n                    case 'unionArray':\n                        resultOctree = OctreeCSG.unionArray(octrees, options);\n                        break;\n                    case 'subtractArray':\n                        resultOctree = OctreeCSG.subtractArray(octrees, options);\n                        break;\n                    default:\n                        resultOctree = OctreeCSG.intersectArray(octrees, options);\n                }\n\n                disposeOctree(...octrees);\n                break;\n            }\n            default:\n                throw new Error(`Unknown operation: ${(obj as {op: unknown}).op}`);\n        }\n\n        return resultOctree;\n    }\n\n    static async = {\n        union(octreeA: OctreeCSG, octreeB: OctreeCSG, options?: AsyncOctreeCSGOptions): Promise<OctreeCSG> {\n            const mergedMatDef = mergeTwoMaterials(octreeA.materials, octreeB.materials);\n            return asyncOperation('union', OctreeCSG.union, octreeA, octreeB, mergedMatDef, options);\n        },\n\n        subtract(octreeA: OctreeCSG, octreeB: OctreeCSG, options?: AsyncOctreeCSGOptions): Promise<OctreeCSG> {\n            const mergedMatDef = mergeTwoMaterials(octreeA.materials, octreeB.materials);\n            return asyncOperation('subtract', OctreeCSG.subtract, octreeA, octreeB, mergedMatDef, options);\n        },\n\n        intersect(octreeA: OctreeCSG, octreeB: OctreeCSG, options?: AsyncOctreeCSGOptions): Promise<OctreeCSG> {\n            const mergedMatDef = mergeTwoMaterials(octreeA.materials, octreeB.materials);\n            return asyncOperation('intersect', OctreeCSG.intersect, octreeA, octreeB, mergedMatDef, options);\n        },\n\n        unionArray(objArr: OctreeCSG[], options?: AsyncOctreeCSGOptions): Promise<OctreeCSG> {\n            return asyncArrayOperation(OctreeCSG.async.union, OctreeCSG.async.unionArray, objArr, options);\n        },\n\n        async subtractArray(objArr: OctreeCSG[], options?: AsyncOctreeCSGOptions): Promise<OctreeCSG> {\n            // XXX subtraction is a special case; the leftmost element is\n            // subtracted with everything from the right, which means that:\n            // subtractArray(0 ... N) = subtract(0, union(1 ... N))\n            const objArrCount = objArr.length;\n            if (objArrCount === 0) {\n                throw new Error('Unable to find any result octree');\n            } else if (objArrCount === 1) {\n                return objArr[0];\n            } else if (objArrCount === 2) {\n                return await OctreeCSG.async.subtract(objArr[0], objArr[1], options);\n            } else {\n                return await OctreeCSG.async.subtract(objArr[0], await OctreeCSG.async.unionArray(objArr.slice(1), options), options);\n            }\n        },\n\n        intersectArray(objArr: OctreeCSG[], options?: AsyncOctreeCSGOptions): Promise<OctreeCSG> {\n            return asyncArrayOperation(OctreeCSG.async.intersect, OctreeCSG.async.intersectArray, objArr, options);\n        },\n\n        operation(obj: OctreeCSGObject, options?: AsyncOctreeCSGOptions): Promise<OctreeCSG> {\n            return new Promise((resolve, reject) => {\n                try {\n                    switch (obj.op) {\n                        case 'union':\n                        case 'subtract':\n                        case 'intersect':\n                        {\n                            let octreeA: OctreeCSG, octreeB: OctreeCSG;\n                            const promises = [];\n                            if (obj.objA) {\n                                promises.push(handleObjectForOp_async(obj.objA, 0, options));\n                            }\n\n                            if (obj.objB) {\n                                promises.push(handleObjectForOp_async(obj.objB, 1, options));\n                            }\n\n                            Promise.allSettled(promises).then(results => {\n                                for (const result of results) {\n                                    if (result.status === 'fulfilled') {\n                                        const [csg, objIndex] = result.value;\n                                        if (objIndex === 0) {\n                                            octreeA = csg;\n                                        } else if (objIndex === 1) {\n                                            octreeB = csg;\n                                        }\n                                    }\n                                }\n\n                                let resultPromise;\n                                switch (obj.op) {\n                                    case 'union':\n                                        resultPromise = OctreeCSG.async.union(octreeA, octreeB, options);\n                                        break;\n                                    case 'subtract':\n                                        resultPromise = OctreeCSG.async.subtract(octreeA, octreeB, options);\n                                        break;\n                                    default:\n                                        resultPromise = OctreeCSG.async.intersect(octreeA, octreeB, options);\n                                }\n\n                                resultPromise.then(resultOctree => {\n                                    resolve(resultOctree);\n                                    disposeOctree(octreeA, octreeB);\n                                }).catch(e => reject(e));\n                            });\n                            break;\n                        }\n                        case 'unionArray':\n                        case 'subtractArray':\n                        case 'intersectArray':\n                        {\n                            const octrees = new Array<OctreeCSG>();\n\n                            for (const octreeObj of obj.objs) {\n                                octrees.push(handleObjectForOp(octreeObj, options));\n                            }\n\n                            let promise;\n                            switch (obj.op) {\n                                case 'unionArray':\n                                    promise = OctreeCSG.async.unionArray(octrees, options);\n                                    break;\n                                case 'subtractArray':\n                                    promise = OctreeCSG.async.subtractArray(octrees, options);\n                                    break;\n                                default:\n                                    promise = OctreeCSG.async.intersectArray(octrees, options);\n                            }\n\n                            disposeOctree(...octrees);\n\n                            promise.then(resultOctree => resolve(resultOctree));\n                            break;\n                        }\n                        default:\n                            throw new Error(`Unknown operation: ${(obj as {op: unknown}).op}`);\n                    }\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        }\n    }\n\n    protected static handleIntersectingOctrees(octreeA: OctreeCSG, octreeB: OctreeCSG, useWindingNumber: boolean, bothOctrees = true, octreeA_buffer?: Float32Array, octreeB_buffer?: Float32Array) {\n        if (useWindingNumber) {\n            if (bothOctrees && !octreeA_buffer) {\n                octreeA_buffer = prepareTriangleBuffer(octreeA.getPolygons());\n            }\n\n            if (!octreeB_buffer) {\n                octreeB_buffer = prepareTriangleBuffer(octreeB.getPolygons());\n            }\n        }\n\n        octreeA.handleIntersectingPolygons(octreeB, useWindingNumber, octreeB_buffer);\n\n        if (bothOctrees) {\n            octreeB.handleIntersectingPolygons(octreeA, useWindingNumber, octreeA_buffer);\n        }\n\n        if (octreeA_buffer !== undefined) {\n            octreeA_buffer = undefined;\n            octreeB_buffer = undefined;\n        }\n    }\n}\n\nfunction raycastIntersectAscSort(a: RayIntersect, b: RayIntersect) {\n    return a.distance - b.distance;\n}\n\nfunction handleObjectForOp(obj: OctreeCSG | OctreeCSGObject, options?: OctreeCSGOptions) {\n    if (obj instanceof OctreeCSG) {\n        return obj;\n    } else if (obj.op) {\n        return OctreeCSG.operation(obj, options);\n    } else {\n        throw new Error('Invalid OctreeCSG operation object');\n    }\n}\n\nfunction handleObjectForOp_async(obj: OctreeCSG | OctreeCSGObject, objIndex: number, options?: AsyncOctreeCSGOptions): Promise<[csg: OctreeCSG, objIndex: number]> {\n    return new Promise((resolve, reject) => {\n        try {\n            if (obj instanceof OctreeCSG) {\n                resolve([obj, objIndex]);\n            } else if (obj.op) {\n                OctreeCSG.async.operation(obj, options).then(returnObj => {\n                    resolve([returnObj, objIndex]);\n                });\n            } else {\n                throw new Error('Invalid OctreeCSG operation object');\n            }\n        }\n        catch (e) {\n            reject(e);\n        }\n    });\n}\n\nfunction disposeOctree(...octrees: OctreeCSG[]) {\n    for (const octree of octrees) {\n        octree.delete();\n    }\n}\n\nfunction handlePolygonArrayIntersections(targetPolygon: Polygon, outputPolygons: Polygon[], polygons: Polygon[]) {\n    for (const polygon of polygons) {\n        if (polygon.originalValid && polygon.valid && polygon.intersects && checkTrianglesIntersection(targetPolygon.triangle, polygon.triangle)) {\n            outputPolygons.push(polygon);\n        }\n    }\n}\n\nfunction arrayOperation(callback: (octreeA: OctreeCSG, octreeB: OctreeCSG, options?: OctreeCSGOptions) => OctreeCSG, objArr: OctreeCSG[], options?: OctreeCSGOptions) {\n    let octreesArray = objArr.slice();\n\n    // XXX minimise the octree bounding box after each operation by applying an\n    // operation to pairs of octrees instead of applying it to the same octree\n    // over and over again (which results in a single octree with a giant\n    // bounding box), and trying to keep the same order. this works best when\n    // each octree in the array is ordered by their position\n    while (octreesArray.length > 1) {\n        const octreeCount = octreesArray.length;\n        const nextOctreeArray = new Array<OctreeCSG>();\n\n        // process pairs\n        let i = 0;\n        for (; i + 1 < octreeCount; i += 2) {\n            const octreeA = octreesArray[i];\n            const octreeB = octreesArray[i + 1];\n            const resultOctree = callback(octreeA, octreeB, options);\n            disposeOctree(octreeA, octreeB);\n            nextOctreeArray.push(resultOctree);\n        }\n\n        // add leftover octrees\n        if (i < octreeCount) {\n            nextOctreeArray.push(octreesArray[i]);\n        }\n\n        // next iteration array\n        octreesArray = nextOctreeArray;\n    }\n\n    if (octreesArray.length === 0) {\n        throw new Error('Unable to find any result octree');\n    }\n\n    return octreesArray[0];\n}\n\nasync function asyncOperation(op: 'union' | 'subtract' | 'intersect', syncCallback: (octreeA: OctreeCSG, octreeB: OctreeCSG, options?: AsyncOctreeCSGOptions) => OctreeCSG, octreeA: OctreeCSG, octreeB: OctreeCSG, materials: MaterialDefinitions, options?: AsyncOctreeCSGOptions): Promise<OctreeCSG> {\n    // try using async job dispatcher\n    if (globalThis.globalOctreeCSGJobDispatcher) {\n        try {\n            return await globalThis.globalOctreeCSGJobDispatcher.dispatch({\n                op,\n                objA: octreeA,\n                objB: octreeB,\n            }, materials, options);\n        } catch(error) {\n            let rethrow = true;\n            if (error instanceof JobError && error.failReason === JobFailReason.WorkerCreationFailure) {\n                console.warn('Queued job failed due to worker creation failure. Retrying synchronously');\n                rethrow = false;\n            }\n\n            if (rethrow) {\n                throw error;\n            }\n        }\n    }\n\n    // fall back to synchronous implementation\n    const result = syncCallback(octreeA, octreeB, options);\n    disposeOctree(octreeA, octreeB);\n    return result;\n}\n\nfunction asyncArrayOperation(singleCallback: (octreeA: OctreeCSG, octreeB: OctreeCSG, options?: AsyncOctreeCSGOptions) => Promise<OctreeCSG>, arrayCallback: (objArr: OctreeCSG[], options?: AsyncOctreeCSGOptions) => Promise<OctreeCSG>, objArr: OctreeCSG[], options?: AsyncOctreeCSGOptions): Promise<OctreeCSG> {\n    const batchSize = options?.batchSize ?? defaultBatchSize;\n\n    return new Promise((resolve, reject) => {\n        try {\n            const usingBatches = batchSize > 4 && batchSize < objArr.length;\n            let mainOctree: OctreeCSG;\n            let mainOctreeUsed = false;\n            const promises = [];\n\n            if (usingBatches) {\n                const batches = [];\n                let currentIndex = 0;\n\n                while (currentIndex < objArr.length) {\n                    batches.push(objArr.slice(currentIndex, currentIndex + batchSize));\n                    currentIndex += batchSize;\n                }\n\n                let batch;\n                while ((batch = batches.shift())) { // XXX assignment is on purpose\n                    promises.push(arrayCallback(batch, options));\n                }\n\n                mainOctreeUsed = true;\n                objArr.length = 0;\n            } else {\n                const octreesArray: OctreeCSG[] = [];\n                const objArrLen = objArr.length;\n                for (let i = 0; i < objArrLen; i++) {\n                    octreesArray.push(objArr[i]);\n                }\n\n                mainOctree = octreesArray.shift() as OctreeCSG;\n\n                let leftOverOctree;\n                const octreesArrayLen = octreesArray.length;\n                for (let i = 0; i < octreesArrayLen; i += 2) {\n                    if (i + 1 >= octreesArrayLen) {\n                        leftOverOctree = octreesArray[i];\n                        break;\n                    }\n\n                    promises.push(singleCallback(octreesArray[i], octreesArray[i + 1], options));\n                }\n\n                if (leftOverOctree) {\n                    promises.push(singleCallback(mainOctree, leftOverOctree, options));\n                    mainOctreeUsed = true;\n                }\n            }\n\n            Promise.allSettled(promises).then(results => {\n                const octrees = new Array<OctreeCSG>();\n\n                for (const result of results) {\n                    if (result.status === 'fulfilled') {\n                        octrees.push(result.value);\n                    }\n                }\n\n                if (!mainOctreeUsed) {\n                    octrees.unshift(mainOctree);\n                }\n\n                if (octrees.length <= 0) {\n                    reject('Unable to find any result octree');\n                } else if (octrees.length === 1) {\n                    resolve(octrees[0]);\n                } else if (octrees.length > 3) {\n                    arrayCallback(octrees, options).then(result => {\n                        resolve(result);\n                    }).catch(e => reject(e));\n                } else {\n                    singleCallback(octrees[0], octrees[1], options).then(result => {\n                        if (octrees.length === 3) {\n                            singleCallback(result, octrees[2], options).then(innerResult => {\n                                resolve(innerResult);\n                            }).catch(e => reject(e));\n                        } else {\n                            resolve(result);\n                        }\n                    }).catch(e => reject(e));\n                }\n            });\n        } catch (e) {\n            reject(e);\n        }\n    });\n}", "import { MaterialAttributeValueType } from '../base/MaterialDefinition';\n\nexport default function getVertexPropertyTypeSize(propertyType: MaterialAttributeValueType) {\n    switch (propertyType) {\n        case MaterialAttributeValueType.Number:\n            return 4;\n        case MaterialAttributeValueType.Vec2:\n            return 8;\n        case MaterialAttributeValueType.Vec3:\n            return 12;\n        case MaterialAttributeValueType.Vec4:\n            return 16;\n    }\n\n    throw new Error(`Unknown vertex property type ID (${propertyType})`);\n}", "import { MaterialAttributes, MaterialAttributeValueType } from '../base/MaterialDefinition';\nimport getVertexPropertyTypeSize from './get-vertex-property-type-size';\n\nimport type Vertex from '../math/Vertex';\n\nexport function encodePointDatum(datum: number[] | Float32Array | number, datumType: MaterialAttributeValueType, view: DataView, idx: number) {\n    // XXX missing data will be replaced with zeros\n    switch (datumType) {\n        case MaterialAttributeValueType.Number:\n            view.setFloat32(idx, datum as number);\n            break;\n        case MaterialAttributeValueType.Vec2:\n        {\n            const datumVec = datum as number[] | Float32Array;\n            view.setFloat32(idx, datumVec[0]);\n            idx += 4;\n            view.setFloat32(idx, datumVec[1]);\n            break;\n        }\n        case MaterialAttributeValueType.Vec3:\n        {\n            const datumVec = datum as number[] | Float32Array;\n            view.setFloat32(idx, datumVec[0]);\n            idx += 4;\n            view.setFloat32(idx, datumVec[1]);\n            idx += 4;\n            view.setFloat32(idx, datumVec[2]);\n            break;\n        }\n        case MaterialAttributeValueType.Vec4:\n        {\n            const datumVec = datum as number[] | Float32Array;\n            view.setFloat32(idx, datumVec[0]);\n            idx += 4;\n            view.setFloat32(idx, datumVec[1]);\n            idx += 4;\n            view.setFloat32(idx, datumVec[2]);\n            idx += 4;\n            view.setFloat32(idx, datumVec[3]);\n            break;\n        }\n    }\n}\n\nexport function encodePoint(point: Vertex, attributes: MaterialAttributes | undefined, view: DataView, idx: number): number {\n    // encode position\n    encodePointDatum(point.pos, MaterialAttributeValueType.Vec3, view, idx);\n    idx += 12;\n\n    // encode per-material extra vertex data\n    if (attributes) {\n        let idxExtra = 0;\n        for (const attribute of attributes) {\n            if (point.extra) {\n                encodePointDatum(point.extra[idxExtra++], attribute.valueType, view, idx);\n            }\n\n            idx += getVertexPropertyTypeSize(attribute.valueType);\n        }\n    }\n\n    return idx;\n}", "import type Triangle from '../math/Triangle';\n\nexport default class TriangleHasher {\n    buckets = new Map<number, Triangle[]>;\n    // buckets = new Set<string>();\n\n    isUnique(triangle: Triangle) {\n        const hash = triangle.hash;\n        let arr = this.buckets.get(hash);\n\n        if (arr) {\n            for (const other of arr) {\n                if (triangle.equals(other)) {\n                    return false;\n                }\n            }\n\n            arr.push(triangle);\n        } else {\n            arr = [triangle];\n        }\n\n        return true;\n\n        // const hash1 = `{${triangle.a[0]},${triangle.a[1]},${triangle.a[2]}}-{${triangle.b[0]},${triangle.b[1]},${triangle.b[2]}}-{${triangle.c[0]},${triangle.c[1]},${triangle.c[2]}}`;\n\n        // if (this.buckets.has(hash1)) {\n        //     return false;\n        // } else {\n        //     this.buckets.add(hash1);\n        //     return true;\n        // }\n    }\n\n    clear() {\n        this.buckets.clear();\n    }\n}", "import { PolygonState } from '../math/Polygon';\n\ntype CSGRule = {\n    array: true,\n    rule: PolygonState[]\n} | {\n    array: false,\n    rule: PolygonState\n};\n\nexport type CSGRulesArray = CSGRule[];\n\nexport const CSG_Rules = {\n    union: {\n        a: <CSGRulesArray>[\n            {\n                array: true,\n                rule: [PolygonState.Inside, PolygonState.CoplanarBack]\n            },\n            {\n                array: false,\n                rule: PolygonState.Inside\n            }\n        ],\n        b: <CSGRulesArray>[\n            {\n                array: true,\n                rule: [PolygonState.Inside, PolygonState.CoplanarBack]\n            },\n            {\n                array: true,\n                rule: [PolygonState.Inside, PolygonState.CoplanarFront]\n            },\n            {\n                array: false,\n                rule: PolygonState.Inside\n            }\n        ]\n    },\n    subtract: {\n        a: <CSGRulesArray>[\n            {\n                array: true,\n                rule: [PolygonState.Inside, PolygonState.CoplanarBack]\n            },\n            {\n                array: true,\n                rule: [PolygonState.Inside, PolygonState.CoplanarFront]\n            },\n            {\n                array: false,\n                rule: PolygonState.Inside\n            }\n        ],\n        b: <CSGRulesArray>[\n            {\n                array: true,\n                rule: [PolygonState.Outside, PolygonState.CoplanarBack]\n            },\n            {\n                array: true,\n                rule: [PolygonState.Outside, PolygonState.CoplanarFront]\n            },\n            {\n                array: true,\n                rule: [PolygonState.Inside, PolygonState.CoplanarFront]\n            },\n            {\n                array: false,\n                rule: PolygonState.Outside\n            }\n        ]\n    },\n    intersect: {\n        a: <CSGRulesArray>[\n            {\n                array: true,\n                rule: [PolygonState.Inside, PolygonState.CoplanarBack]\n            },\n            {\n                array: true,\n                rule: [PolygonState.Outside, PolygonState.CoplanarFront]\n            },\n            {\n                array: true,\n                rule: [PolygonState.Outside, PolygonState.CoplanarBack]\n            },\n            {\n                array: false,\n                rule: PolygonState.Outside\n            }\n        ],\n        b: <CSGRulesArray>[\n            {\n                array: true,\n                rule: [PolygonState.Inside, PolygonState.CoplanarFront]\n            },\n            {\n                array: true,\n                rule: [PolygonState.Inside, PolygonState.CoplanarBack]\n            },\n            {\n                array: true,\n                rule: [PolygonState.Outside, PolygonState.CoplanarFront]\n            },\n            {\n                array: true,\n                rule: [PolygonState.Outside, PolygonState.CoplanarBack]\n            },\n            {\n                array: false,\n                rule: PolygonState.Outside\n            }\n        ]\n    }\n};", "import getVertexPropertyTypeSize from './get-vertex-property-type-size';\n\nimport type { MaterialDefinitions } from '../base/MaterialDefinition';\n\nexport default function countExtraVertexBytes(materials: MaterialDefinitions | null, materialID: number) {\n    let extraBytes = 0;\n\n    if (materials) {\n        const attributes = materials.get(materialID);\n        if (attributes) {\n            for (const attribute of attributes) {\n                extraBytes += getVertexPropertyTypeSize(attribute.valueType);\n            }\n        }\n    }\n\n    return extraBytes;\n}", "import { mat3, mat4, vec2, vec3, vec4 } from 'gl-matrix';\nimport { MaterialAttributes, MaterialAttributeValue, MaterialAttributeValueType, MaterialAttributeTransform } from '../base/MaterialDefinition';\nimport lerp from './lerp';\n\nexport default class Vertex {\n    constructor(public pos: vec3, public extra?: Array<MaterialAttributeValue>) {}\n\n    clone() {\n        let extraClone = undefined;\n\n        if (this.extra) {\n            const extraCount = this.extra.length;\n            extraClone = new Array(extraCount);\n\n            for (let i = 0; i < extraCount; i++) {\n                const val = this.extra[i];\n                if (typeof val === 'number') {\n                    extraClone[i] = val;\n                } else {\n                    extraClone[i] = val.slice();\n                }\n            }\n        }\n\n        return new Vertex(vec3.clone(this.pos), extraClone);\n    }\n\n    // Invert all orientation-specific data (e.g. vertex normal). Called when\n    // the orientation of a polygon is flipped.\n    flip(attributes: MaterialAttributes | undefined) {\n        if (attributes && this.extra) {\n            const extraCount = this.extra.length;\n            for (let i = 0; i < extraCount; i++) {\n                const attribute = attributes[i];\n\n                if (attribute.flippable) {\n                    switch (attribute.valueType) {\n                        case MaterialAttributeValueType.Number:\n                            this.extra[i] = -this.extra[i];\n                            break;\n                        case MaterialAttributeValueType.Vec2:\n                            vec2.negate(this.extra[i] as vec2, this.extra[i] as vec2);\n                            break;\n                        case MaterialAttributeValueType.Vec3:\n                            vec3.negate(this.extra[i] as vec3, this.extra[i] as vec3);\n                            break;\n                        case MaterialAttributeValueType.Vec4:\n                            vec4.negate(this.extra[i] as vec4, this.extra[i] as vec4);\n                            break;\n                    }\n                }\n            }\n        }\n    }\n\n    applyMatrix(matrix: mat4, normalMatrix: mat3 | undefined, attributes: MaterialAttributes | undefined) {\n        if (attributes && this.extra) {\n            const extraCount = this.extra.length;\n            for (let i = 0; i < extraCount; i++) {\n                const attribute = attributes[i];\n                const transformMode = attribute.transformable;\n                if (transformMode !== null) {\n                    if (transformMode === MaterialAttributeTransform.Model) {\n                        switch (attribute.valueType) {\n                            case MaterialAttributeValueType.Vec3:\n                                vec3.transformMat4(this.extra[i] as vec3, this.extra[i] as vec3, matrix);\n                                break;\n                            case MaterialAttributeValueType.Vec4:\n                                vec4.transformMat4(this.extra[i] as vec4, this.extra[i] as vec4, matrix);\n                                break;\n                            default:\n                                throw new Error('Can\\'t transform this vertex attribute with a model matrix; must be a vec3 or vec4');\n                        }\n                    } else {\n                        if (attribute.valueType !== MaterialAttributeValueType.Vec3) {\n                            throw new Error('Can\\'t transform this vertex attribute with a normal matrix; must be a vec3');\n                        } else if (normalMatrix === undefined) {\n                            throw new Error('Missing normal matrix');\n                        }\n\n                        const out = this.extra[i] as vec3;\n                        vec3.transformMat3(out, out, normalMatrix);\n                        vec3.normalize(out, out);\n                    }\n                }\n            }\n        }\n    }\n\n    delete() {\n        (this.pos as unknown) = undefined;\n        this.extra = undefined;\n    }\n\n    // Create a new vertex between this vertex and `other` by linearly\n    // interpolating all properties using a parameter of `t`. Additional\n    // properties in the `extra` field are also interpolated, but the vertices\n    // being interpolated must have the same additional properties in the same\n    // order\n    interpolate(other: Vertex, t: number, attributes: MaterialAttributes | undefined) {\n        let extra = undefined;\n\n        if (attributes && this.extra) {\n            const extraCount = this.extra.length;\n            extra = new Array(extraCount);\n\n            for (let i = 0; i < extraCount; i++) {\n                const val = this.extra[i];\n                const otherVal = (other.extra as Array<MaterialAttributeValue>)[i];\n                const attribute = attributes[i];\n\n                switch (attribute.valueType) {\n                    case MaterialAttributeValueType.Number:\n                        extra[i] = lerp(val as number, otherVal as number, t);\n                        break;\n                    case MaterialAttributeValueType.Vec2:\n                        extra[i] = vec2.lerp(vec2.create(), val as vec2, otherVal as vec2, t);\n                        break;\n                    case MaterialAttributeValueType.Vec3:\n                        extra[i] = vec3.lerp(vec3.create(), val as vec3, otherVal as vec3, t);\n                        break;\n                    case MaterialAttributeValueType.Vec4:\n                        extra[i] = vec4.lerp(vec4.create(), val as vec4, otherVal as vec4, t);\n                        break;\n                }\n            }\n        }\n\n        return new Vertex(\n            vec3.lerp(vec3.create(), this.pos, other.pos, t),\n            extra,\n        );\n    }\n}", "export default function lerp(a: number, b: number, t: number): number {\n    return a + t * (b - a);\n}", "import { MaterialAttributeValueType } from '../base/MaterialDefinition';\nimport Vertex from '../math/Vertex';\nimport getVertexPropertyTypeSize from './get-vertex-property-type-size';\nimport { vec2, vec3, vec4 } from 'gl-matrix';\n\nimport type { MaterialAttributes } from '../base/MaterialDefinition';\n\nexport function decodePointDatum(datumType: MaterialAttributeValueType, view: DataView, idx: number): number | vec2 | vec3 | vec4 {\n    switch (datumType) {\n        case MaterialAttributeValueType.Number:\n            return view.getFloat32(idx);\n        case MaterialAttributeValueType.Vec2:\n        {\n            const x = view.getFloat32(idx);\n            idx += 4;\n            const y = view.getFloat32(idx);\n            return vec2.fromValues(x, y);\n        }\n        case MaterialAttributeValueType.Vec3:\n        {\n            const x = view.getFloat32(idx);\n            idx += 4;\n            const y = view.getFloat32(idx);\n            idx += 4;\n            const z = view.getFloat32(idx);\n            return vec3.fromValues(x, y, z);\n        }\n        case MaterialAttributeValueType.Vec4:\n        {\n            const x = view.getFloat32(idx);\n            idx += 4;\n            const y = view.getFloat32(idx);\n            idx += 4;\n            const z = view.getFloat32(idx);\n            idx += 4;\n            const w = view.getFloat32(idx);\n            return vec4.fromValues(x, y, z, w);\n        }\n    }\n}\n\nexport function decodePoint(attributes: MaterialAttributes | undefined, view: DataView, idx: number): Vertex {\n    // decode position\n    const pos = decodePointDatum(MaterialAttributeValueType.Vec3, view, idx) as vec3;\n    idx += 12;\n\n    // decode per-material extra vertex data\n    let extra;\n    if (attributes) {\n        extra = [];\n        for (const attribute of attributes) {\n            extra.push(decodePointDatum(attribute.valueType, view, idx));\n            idx += getVertexPropertyTypeSize(attribute.valueType);\n        }\n    }\n\n    return new Vertex(pos, extra);\n}", "import OctreeCSG from './OctreeCSG';\n\nimport type { MaterialAttributes, MaterialDefinitions } from './MaterialDefinition';\n\nconst incompPrefix = 'Incompatible material definitions for material ID ';\nconst attrProps: ('type' | 'valueType' | 'transformable' | 'flippable')[] = ['type', 'valueType', 'transformable', 'flippable'];\n\nfunction assertAttributesMatch(materialID: number, first: MaterialAttributes, second: MaterialAttributes) {\n    const attrCount = first.length;\n    if (attrCount !== second.length) {\n        throw new Error(`${incompPrefix}${materialID}; extra attributes count doesn't match`);\n    }\n\n    for (let i = 0; i < attrCount; i++) {\n        const attrFirst = first[i];\n        const attrSecond = second[i];\n\n        for (const propName of attrProps) {\n            if (attrFirst[propName] !== attrSecond[propName]) {\n                throw new Error(`${incompPrefix}${materialID}; attribute ${i}'s ${propName} doesn't match`);\n            }\n        }\n    }\n}\n\nexport function mergeTwoMaterials(first: Readonly<MaterialDefinitions>, second: Readonly<MaterialDefinitions>): MaterialDefinitions {\n    // special case; if both have the same reference, just return one of them\n    if (first === second) {\n        return first;\n    }\n\n    // check that both definitions are equal but have different references.\n    // return one of them if this is the case\n    if (first.size === second.size) {\n        let equal = true;\n        for (const [materialID, attributes] of first) {\n            const otherAttributes = second.get(materialID);\n            if (!otherAttributes) {\n                equal = false;\n                break;\n            }\n\n            assertAttributesMatch(materialID, attributes, otherAttributes);\n        }\n\n        if (equal) {\n            return first;\n        }\n    }\n\n    // merge definitions\n    const merged: MaterialDefinitions = new Map();\n\n    for (const [materialID, attributes] of first) {\n        const otherAttributes = second.get(materialID);\n        if (otherAttributes) {\n            assertAttributesMatch(materialID, attributes, otherAttributes)\n        }\n\n        merged.set(materialID, attributes);\n    }\n\n    for (const [materialID, attributes] of second) {\n        if (!first.has(materialID)) {\n            merged.set(materialID, attributes);\n        }\n    }\n\n    return merged;\n}\n\nexport function mergeMaterials(materialsOrOctrees: Array<Readonly<MaterialDefinitions> | Readonly<OctreeCSG>>): MaterialDefinitions {\n    const matCount = materialsOrOctrees.length;\n    if (matCount === 0) {\n        throw new Error('Expected at least one material definition or octree');\n    }\n\n    const firstMO = materialsOrOctrees[0];\n    let first: Readonly<MaterialDefinitions>;\n\n    if (firstMO instanceof OctreeCSG) {\n        first = firstMO.materials;\n    } else {\n        first = firstMO as Readonly<MaterialDefinitions>;\n    }\n\n    // special case; only one material provided\n    if (matCount === 1) {\n        return first;\n    }\n\n    // convert all inputs to materials if some are octrees\n    const materials = new Array<Readonly<MaterialDefinitions>>(matCount);\n    materials[0] = first;\n\n    for (let i = 1; i < matCount; i++) {\n        const thisMatMO = materialsOrOctrees[i];\n\n        if (thisMatMO instanceof OctreeCSG) {\n            materials[i] = thisMatMO.materials;\n        } else {\n            materials[i] = thisMatMO as Readonly<MaterialDefinitions>;\n        }\n    }\n\n    // merge pairs of material definitions\n    while (materials.length > 1) {\n        const a = materials.pop() as Readonly<MaterialDefinitions>;\n        const b = materials.pop() as Readonly<MaterialDefinitions>;\n        materials.push(mergeTwoMaterials(a, b));\n    }\n\n    return materials[0];\n}", "import OctreeCSG from '../base/OctreeCSG';\nimport { JobError } from './JobError';\n\nimport type { OctreeCSGOptions } from '../base/OctreeCSG';\nimport type { EncodedOctreeCSGObject, EncodedOctreeCSGObjectArgument } from './EncodedOctreeCSGObject';\nimport type { OctreeCSGObject } from '../base/OctreeCSGObject';\nimport type WorkerRequest from './WorkerRequest';\nimport type { MaterialDefinitions } from '../base/MaterialDefinition';\n\nfunction encodeOctreeCSGObject(obj: OctreeCSGObject, materials: MaterialDefinitions, transferables: Array<ArrayBuffer>): EncodedOctreeCSGObject {\n    switch (obj.op) {\n        case 'union':\n        case 'subtract':\n        case 'intersect':\n        {\n            return <EncodedOctreeCSGObject>{\n                op: obj.op,\n                objA: encodeOctreeCSGObjectOrCSG(obj.objA, materials, transferables),\n                objB: encodeOctreeCSGObjectOrCSG(obj.objB, materials, transferables),\n            }\n        }\n        case 'unionArray':\n        case 'subtractArray':\n        case 'intersectArray':\n        {\n            const encodedObjs = new Array<EncodedOctreeCSGObjectArgument>();\n\n            for (const octreeObj of obj.objs) {\n                encodedObjs.push(encodeOctreeCSGObjectOrCSG(octreeObj, materials, transferables));\n            }\n\n            return <EncodedOctreeCSGObject>{\n                op: obj.op,\n                objs: encodedObjs,\n            }\n        }\n        default:\n            throw new Error(`Unknown operation: ${(obj as {op: unknown}).op}`);\n    }\n}\n\nfunction encodeOctreeCSGObjectOrCSG(obj: OctreeCSGObject | OctreeCSG, materials: MaterialDefinitions, transferables: Array<ArrayBuffer>): EncodedOctreeCSGObjectArgument {\n    if (obj instanceof OctreeCSG) {\n        return obj.encode(materials, transferables);\n    } else {\n        return encodeOctreeCSGObject(obj, materials, transferables);\n    }\n}\n\nexport default class Job {\n    private operation: EncodedOctreeCSGObject | null;\n    private materials: MaterialDefinitions | null;\n    private options?: OctreeCSGOptions;\n    private transferables: Array<ArrayBuffer> | null;\n    workerIndex: number | null = null;\n\n    constructor(operation: OctreeCSGObject, materials: MaterialDefinitions, options: OctreeCSGOptions | undefined, private resolveCallback: (octree: OctreeCSG) => void, private rejectCallback: (error: JobError) => void) {\n        // encode operation\n        this.transferables = [];\n        this.operation = encodeOctreeCSGObject(operation, materials, this.transferables);\n        this.materials = materials;\n        this.options = options;\n    }\n\n    getMessage(workerIndex: number, jobIndex: number): [message: WorkerRequest, transferables: Array<ArrayBuffer>] {\n        if (!(this.operation && this.transferables)) {\n            throw new Error('Message already created');\n        }\n\n        const operation = this.operation;\n        const materials = this.materials;\n        const options = this.options;\n        const transferables = this.transferables;\n\n        this.operation = null;\n        this.materials = null;\n        this.options = undefined;\n        this.transferables = null;\n        this.workerIndex = workerIndex;\n\n        const data: [message: WorkerRequest, transferables: Array<ArrayBuffer>] = [\n            <WorkerRequest>{\n                type: 'operation',\n                jobIndex,\n                operation,\n                materials,\n                options,\n            },\n            transferables,\n        ];\n\n        return data;\n    }\n\n    resolve(buffer: ArrayBuffer, materials: MaterialDefinitions) {\n        try {\n            this.resolveCallback(OctreeCSG.decode(buffer, materials));\n        } catch(e) {\n            this.rejectCallback(JobError.DecodeFailure(e));\n        }\n    }\n\n    reject(error: JobError) {\n        this.rejectCallback(error);\n    }\n}\n", "import { JobError } from './JobError';\nimport Job from './Job';\n\nimport type { OctreeCSGObject } from '../base/OctreeCSGObject';\nimport type OctreeCSG from '../base/OctreeCSG';\nimport type JobResult from './JobResult';\nimport type { MaterialDefinitions } from '../base/MaterialDefinition';\nimport { OctreeCSGOptions } from '../base/OctreeCSG';\n\ndeclare global {\n    // eslint-disable-next-line no-var\n    var globalOctreeCSGJobDispatcher: OctreeCSGJobDispatcher | null | undefined;\n}\n\nconst JOB_REG_MSG = 'OctreeCSG job dispatcher worker creation';\nconst WARN_START = `Skipped ${JOB_REG_MSG}; `;\n\nexport default class OctreeCSGJobDispatcher {\n    private workers: Array<Worker> | null = null;\n    private nextJobIndex = 0;\n    private waitingJobs = new Map<number, Job>();\n    private jobCounts = new Array<number>();\n\n    private initWorker(workers: Array<Worker>, workerPath: string, timeoutMS: number, name: string) {\n        return new Promise((resolve: (value: undefined) => void, reject: (reason: Error) => void) => {\n            const timeout = setTimeout(() => {\n                worker.terminate();\n                reject(new Error('Timed out'));\n            }, timeoutMS);\n\n            const worker = new Worker(workerPath, { type: 'classic', name });\n            worker.onmessage = (message: MessageEvent<string>) => {\n                clearTimeout(timeout);\n\n                if (message.data === 'initialized') {\n                    const workerIndex = workers.length;\n                    workers.push(worker);\n\n                    worker.onmessage = this.makeMessageHandler(workerIndex);\n                    resolve(undefined); // XXX undefined so typescript shuts up\n                } else {\n                    worker.terminate();\n                    reject(new Error('Unexpected initialization message'));\n                }\n            }\n        });\n    }\n\n    private init(workerPath: string, workerCount: number, timeoutMS: number) {\n        return new Promise((resolve: (value: undefined) => void, reject: (reason: Error) => void) => {\n            const workers = new Array<Worker>();\n            let workersDone = 0;\n\n            for (let i = 0; i < workerCount; i++) {\n                this.initWorker(workers, workerPath, timeoutMS, `octreecsg-ea-${i}`).catch((reason: Error) => {\n                    console.error('Failed to create OctreeCSG worker:', reason.message);\n                }).finally(() => {\n                    if (++workersDone === workerCount) {\n                        const actualWorkerCount = workers.length;\n\n                        if (actualWorkerCount === 0) {\n                            reject(new Error('All OctreeCSG workers failed to be created'));\n                            return;\n                        } else if (actualWorkerCount !== workerCount) {\n                            console.warn(`Some OctreeCSG workers failed to be created. Created ${actualWorkerCount} workers instead of ${workerCount}`);\n                        } else {\n                            console.info(`Created ${actualWorkerCount} OctreeCSG workers`);\n                        }\n\n                        this.workers = workers;\n                        this.jobCounts = new Array(actualWorkerCount);\n                        this.jobCounts.fill(0);\n\n                        resolve(undefined); // XXX undefined so typescript shuts up\n                    }\n                });\n            }\n        });\n    }\n\n    private makeMessageHandler(workerIndex: number) {\n        // XXX this aliasing is OK here because this changes in the callback\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const dispatcher = this;\n\n        return function(this: Worker, event: MessageEvent<JobResult>) {\n            dispatcher.handleMessage(workerIndex, event);\n        }\n    }\n\n    private handleMessage(workerIndex: number, event: MessageEvent<JobResult>) {\n        // remove job from worker job count\n        this.jobCounts[workerIndex]--;\n\n        // delete from waiting jobs\n        const jobIndex = event.data.jobIndex;\n        const job = this.waitingJobs.get(jobIndex) as Job;\n        this.waitingJobs.delete(jobIndex);\n\n        // finalize promise\n        if (event.data.success) {\n            job.resolve(event.data.buffer, event.data.materials);\n        } else {\n            job.reject(JobError.OperationFailure(event.data.error));\n        }\n    }\n\n    private doDispatch(jobIndex: number, job: Job) {\n        // get worker with least workers (prefer workers with lower indices)\n        let minWorkerIndex = 0;\n        let minJobCount = this.jobCounts[0];\n\n        const workerCount = this.jobCounts.length;\n        for (let workerIndex = 1; workerIndex < workerCount; workerIndex++) {\n            const jobCount = this.jobCounts[workerIndex];\n            if (jobCount < minJobCount) {\n                minWorkerIndex = workerIndex;\n                minJobCount = jobCount;\n            }\n        }\n\n        // add job to worker job count\n        this.jobCounts[minWorkerIndex]++;\n\n        // dispatch to chosen worker\n        const worker = (this.workers as Array<Worker>)[minWorkerIndex];\n        worker.postMessage(...job.getMessage(minWorkerIndex, jobIndex));\n    }\n\n    dispatch(operation: OctreeCSGObject, materials: MaterialDefinitions, options?: OctreeCSGOptions) {\n        return new Promise((resolve: (octree: OctreeCSG) => void, reject: (error: JobError) => void) => {\n            // create job\n            const job = new Job(operation, materials, options, resolve, reject)\n            const jobIndex = this.nextJobIndex++;\n            this.waitingJobs.set(jobIndex, job);\n\n            // dispatch to worker if workers are registered\n            if (this.workers) {\n                this.doDispatch(jobIndex, job);\n            }\n        })\n    }\n\n    static async create(workerPath: string, workerCount: number, timeoutMS: number) {\n        if (globalThis.globalOctreeCSGJobDispatcher) {\n            console.warn(`${WARN_START}already created`);\n            return;\n        } else if (globalThis.globalOctreeCSGJobDispatcher === null) {\n            console.warn(`${WARN_START}previous creation failed`);\n            return;\n        }\n\n        let jobDispatcher;\n\n        if (globalThis.Worker) {\n            try {\n                jobDispatcher = new OctreeCSGJobDispatcher();\n                globalThis.globalOctreeCSGJobDispatcher = jobDispatcher;\n                await jobDispatcher.init(workerPath, workerCount, timeoutMS);\n            } catch(e) {\n                console.error(`${JOB_REG_MSG} failed:`, e);\n\n                // reject all jobs with a special reason so that they can recover\n                globalThis.globalOctreeCSGJobDispatcher = null;\n\n                if (jobDispatcher) {\n                    for (const job of jobDispatcher.waitingJobs.values()) {\n                        job.reject(JobError.WorkerCreationFailure(e));\n                    }\n\n                    jobDispatcher.waitingJobs.clear();\n                }\n\n                throw e;\n            }\n\n            for (const [jobIndex, job] of jobDispatcher.waitingJobs) {\n                jobDispatcher.doDispatch(jobIndex, job);\n            }\n        } else {\n            console.warn(`${WARN_START}Worker API not supported`);\n            return;\n        }\n    }\n}", "import { vec3 } from 'gl-matrix';\n\nimport Box3 from '../math/Box3';\nimport Vertex from '../math/Vertex';\nimport { CSGPrimitive } from './CSGPrimitive';\n\nimport type { CSGPrimitiveOptions } from './CSGPrimitive';\n\nfunction addSquare(vertices: Array<Vertex>, index: number, a: vec3, b: vec3, c: vec3, d: vec3, normal: vec3): number {\n    // first triangle\n    vertices[index++] = new Vertex(vec3.clone(a), [vec3.clone(normal)]);\n    vertices[index++] = new Vertex(b, [vec3.clone(normal)]);\n    vertices[index++] = new Vertex(vec3.clone(c), [vec3.clone(normal)]);\n    // second triangle\n    vertices[index++] = new Vertex(c, [vec3.clone(normal)]);\n    vertices[index++] = new Vertex(d, [vec3.clone(normal)]);\n    vertices[index++] = new Vertex(a, [normal]);\n\n    return index;\n}\n\nexport class Cuboid extends CSGPrimitive {\n    constructor(xLength: number, yLength: number, zLength: number, options?: CSGPrimitiveOptions) {\n        // make bounding box\n        xLength *= 0.5;\n        yLength *= 0.5;\n        zLength *= 0.5;\n\n        const max = vec3.fromValues(xLength, yLength, zLength);\n        const min = vec3.negate(vec3.create(), max);\n\n        // add cuboid triangles\n        const luf = vec3.fromValues(-xLength,  yLength,  zLength);\n        const ruf = vec3.fromValues( xLength,  yLength,  zLength);\n        const lub = vec3.fromValues(-xLength,  yLength, -zLength);\n        const rub = vec3.fromValues( xLength,  yLength, -zLength);\n        const ldf = vec3.fromValues(-xLength, -yLength,  zLength);\n        const rdf = vec3.fromValues( xLength, -yLength,  zLength);\n        const ldb = vec3.fromValues(-xLength, -yLength, -zLength);\n        const rdb = vec3.fromValues( xLength, -yLength, -zLength);\n\n        const vertices = new Array(36);\n        let index = addSquare(vertices, 0, luf, ruf, rub, lub, vec3.fromValues( 0,  1,  0));\n        index = addSquare(vertices, index, ldb, rdb, rdf, ldf, vec3.fromValues( 0, -1,  0));\n        index = addSquare(vertices, index, rub, ruf, rdf, rdb, vec3.fromValues( 1,  0,  0));\n        index = addSquare(vertices, index, ldb, ldf, luf, lub, vec3.fromValues(-1,  0,  0));\n        index = addSquare(vertices, index, rdf, ruf, luf, ldf, vec3.fromValues( 0,  0,  1));\n                addSquare(vertices, index, ldb, lub, rub, rdb, vec3.fromValues( 0,  0, -1));\n\n        super(new Box3(min, max), vertices, options);\n    }\n}", "import { mat4, quat, vec3 } from 'gl-matrix';\nimport OctreeCSG from '../base/OctreeCSG';\nimport { Polygon } from '../math/Polygon';\nimport CSGPrimitiveMaterialAttributes from './CSGPrimitiveMaterialAttributes';\n\nimport type { mat3 } from 'gl-matrix';\n\nimport type Vertex from '../math/Vertex';\nimport type Box3 from '../math/Box3';\n\nexport type CSGPrimitiveOptions = {\n    materialID?: number,\n    outputMatrix?: mat4,\n    inverted?: boolean,\n} & ({\n    matrix: mat4,\n    normalMatrix?: mat3,\n} | {\n    rotation?: quat | vec3,\n    translation?: vec3,\n    scale?: vec3,\n} | {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n});\n\nexport class CSGPrimitive extends OctreeCSG {\n    constructor(box: Box3, triangleVertices: Array<Vertex>, options?: CSGPrimitiveOptions) {\n        const vertexCount = triangleVertices.length;\n        if (vertexCount % 3 !== 0) {\n            throw new Error('Input triangle vertices array has a non-multiple-of-three length');\n        }\n\n        const materialID = options?.materialID ?? 0;\n        const materials = new Map([[materialID, CSGPrimitiveMaterialAttributes]]);\n\n        super(materials, box);\n\n        // turn vertex array to triangle array\n        for (let i = 0; i < vertexCount; i += 3) {\n            const polygon = new Polygon(triangleVertices.slice(i, i + 3), materialID);\n            polygon.originalValid = true;\n            this.polygons.push(polygon);\n        }\n\n        // transform if necessary\n        if (!options) {\n            return;\n        }\n\n        // TODO this feels kinda wrong, but i can't think of a better api (as in\n        // easier to use, but still as efficient) for this. maybe improve this\n        // later?\n        const outputMatrix = options.outputMatrix;\n\n        if ('matrix' in options) {\n            const matrix = options.matrix;\n            this.applyMatrix(matrix, options.normalMatrix);\n\n            if (outputMatrix) {\n                mat4.copy(outputMatrix, matrix);\n            }\n        } else if ('rotation' in options || 'translation' in options || 'scale' in options) {\n            // make transformation matrix\n            const matrix = mat4.create();\n\n            let rotation;\n            if (options.rotation) {\n                if (options.rotation.length === 4) {\n                    rotation = options.rotation;\n                } else {\n                    const [xDeg, yDeg, zDeg] = options.rotation;\n                    rotation = quat.fromEuler(quat.create(), xDeg, yDeg, zDeg);\n                }\n            }\n\n            if (rotation && options.translation) {\n                if (options.scale) {\n                    // RTS\n                    mat4.fromRotationTranslationScale(matrix, rotation, options.translation, options.scale);\n                } else {\n                    // RT\n                    mat4.fromRotationTranslation(matrix, rotation, options.translation);\n                }\n            } else if (options.translation) {\n                if (options.scale) {\n                    // TS\n                    mat4.identity(matrix);\n                    mat4.translate(matrix, matrix, options.translation);\n                    mat4.scale(matrix, matrix, options.scale);\n                } else {\n                    // T\n                    mat4.fromTranslation(matrix, options.translation);\n                }\n            } else if (rotation) {\n                if (options.scale) {\n                    // RS\n                    mat4.identity(matrix);\n                    const tmpMat = mat4.create();\n                    mat4.fromQuat(tmpMat, rotation);\n                    mat4.multiply(matrix, matrix, tmpMat);\n                    mat4.scale(matrix, matrix, options.scale);\n                } else {\n                    // R\n                    mat4.fromQuat(matrix, rotation);\n                }\n            } else {\n                // S\n                // XXX for some reason typescript doesn't detect scale as being\n                // a vec3 here but can be safely ignored\n                mat4.fromScaling(matrix, options.scale as vec3);\n            }\n\n            this.applyMatrix(matrix);\n\n            if (outputMatrix) {\n                mat4.copy(outputMatrix, matrix);\n            }\n        } else if (outputMatrix) {\n            mat4.identity(outputMatrix);\n        }\n\n        // invert if needed\n        if (options?.inverted) {\n            this.invert();\n        }\n    }\n}", "import { MaterialAttribute, MaterialAttributes, MaterialAttributeValueType, MaterialAttributeTransform, MaterialAttributeStandardType } from '../base/MaterialDefinition';\n\nconst vertexNormal = <MaterialAttribute>{\n    type: MaterialAttributeStandardType.Normal,\n    valueType: MaterialAttributeValueType.Vec3,\n    transformable: MaterialAttributeTransform.Normal,\n    flippable: true,\n}\n\nconst CSGPrimitiveMaterialAttributes: MaterialAttributes = [vertexNormal];\n\nexport default CSGPrimitiveMaterialAttributes;", "import { Cuboid } from './Cuboid';\n\nimport type { CSGPrimitiveOptions } from './CSGPrimitive';\n\nexport class Cube extends Cuboid {\n    constructor(length = 1, options?: CSGPrimitiveOptions) {\n        super(length, length, length, options);\n    }\n}", "import { vec3 } from 'gl-matrix';\n\nimport Box3 from '../math/Box3';\nimport Vertex from '../math/Vertex';\nimport { CSGPrimitive } from './CSGPrimitive';\n\nimport type { CSGPrimitiveOptions } from './CSGPrimitive';\n\nexport type SphereCSGPrimitiveOptions = CSGPrimitiveOptions & {\n    subDivisions?: number,\n};\n\nexport type SpherifyPointFunction = (ip: number, jp: number, radius: number, origin: vec3, right: vec3, up: vec3) => [pos: vec3, normal: vec3];\n\nfunction spherifyFace(spherifyPoint: SpherifyPointFunction, index: number, subDivs: number, radius: number, vertices: Array<Vertex>, origin: vec3, right: vec3, up: vec3): number {\n    // XXX this can be optimised by re-using the previous sub-division's vertex\n    // per axis\n    for (let i = 0; i < subDivs; i++) {\n        const ip = i / subDivs;\n        const inp = (i + 1) / subDivs;\n\n        for (let j = 0; j < subDivs; j++) {\n            const jp = j / subDivs;\n            const jnp = (j + 1) / subDivs;\n\n            const [a, aNorm] = spherifyPoint(ip, jp, radius, origin, right, up);\n            const [b, bNorm] = spherifyPoint(inp, jp, radius, origin, right, up);\n            const [c, cNorm] = spherifyPoint(inp, jnp, radius, origin, right, up);\n            const [d, dNorm] = spherifyPoint(ip, jnp, radius, origin, right, up);\n\n            vertices[index++] = new Vertex(vec3.clone(a), [vec3.clone(aNorm)]);\n            vertices[index++] = new Vertex(b, [bNorm]);\n            vertices[index++] = new Vertex(vec3.clone(c), [vec3.clone(cNorm)]);\n            vertices[index++] = new Vertex(c, [cNorm]);\n            vertices[index++] = new Vertex(d, [dNorm]);\n            vertices[index++] = new Vertex(a, [aNorm]);\n        }\n    }\n\n    return index;\n}\n\nexport class CubeSphere extends CSGPrimitive {\n    constructor(spherifyPoint: SpherifyPointFunction, diameter = 1, options?: SphereCSGPrimitiveOptions) {\n        // spherify a cube\n        const subDivs = options?.subDivisions ?? 4;\n        const vertexCount = 36 * subDivs * subDivs;\n        const vertices = new Array<Vertex>(vertexCount);\n        const radius = diameter / 2;\n\n        // right\n        let index = spherifyFace(spherifyPoint, 0, subDivs, radius, vertices, [1, -1, 1], [0, 0, -2], [0, 2, 0]);\n        // left\n        index = spherifyFace(spherifyPoint, index, subDivs, radius, vertices, [-1, -1, -1], [0, 0, 2], [0, 2, 0]);\n        // up\n        index = spherifyFace(spherifyPoint, index, subDivs, radius, vertices, [-1, 1, 1], [2, 0, 0], [0, 0, -2]);\n        // down\n        index = spherifyFace(spherifyPoint, index, subDivs, radius, vertices, [1, -1, 1], [-2, 0, 0], [0, 0, -2]);\n        // front\n        index = spherifyFace(spherifyPoint, index, subDivs, radius, vertices, [-1, -1, 1], [2, 0, 0], [0, 2, 0]);\n        // back\n        spherifyFace(spherifyPoint, index, subDivs, radius, vertices, [1, -1, -1], [-2, 0, 0], [0, 2, 0]);\n\n        // make bounding box\n        const max = vec3.fromValues(radius, radius, radius);\n        const min = vec3.negate(vec3.create(), max);\n\n        super(new Box3(min, max), vertices, options);\n    }\n}", "import { vec3 } from 'gl-matrix';\n\nimport { THIRD } from '../math/const-numbers';\nimport { tv0, tv1 } from '../math/temp';\nimport { CubeSphere } from './CubeSphere';\n\nimport type { SphereCSGPrimitiveOptions } from './CubeSphere';\n\nfunction spherifyPoint(ip: number, jp: number, radius: number, origin: vec3, right: vec3, up: vec3): [pos: vec3, normal: vec3] {\n    // algorithm adapted from:\n    // http://mathproofs.blogspot.com/2005/07/mapping-cube-to-sphere.html\n    vec3.copy(tv0, origin);\n    vec3.scaleAndAdd(tv0, tv0, right, ip);\n    vec3.scaleAndAdd(tv0, tv0, up, jp);\n    vec3.multiply(tv1, tv0, tv0);\n\n    const normal = vec3.fromValues(\n        tv0[0] * Math.sqrt(1 - 0.5 * (tv1[1] + tv1[2]) + tv1[1] * tv1[2] * THIRD),\n        tv0[1] * Math.sqrt(1 - 0.5 * (tv1[2] + tv1[0]) + tv1[2] * tv1[0] * THIRD),\n        tv0[2] * Math.sqrt(1 - 0.5 * (tv1[0] + tv1[1]) + tv1[0] * tv1[1] * THIRD),\n    );\n    const pos = vec3.scale(vec3.create(), normal, radius);\n\n    return [pos, normal];\n}\n\nexport class Sphere extends CubeSphere {\n    constructor(diameter = 1, options?: SphereCSGPrimitiveOptions) {\n        super(spherifyPoint, diameter, options);\n    }\n}", "import { vec3 } from 'gl-matrix';\n\nimport { tv0 } from '../math/temp';\nimport { CubeSphere } from './CubeSphere';\n\nimport type { SphereCSGPrimitiveOptions } from './CubeSphere';\n\nfunction spherifyPoint(ip: number, jp: number, radius: number, origin: vec3, right: vec3, up: vec3): [pos: vec3, normal: vec3] {\n    vec3.copy(tv0, origin);\n    vec3.scaleAndAdd(tv0, tv0, right, ip);\n    vec3.scaleAndAdd(tv0, tv0, up, jp);\n    const normal = vec3.normalize(tv0, tv0);\n    const pos = vec3.scale(vec3.create(), normal, radius);\n\n    return [pos, normal];\n}\n\nexport class UVSphere extends CubeSphere {\n    constructor(diameter = 1, options?: SphereCSGPrimitiveOptions) {\n        super(spherifyPoint, diameter, options);\n    }\n}", "import { vec3 } from 'gl-matrix';\n\nimport Box3 from '../math/Box3';\nimport Vertex from '../math/Vertex';\nimport { CSGPrimitive } from './CSGPrimitive';\nimport { makeCircularBase, precalcCircularBase } from './make-circular-base';\n\nimport type CircularBaseCSGPrimitiveOptions from './CircularBaseCSGPrimitiveOptions';\n\nexport class Cylinder extends CSGPrimitive {\n    constructor(diameter = 1, length = 1, options?: CircularBaseCSGPrimitiveOptions) {\n        // pre-calculations\n        const subDivs = options?.subDivisions ?? 12;\n        const vertexCount = (subDivs - 2) * 6 + subDivs * 6;\n        const vertices = new Array<Vertex>(vertexCount);\n        const radius = diameter / 2;\n        const halfLength = length / 2;\n        const xzn = precalcCircularBase(subDivs, radius, true);\n\n        // make bases\n        let index = makeCircularBase(vertices, xzn, halfLength, vec3.fromValues(0, 1, 0), 0, false);\n        index = makeCircularBase(vertices, xzn, -halfLength, vec3.fromValues(0, -1, 0), index, true);\n\n        // make sides\n        for (let i = 0; i < subDivs; i++) {\n            const [x1, z1, normal1] = xzn[i];\n            const [x2, z2, normal2] = xzn[(i + 1) % subDivs];\n\n            vertices[index++] = new Vertex(vec3.fromValues(x2, halfLength, z2), [vec3.clone(normal2)]);\n            vertices[index++] = new Vertex(vec3.fromValues(x1, halfLength, z1), [vec3.clone(normal1)]);\n            vertices[index++] = new Vertex(vec3.fromValues(x1, -halfLength, z1), [vec3.clone(normal1)]);\n\n            vertices[index++] = new Vertex(vec3.fromValues(x1, -halfLength, z1), [vec3.clone(normal1)]);\n            vertices[index++] = new Vertex(vec3.fromValues(x2, -halfLength, z2), [vec3.clone(normal2)]);\n            vertices[index++] = new Vertex(vec3.fromValues(x2, halfLength, z2), [vec3.clone(normal2)]);\n        }\n\n        // make bounding box\n        const max = vec3.fromValues(radius, halfLength, radius);\n        const min = vec3.negate(vec3.create(), max);\n\n        super(new Box3(min, max), vertices, options);\n    }\n}", "import { vec3 } from 'gl-matrix';\n\nimport Vertex from '../math/Vertex';\nimport triangulateConvexPolygon from '../helpers/triangulate-convex-polygon';\nimport { TAU } from '../math/const-numbers';\n\nexport type CircularPrecalcArr = Array<[x: number, z: number, normal?: vec3]>;\nexport type CircularPrecalcArrNoNormal = Array<[x: number, z: number]>;\nexport type CircularPrecalcArrNormal = Array<[x: number, z: number, normal: vec3]>;\n\nexport function makeCircularBase(vertices: Array<Vertex>, xzn: CircularPrecalcArr, y: number, normal: vec3, index: number, flip: boolean): number {\n    // make polyline\n    const segments = xzn.length;\n    const polyline = new Array(segments);\n\n    for (let i = 0; i < segments; i++) {\n        polyline[i] = new Vertex(vec3.fromValues(xzn[i][0], y, xzn[i][1]), [vec3.clone(normal)]);\n    }\n\n    // triangulate\n    return triangulateConvexPolygon(polyline, flip, vertices, index)[1];\n}\n\nexport function precalcCircularBase(subDivs: number, radius: number, generateNormals: false): CircularPrecalcArrNoNormal;\nexport function precalcCircularBase(subDivs: number, radius: number, generateNormals: true): CircularPrecalcArrNormal;\nexport function precalcCircularBase(subDivs: number, radius: number, generateNormals: boolean): CircularPrecalcArr;\nexport function precalcCircularBase(subDivs: number, radius: number, generateNormals: boolean): CircularPrecalcArr {\n    const xzn: CircularPrecalcArr = new Array(subDivs);\n\n    for (let i = 0; i < subDivs; i++) {\n        const angle = TAU * (subDivs - 1 - i) / subDivs;\n        const dx = Math.cos(angle);\n        const dz = Math.sin(angle);\n\n        if (generateNormals) {\n            xzn[i] = [radius * dx, radius * dz, vec3.fromValues(dx, 0, dz)];\n        } else {\n            xzn[i] = [radius * dx, radius * dz];\n        }\n    }\n\n    return xzn;\n}", "import { vec3 } from 'gl-matrix';\nimport Vertex from '../math/Vertex';\n\nexport default function triangulateConvexPolygon(vertices: Array<Vertex>, flip = false, output?: Array<Vertex>, startIndex = 0): [Array<Vertex>, number] {\n    // XXX assume that the vertices in the polyline are already in CCW order\n    const vertexCount = vertices.length;\n\n    // fast paths (and error conditions):\n    if (vertexCount < 3) {\n        throw new Error(`Expected input polyline with 3 or more vertices, got ${vertexCount}`);\n    }\n\n    if (!output) {\n        output = new Array(startIndex + (vertexCount - 2) * 3);\n    }\n\n    if (vertexCount === 3) {\n        // already a triangle, copy it\n        if (flip) {\n            output[startIndex++] = vertices[2].clone();\n            output[startIndex++] = vertices[1].clone();\n            output[startIndex++] = vertices[0].clone();\n        } else {\n            output[startIndex++] = vertices[0].clone();\n            output[startIndex++] = vertices[1].clone();\n            output[startIndex++] = vertices[2].clone();\n        }\n\n        return [output, startIndex];\n    } else if (vertexCount === 4) {\n        // triangulate a square. special case that avoids sliver triangles\n        if (flip) {\n            output[startIndex++] = vertices[2].clone();\n            output[startIndex++] = vertices[1].clone();\n            output[startIndex++] = vertices[0].clone();\n        } else {\n            output[startIndex++] = vertices[0].clone();\n            output[startIndex++] = vertices[1].clone();\n            output[startIndex++] = vertices[2].clone();\n        }\n\n        if (vec3.squaredDistance(vertices[0].pos, vertices[2].pos) <= vec3.squaredDistance(vertices[1].pos, vertices[3].pos)) {\n            output[startIndex++] = vertices[0].clone();\n        } else {\n            output[startIndex++] = vertices[1].clone();\n        }\n\n        if (flip) {\n            output[startIndex++] = vertices[3].clone();\n            output[startIndex++] = vertices[2].clone();\n        } else {\n            output[startIndex++] = vertices[2].clone();\n            output[startIndex++] = vertices[3].clone();\n        }\n\n        return [output, startIndex];\n    }\n\n    // general case: use top-to-bottom scan algorithm\n    // sort vertices by XYZ respectively\n    const indices = Array.from({ length: vertexCount }, (_, i) => i);\n    indices.sort((aIdx, bIdx) => {\n        // if a < b, then -1, if a = b, then 0, if a > b, then 1\n        const a: Vertex = vertices[aIdx];\n        const b: Vertex = vertices[bIdx];\n\n        // compare x\n        if (a.pos[0] < b.pos[0]) {\n            return -1;\n        } else if (a.pos[0] > b.pos[0]) {\n            return 1;\n        } else {\n            // x equal. compare y\n            if (a.pos[1] < b.pos[1]) {\n                return -1;\n            } else if (a.pos[1] > b.pos[1]) {\n                return 1;\n            } else {\n                // y equal. compare z\n                if (a.pos[2] < b.pos[2]) {\n                    return -1;\n                } else if (a.pos[2] > b.pos[2]) {\n                    return 1;\n                } else {\n                    return 0;\n                }\n            }\n        }\n    });\n\n    // scan vertices from \"top\" to \"bottom\" (not really, but by the sorted\n    // order). since the vertices array is a polyline in CCW order, then we can\n    // make a triangle in the correct orientation by connecting the highest\n    // index vertex to the lowest index vertex to the other vertex\n    for (let i = 2; i < vertexCount; i++) {\n        // get indices for this triangle\n        let idxLow = indices[i - 2];\n        let idxMid = indices[i - 1];\n        let idxHigh = indices[i];\n\n        // sort by index number with an unrolled bubble sort. found in:\n        // https://stackoverflow.com/a/16612345\n        if (idxLow > idxMid) {\n            [idxLow, idxMid] = [idxMid, idxLow];\n        }\n        if (idxMid > idxHigh) {\n            [idxMid, idxHigh] = [idxHigh, idxMid];\n            if (idxLow > idxMid) {\n                [idxLow, idxMid] = [idxMid, idxLow];\n            }\n        }\n\n        // flip triangle if necessary\n        if (flip) {\n            [idxHigh, idxLow] = [idxLow, idxHigh];\n        }\n\n        // add triangle to output\n        output[startIndex++] = vertices[idxHigh].clone();\n        output[startIndex++] = vertices[idxLow].clone();\n        output[startIndex++] = vertices[idxMid].clone();\n    }\n\n    return [output, startIndex];\n}", "import { vec3 } from 'gl-matrix';\n\nimport Box3 from '../math/Box3';\nimport Vertex from '../math/Vertex';\nimport { CSGPrimitive } from './CSGPrimitive';\nimport { makeCircularBase, precalcCircularBase } from './make-circular-base';\n\nimport type { CSGPrimitiveOptions } from './CSGPrimitive';\nimport Plane from '../math/Plane';\n\nexport class BaseCone extends CSGPrimitive {\n    constructor(baseVertices: number, smoothNormals: boolean, diameter: number, length: number, options?: CSGPrimitiveOptions) {\n        // pre-calculations\n        const vertexCount = (baseVertices - 2) * 3 + baseVertices * 3;\n        const vertices = new Array<Vertex>(vertexCount);\n        const radius = diameter / 2;\n        const halfLength = length / 2;\n        const tip = vec3.fromValues(0, halfLength, 0);\n        const xzn = precalcCircularBase(baseVertices, radius, smoothNormals);\n\n        // calculate normals to match cone slope\n        if (smoothNormals) {\n            const angle = Math.atan(radius / length);\n            const xNormMul = Math.cos(angle);\n            const yNormVal = Math.sin(angle);\n\n            for (let i = 0; i < baseVertices; i++) {\n                const normal = xzn[i][2] as vec3;\n                normal[0] *= xNormMul;\n                normal[1] = yNormVal;\n                normal[2] *= xNormMul;\n            }\n        }\n\n        // make base\n        let index = makeCircularBase(vertices, xzn, -halfLength, vec3.fromValues(0, -1, 0), 0, true);\n\n        // make sides\n        for (let i = 0; i < baseVertices; i++) {\n            const xzn1 = xzn[i];\n            const xzn2 = xzn[(i + 1) % baseVertices];\n            const [x1, z1] = xzn1;\n            const [x2, z2] = xzn2;\n            const a = vec3.fromValues(x2, -halfLength, z2);\n            const b = vec3.clone(tip);\n            const c = vec3.fromValues(x1, -halfLength, z1);\n\n            let an: vec3, bn: vec3, cn: vec3;\n            if (smoothNormals) {\n                an = xzn1[2] as vec3;\n                // XXX this is counterintuitive, but the cone tip should have a\n                // normal pointing up, instead of pointing at the sloped angle\n                // between the 2 connected vertices\n                bn = vec3.fromValues(0, 1, 0);\n                cn = xzn2[2] as vec3;\n            } else {\n                an = bn = cn = Plane.calculateNormal(a, b, c);\n            }\n\n            vertices[index++] = new Vertex(a, [vec3.clone(cn)]);\n            vertices[index++] = new Vertex(b, [bn]);\n            vertices[index++] = new Vertex(c, [vec3.clone(an)]);\n        }\n\n        // make bounding box\n        const max = vec3.fromValues(radius, halfLength, radius);\n        const min = vec3.negate(vec3.create(), max);\n\n        super(new Box3(min, max), vertices, options);\n    }\n}", "import { BaseCone } from './BaseCone';\n\nimport type CircularBaseCSGPrimitiveOptions from './CircularBaseCSGPrimitiveOptions';\n\nexport class Cone extends BaseCone {\n    constructor(diameter = 1, length = 1, options?: CircularBaseCSGPrimitiveOptions) {\n        super(options?.subDivisions ?? 12, true, diameter, length, options);\n    }\n}", "import { BaseCone } from './BaseCone';\n\nimport type { CSGPrimitiveOptions } from './CSGPrimitive';\n\nexport class Pyramid extends BaseCone {\n    constructor(sides: number, diameter = 1, length = 1, options?: CSGPrimitiveOptions) {\n        super(sides, false, diameter, length, options);\n    }\n}", "import { vec3 } from 'gl-matrix';\n\nimport Box3 from '../math/Box3';\nimport Vertex from '../math/Vertex';\nimport { CSGPrimitive } from './CSGPrimitive';\nimport Plane from '../math/Plane';\nimport makeIcosahedronTriangles from './icosahedron-make-triangles';\n\nimport type { CSGPrimitiveOptions } from './CSGPrimitive';\n\nfunction addTriangle(vertices: Array<Vertex>, index: number, radius: number, a: Readonly<vec3>, b: Readonly<vec3>, c: Readonly<vec3>) {\n    const normal = Plane.calculateNormal(a, b, c);\n    vertices[index++] = new Vertex(vec3.scale(vec3.create(), a, radius), [vec3.clone(normal)]);\n    vertices[index++] = new Vertex(vec3.scale(vec3.create(), b, radius), [vec3.clone(normal)]);\n    vertices[index++] = new Vertex(vec3.scale(vec3.create(), c, radius), [normal]);\n    return index;\n}\n\nexport class Icosahedron extends CSGPrimitive {\n    constructor(diameter = 1, options?: CSGPrimitiveOptions) {\n        // make bounding box\n        const radius = diameter / 2;\n\n        const max = vec3.fromValues(radius, radius, radius);\n        const min = vec3.negate(vec3.create(), max);\n\n        // add icosahedron triangles\n        const vertices = new Array(60);\n        makeIcosahedronTriangles(addTriangle, vertices, radius);\n\n        super(new Box3(min, max), vertices, options);\n    }\n}", "import { vec3 } from 'gl-matrix';\n\nimport Vertex from '../math/Vertex';\n\nconst ICO_V: Array<Readonly<vec3>> = [\n    vec3.fromValues( 0       ,  1       ,  0      ),\n    vec3.fromValues( 0.276385,  0.447215, -0.85064),\n    vec3.fromValues(-0.7236  ,  0.447215, -0.52572),\n    vec3.fromValues(-0.7236  ,  0.447215,  0.52572),\n    vec3.fromValues( 0.276385,  0.447215,  0.85064),\n    vec3.fromValues( 0.894425,  0.447215,  0      ),\n    vec3.fromValues(-0.276385, -0.447215, -0.85064),\n    vec3.fromValues(-0.894425, -0.447215,  0      ),\n    vec3.fromValues(-0.276385, -0.447215,  0.85064),\n    vec3.fromValues( 0.7236  , -0.447215,  0.52572),\n    vec3.fromValues( 0.7236  , -0.447215, -0.52572),\n    vec3.fromValues( 0       , -1       ,  0      ),\n];\n\nexport default function makeIcosahedronTriangles(addTriangle: (vertices: Array<Vertex>, index: number, radius: number, a: Readonly<vec3>, b: Readonly<vec3>, c: Readonly<vec3>) => number, vertices: Array<Vertex>, radius: number) {\n    // top triangles\n    let index = addTriangle(vertices, 0, radius, ICO_V[0], ICO_V[1], ICO_V[2]);\n    index = addTriangle(vertices, index, radius, ICO_V[0], ICO_V[2], ICO_V[3]);\n    index = addTriangle(vertices, index, radius, ICO_V[0], ICO_V[3], ICO_V[4]);\n    index = addTriangle(vertices, index, radius, ICO_V[0], ICO_V[4], ICO_V[5]);\n    index = addTriangle(vertices, index, radius, ICO_V[0], ICO_V[5], ICO_V[1]);\n\n    // side triangles\n    index = addTriangle(vertices, index, radius, ICO_V[1], ICO_V[6], ICO_V[2]);\n    index = addTriangle(vertices, index, radius, ICO_V[2], ICO_V[6], ICO_V[7]);\n    index = addTriangle(vertices, index, radius, ICO_V[2], ICO_V[7], ICO_V[3]);\n    index = addTriangle(vertices, index, radius, ICO_V[3], ICO_V[7], ICO_V[8]);\n    index = addTriangle(vertices, index, radius, ICO_V[3], ICO_V[8], ICO_V[4]);\n    index = addTriangle(vertices, index, radius, ICO_V[4], ICO_V[8], ICO_V[9]);\n    index = addTriangle(vertices, index, radius, ICO_V[4], ICO_V[9], ICO_V[5]);\n    index = addTriangle(vertices, index, radius, ICO_V[5], ICO_V[9], ICO_V[10]);\n    index = addTriangle(vertices, index, radius, ICO_V[5], ICO_V[10], ICO_V[1]);\n    index = addTriangle(vertices, index, radius, ICO_V[1], ICO_V[10], ICO_V[6]);\n\n    // bottom triangles\n    index = addTriangle(vertices, index, radius, ICO_V[11], ICO_V[7], ICO_V[6]);\n    index = addTriangle(vertices, index, radius, ICO_V[11], ICO_V[8], ICO_V[7]);\n    index = addTriangle(vertices, index, radius, ICO_V[11], ICO_V[9], ICO_V[8]);\n    index = addTriangle(vertices, index, radius, ICO_V[11], ICO_V[10], ICO_V[9]);\n            addTriangle(vertices, index, radius, ICO_V[11], ICO_V[6], ICO_V[10]);\n}", "import { vec3 } from 'gl-matrix';\n\nimport Box3 from '../math/Box3';\nimport Vertex from '../math/Vertex';\nimport { CSGPrimitive } from './CSGPrimitive';\nimport makeIcosahedronTriangles from './icosahedron-make-triangles';\n\nimport type { CSGPrimitiveOptions } from './CSGPrimitive';\n\nfunction addTriangle(depth: number, vertices: Array<Vertex>, index: number, radius: number, a: Readonly<vec3>, b: Readonly<vec3>, c: Readonly<vec3>) {\n    if (depth <= 0) {\n        // target depth reached, make triangle\n        vertices[index++] = new Vertex(vec3.scale(vec3.create(), a, radius), [vec3.clone(a)]);\n        vertices[index++] = new Vertex(vec3.scale(vec3.create(), b, radius), [vec3.clone(b)]);\n        vertices[index++] = new Vertex(vec3.scale(vec3.create(), c, radius), [vec3.clone(c)]);\n    } else {\n        // target depth not reached, subdivide triangle into 4 triangles\n        const abm = vec3.add(vec3.create(), a, b);\n        vec3.normalize(abm, abm);\n        const bcm = vec3.add(vec3.create(), b, c);\n        vec3.normalize(bcm, bcm);\n        const cam = vec3.add(vec3.create(), c, a);\n        vec3.normalize(cam, cam);\n\n        const nextDepth = depth - 1;\n\n        index = addTriangle(nextDepth, vertices, index, radius, a, abm, cam);\n        index = addTriangle(nextDepth, vertices, index, radius, abm, b, bcm);\n        index = addTriangle(nextDepth, vertices, index, radius, abm, bcm, cam);\n        index = addTriangle(nextDepth, vertices, index, radius, cam, bcm, c);\n    }\n\n    return index;\n}\n\nexport type IcosphereCSGPrimitiveOptions = CSGPrimitiveOptions & {\n    subDivisions?: number,\n};\n\nexport class Icosphere extends CSGPrimitive {\n    constructor(diameter = 1, options?: IcosphereCSGPrimitiveOptions) {\n        // make bounding box\n        const radius = diameter / 2;\n\n        const max = vec3.fromValues(radius, radius, radius);\n        const min = vec3.negate(vec3.create(), max);\n\n        // add icosphere triangles recursively\n        const subDivs = options?.subDivisions ?? 2;\n        const vertices = new Array(60 * 4 ** subDivs);\n        makeIcosahedronTriangles(addTriangle.bind(null, subDivs), vertices, radius);\n\n        super(new Box3(min, max), vertices, options);\n    }\n}", "import { mat4, quat, vec3 } from 'gl-matrix';\n\nimport { CSGPrimitive } from './CSGPrimitive';\nimport Box3 from '../math/Box3';\nimport { TAU } from '../math/const-numbers';\nimport Vertex from '../math/Vertex';\nimport { tmpm4_0, tmpm4_1, tv0 } from '../math/temp';\n\nimport type { CSGPrimitiveOptions } from './CSGPrimitive';\n\nexport type TorusCSGPrimitiveOptions = CSGPrimitiveOptions & {\n    radialSubDivisions?: number,\n    tubularSubDivisions?: number,\n};\n\nexport class Torus extends CSGPrimitive {\n    constructor(outerDiameter = 1, innerDiameter = 0.5, options?: TorusCSGPrimitiveOptions) {\n        // make bounding box\n        const radSubDivs = options?.radialSubDivisions ?? 8;\n        const tubSubDivs = options?.tubularSubDivisions ?? 16;\n        const outerRadius = outerDiameter / 2;\n        const innerRadius = innerDiameter / 2;\n        const tubeRadius = outerRadius - innerRadius;\n\n        const max = vec3.fromValues(outerRadius, tubeRadius, outerRadius);\n        const min = vec3.negate(vec3.create(), max);\n\n        // pre-calculate segment vertices\n        const tubularSegments = new Array<Array<[positions: vec3, normals: vec3]>>(tubSubDivs);\n\n        for (let i = 0; i < tubSubDivs; i++) {\n            const radialSegments = new Array(radSubDivs);\n            tubularSegments[i] = radialSegments;\n\n            // XXX for some reason fromEuler breaks the norm and uses degrees\n            // instead of radians. THIS IS NOT A MISTAKE\n            const tubeRot = quat.fromEuler(quat.create(), 0, 360 * i / tubSubDivs, 0);\n\n            vec3.set(tv0, innerRadius + tubeRadius, 0, 0);\n            mat4.fromTranslation(tmpm4_0, tv0);\n            mat4.fromQuat(tmpm4_1, tubeRot);\n            mat4.multiply(tmpm4_0, tmpm4_1, tmpm4_0);\n\n            for (let j = 0; j < radSubDivs; j++) {\n                const angle = TAU * j / radSubDivs;\n                const x = Math.cos(angle);\n                const y = Math.sin(angle);\n\n                const pos = vec3.fromValues(x * tubeRadius, y * tubeRadius, 0);\n                vec3.transformMat4(pos, pos, tmpm4_0);\n                const normal = vec3.fromValues(x, y, 0);\n                vec3.transformQuat(normal, normal, tubeRot);\n\n                radialSegments[j] = [pos, normal];\n            }\n        }\n\n        // generate torus segments from pre-calculated vertices\n        const vertices = new Array(tubSubDivs * radSubDivs * 6);\n        let index = 0;\n\n        for (let i = 0; i < tubSubDivs; i++) {\n            const segment1 = tubularSegments[i];\n            const segment2 = tubularSegments[(i + 1) % tubSubDivs];\n\n            for (let j = 0; j < radSubDivs; j++) {\n                const jNext = (j + 1) % radSubDivs;\n                const [pos11, normal11] = segment1[j];\n                const [pos21, normal21] = segment2[j];\n                const [pos12, normal12] = segment1[jNext];\n                const [pos22, normal22] = segment2[jNext];\n\n                // first triangle\n                vertices[index++] = new Vertex(vec3.clone(pos12), [vec3.clone(normal12)]);\n                vertices[index++] = new Vertex(pos11, [normal11]);\n                vertices[index++] = new Vertex(vec3.clone(pos21), [vec3.clone(normal21)]);\n                // second triangle\n                vertices[index++] = new Vertex(vec3.clone(pos21), [vec3.clone(normal21)]);\n                vertices[index++] = new Vertex(vec3.clone(pos22), [vec3.clone(normal22)]);\n                vertices[index++] = new Vertex(pos12, [normal12]);\n            }\n        }\n\n        super(new Box3(min, max), vertices, options);\n    }\n}", "import { mat3, mat4, vec2, vec3 } from 'gl-matrix';\nimport OctreeCSG from '../base/OctreeCSG';\nimport Plane from '../math/Plane';\nimport { Polygon } from '../math/Polygon';\nimport { tv0 } from '../math/temp';\nimport Vertex from '../math/Vertex';\nimport triangulate2DPolygon from './triangulate-2d-polygon';\nimport CSGPrimitiveMaterialAttributes from '../primitives/CSGPrimitiveMaterialAttributes';\n\nimport type { CurveFrames } from './curve-frame';\n\nfunction makeSlice(output: Array<vec3>, outputMat: mat4, polyline: Array<vec2>, position: vec3, r: vec3, s: vec3, t: vec3) {\n    // r (normal) = +y, s (binormal) = +x, t (tangent) = +z\n    // make matrix from position and frame\n    mat4.set(\n        outputMat,\n        s[0], s[1], s[2], 0,\n        r[0], r[1], r[2], 0,\n        t[0], t[1], t[2], 0,\n        position[0], position[1], position[2], 1\n    );\n\n    // transform polyline to make slice\n    const sliceVerts = polyline.length;\n    for (let i = 0; i < sliceVerts; i++) {\n        const outputVec = output[i];\n        vec2.copy(outputVec as vec2, polyline[i]);\n        outputVec[2] = 0;\n        vec3.transformMat4(outputVec, outputVec, outputMat);\n    }\n}\n\nfunction makeBase(octree: OctreeCSG, triangulatedBase: Array<vec2>, mat: mat4, baseTriVerts: number, flip: boolean) {\n    for (let i = 0; i < baseTriVerts;) {\n        // transform triangle points to match beginning of curve\n        let a = vec3.create();\n        vec2.copy(a as vec2, triangulatedBase[i++]);\n        vec3.transformMat4(a, a, mat);\n        const b = vec3.create();\n        vec2.copy(b as vec2, triangulatedBase[i++]);\n        vec3.transformMat4(b, b, mat);\n        let c = vec3.create();\n        vec2.copy(c as vec2, triangulatedBase[i++]);\n        vec3.transformMat4(c, c, mat);\n\n        if (flip) {\n            [a, c] = [c, a];\n        }\n\n        // calculate normal\n        const normal = Plane.calculateNormal(a, b, c);\n\n        // make vertices\n        const aVert = new Vertex(a, [vec3.clone(normal)]);\n        const bVert = new Vertex(b, [vec3.clone(normal)]);\n        const cVert = new Vertex(c, [normal]);\n\n        // add to octree\n        const polygon = new Polygon([aVert, bVert, cVert]);\n        polygon.originalValid = true;\n        octree.addPolygon(polygon);\n    }\n}\n\nexport interface CurveExtrusionOptions {\n    includeBases?: boolean;\n    smoothNormals?: boolean;\n    materialID?: number;\n}\n\nexport function curveExtrude(polyline: Array<vec2>, positions: Array<vec3>, frames: CurveFrames, options?: CurveExtrusionOptions) {\n    // validate curve\n    const pointCount = positions.length;\n\n    if (frames.length !== pointCount) {\n        throw new Error('There must be at least one frame per point');\n    }\n\n    if (pointCount < 2) {\n        throw new Error('There must be at least 1 segment (2 points) in the curve');\n    }\n\n    // output:\n    const materialID = options?.materialID ?? 0;\n    const materials = new Map([[materialID, CSGPrimitiveMaterialAttributes]]);\n    const octree = new OctreeCSG(materials);\n\n    // pre-calculate first segment's slice (3D polyline)\n    const sliceVertices = polyline.length;\n    let lastSlice = new Array(sliceVertices), curSlice = new Array(sliceVertices);\n\n    for (let i = 0; i < sliceVertices; i++) {\n        lastSlice[i] = vec3.create();\n        curSlice[i] = vec3.create();\n    }\n\n    let lastMat = mat4.create(), lastMatNormal = mat3.create(), curMat = mat4.create(), curMatNormal = mat3.create();\n    makeSlice(curSlice, curMat, polyline, positions[0], ...frames[0]);\n    // XXX don't use normalFromMat4 or you will always get identity matrices\n    mat3.fromMat4(curMatNormal, curMat);\n\n    // pre-calculate untransformed normals of each edge in the polyline\n    const edgeNormals = new Array<vec3>(sliceVertices);\n\n    vec3.set(tv0, 0, 0, 1);\n    for (let i = 0; i < sliceVertices; i++) {\n        const j = (i + 1) % sliceVertices;\n        const iXY = polyline[i];\n        const jXY = polyline[j];\n        const normal = vec3.fromValues(iXY[0] - jXY[0], iXY[1] - jXY[1], 0);\n        edgeNormals[i] = vec3.cross(normal, tv0, normal);\n    }\n\n    // get average normal of connected edges for each vertex in the polyline if\n    // smooth normals are enabled\n    const smoothNormals = options?.smoothNormals ?? false;\n    let vertexNormals: Array<vec3> | undefined;\n\n    if (smoothNormals) {\n        vertexNormals = new Array(sliceVertices);\n\n        for (let i = 0; i < sliceVertices; i++) {\n            let j = i - 1;\n            if (j === -1) {\n                j = sliceVertices - 1;\n            }\n\n            const normal = vec3.add(vec3.create(), edgeNormals[j], edgeNormals[i]);\n            vertexNormals[i] = vec3.normalize(normal, normal);\n        }\n    }\n\n    // triangulate base if necessary\n    let triangulatedBase: Array<vec2> | undefined, baseTriVerts: number | undefined;\n    const includeBases = options?.includeBases ?? true;\n    if (includeBases) {\n        triangulatedBase = triangulate2DPolygon(polyline);\n        baseTriVerts = triangulatedBase.length;\n        // XXX unlike in linear extrusions, the start base is not flipped\n        // because it get's rotated to the correct orientation by a matrix\n        makeBase(octree, triangulatedBase, curMat, baseTriVerts, false);\n    }\n\n    // walk along each curve point/segment\n    const lastSegment = pointCount - 1;\n    for (let i = 1; i < pointCount; i++) {\n        // calculate slice for this point\n        [lastSlice, curSlice, lastMat, curMat, lastMatNormal, curMatNormal] = [curSlice, lastSlice, curMat, lastMat, curMatNormal, lastMatNormal];\n        makeSlice(curSlice, curMat, polyline, positions[i], ...frames[i]);\n        // XXX don't use normalFromMat4 or you will always get identity matrices\n        mat3.fromMat4(curMatNormal, curMat);\n\n        // make segment triangles\n        for (let j = 0; j < sliceVertices; j++) {\n            const k = (j + 1) % sliceVertices;\n\n            // make normals\n            let lastNormalA, lastNormalB, curNormalA, curNormalB;\n\n            if (vertexNormals) {\n                const jNorm = vertexNormals[j];\n                const kNorm = vertexNormals[k];\n                lastNormalA = vec3.clone(jNorm);\n                lastNormalB = vec3.clone(kNorm);\n                curNormalA = vec3.clone(jNorm);\n                curNormalB = vec3.clone(kNorm);\n            } else {\n                const norm = edgeNormals[j];\n                lastNormalA = vec3.clone(norm);\n                lastNormalB = vec3.clone(norm);\n                curNormalA = vec3.clone(norm);\n                curNormalB = vec3.clone(norm);\n            }\n\n            vec3.transformMat3(lastNormalA, lastNormalA, lastMatNormal);\n            vec3.transformMat3(lastNormalB, lastNormalB, lastMatNormal);\n            vec3.transformMat3(curNormalA, curNormalA, curMatNormal);\n            vec3.transformMat3(curNormalB, curNormalB, curMatNormal);\n\n            // make vertices\n            const lastA = new Vertex(lastSlice[j], [lastNormalA]);\n            const lastB = new Vertex(lastSlice[k], [lastNormalB]);\n            const curA = new Vertex(vec3.clone(curSlice[j]), [curNormalA]);\n            const curB = new Vertex(vec3.clone(curSlice[k]), [curNormalB]);\n\n            // make polygons\n            const polygonA = new Polygon([curB.clone(), lastB, lastA.clone()], materialID);\n            polygonA.originalValid = true;\n            octree.addPolygon(polygonA);\n            const polygonB = new Polygon([lastA, curA, curB], materialID);\n            polygonB.originalValid = true;\n            octree.addPolygon(polygonB);\n        }\n\n        // add ending base if necessary\n        if (includeBases && i === lastSegment) {\n            makeBase(octree, triangulatedBase as Array<vec2>, curMat, baseTriVerts as number, true);\n        }\n    }\n\n    return octree;\n}", "import type { vec2 } from 'gl-matrix';\n\nexport default function isClockwise2DPolygon(polyline: Array<vec2>): boolean {\n    // sum up all the edges of the polygon to get 2x signed area. if signed area\n    // is positive, then the polygon is clockwise\n    let sum = 0;\n    const vertCount = polyline.length;\n    let last = polyline[vertCount - 1];\n\n    for (const next of polyline) {\n        sum += (next[0] - last[0]) * (next[1] + last[1]);\n        last = next;\n    }\n\n    return sum >= 0;\n}", "import type { vec2 } from 'gl-matrix';\n\nexport default function sort2DIndices(polyline: Array<vec2>): Array<number> {\n    const indices = Array.from({ length: polyline.length }, (_, i) => i);\n    indices.sort((aIdx, bIdx) => {\n        // if a < b, then -1, if a = b, then 0, if a > b, then 1\n        const a: vec2 = polyline[aIdx];\n        const b: vec2 = polyline[bIdx];\n\n        // compare x\n        if (a[0] < b[0]) {\n            return -1;\n        } else if (a[0] > b[0]) {\n            return 1;\n        } else {\n            // x equal. compare y\n            if (a[1] < b[1]) {\n                return -1;\n            } else if (a[1] > b[1]) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }\n    });\n\n    return indices;\n}", "import { vec2 } from 'gl-matrix';\n\nfunction getPolygonInLoop(indices: Array<number>, start: number, end: number): Array<number> {\n    const indexCount = indices.length;\n    const output: Array<number> = [start];\n\n    for (let i = (indices.indexOf(start) + 1) % indexCount;; i = (i + 1) % indexCount) {\n        const actualIndex = indices[i];\n        output.push(actualIndex);\n\n        if (actualIndex === end) {\n            return output;\n        } else if (actualIndex === start) {\n            throw new Error(`getPolygonInLoop aborted; infinite loop detected due to possibly invalid split diagonal (${start}, ${end})`);\n        }\n    }\n}\n\nfunction splitPolygonTo(polyline: Array<vec2>, indices: Array<number>, diagonals: Array<[number, number]>, output: Array<Array<vec2>>, flip: boolean) {\n    if (diagonals.length > 0) {\n        // split along first diagonal\n        const [start, end] = diagonals[0];\n        const aIndices = getPolygonInLoop(indices, start, end);\n        const bIndices = getPolygonInLoop(indices, end, start);\n\n        // assign other diagonals to one of the partitions\n        const aDiags = new Array<[number, number]>(), bDiags = new Array<[number, number]>();\n        const diagonalCount = diagonals.length;\n        for (let i = 1; i < diagonalCount; i++) {\n            const [oStart, oEnd] = diagonals[i];\n\n            if (aIndices.indexOf(oStart) >= 0 && aIndices.indexOf(oEnd) >= 0) {\n                aDiags.push([oStart, oEnd]);\n            } else if (bIndices.indexOf(oStart) >= 0 && bIndices.indexOf(oEnd) >= 0) {\n                bDiags.push([oStart, oEnd]);\n            } else {\n                throw new Error(`Invalid split diagonal (${oStart}, ${oEnd})`);\n            }\n        }\n\n        // further split\n        splitPolygonTo(polyline, aIndices, aDiags, output, flip);\n        splitPolygonTo(polyline, bIndices, bDiags, output, flip);\n    } else {\n        // no more diagonals, make actual polyline\n        const indexCount = indices.length;\n        const outPolyline = new Array(indexCount);\n\n        if (flip) {\n            for (let i = 0; i < indexCount; i++) {\n                outPolyline[i] = polyline[indices[indexCount - 1 - i]];\n            }\n        } else {\n            for (let i = 0; i < indexCount; i++) {\n                outPolyline[i] = polyline[indices[i]];\n            }\n        }\n\n        output.push(outPolyline);\n    }\n}\n\nexport default function split2DPolygon(polyline: Array<vec2>, diagonals: Array<[number, number]>, output?: Array<Array<vec2>>, flip = false): Array<Array<vec2>> {\n    if (!output) {\n        output = [];\n    }\n\n    splitPolygonTo(polyline, Array.from({ length: polyline.length }, (_, i) => i), diagonals, output, flip);\n    return output;\n}", "import { vec2 } from 'gl-matrix';\nimport { TAU } from '../math/const-numbers';\nimport isClockwise2DPolygon from './is-clockwise-2d-polygon';\nimport sort2DIndices from './sort-2d-indices';\nimport split2DPolygon from './split-2d-polygon';\n\nenum VertexType {\n    Start,\n    End,\n    Regular,\n    Split,\n    Merge\n}\n\nfunction isAbove(p: vec2, q: vec2) {\n    return p[0] < q[0] || (p[0] === q[0] && p[1] < q[1]);\n}\n\nfunction interiorAngle(prev: vec2, cur: vec2, next: vec2) {\n    // XXX angles must be negated due to CCW winding order\n    const prevAngle = -Math.atan2(prev[1] - cur[1], prev[0] - cur[0]);\n    const nextAngle = -Math.atan2(next[1] - cur[1], next[0] - cur[0]);\n    // XXX mod used instead of remainder because angles can be negative\n    return (((nextAngle - prevAngle) % TAU) + TAU) % TAU;\n}\n\nfunction getLeftEdge(polyline: Array<vec2>, status: Set<number>, vertexCount: number, vertex: vec2) {\n    let leftEdge = -1;\n    let leftY = -Infinity;\n\n    for (const lineStartIndex of status) {\n        const lineEndIndex = (lineStartIndex + 1) % vertexCount;\n        const lineStart = polyline[lineStartIndex];\n        const lineEnd = polyline[lineEndIndex];\n\n        let lineMin, lineMax;\n        if (lineStart[0] > lineEnd[0]) {\n            lineMin = lineEnd;\n            lineMax = lineStart;\n        } else {\n            lineMax = lineEnd;\n            lineMin = lineStart;\n        }\n\n        if (vertex[0] >= lineMin[0] && vertex[0] <= lineMax[0]) {\n            // y = mx + c; m = dy / dx; c = y - mx\n            const m = (lineMax[1] - lineMin[1]) / (lineMax[0] - lineMin[0]);\n            const c = lineMin[1] - m * lineMin[0];\n            const y = m * vertex[0] + c;\n\n            if (y <= vertex[1] && y >= leftY) {\n                leftY = y;\n                leftEdge = lineStartIndex;\n            }\n        }\n    }\n\n    if (leftEdge === -1) {\n        throw new Error(`No edge to the left of vertex. Status: ${Array.from(status)}`);\n    }\n\n    return leftEdge;\n}\n\nexport default function partition2DPolygon(polyline: Array<vec2>, output?: Array<Array<vec2>>, isClockwiseHint?: boolean) {\n    // using monotone polygon partitioning algorithm from a book:\n    // Computational Geometry: Algorithms and Applications (second edition,\n    // section 3.2), by Mark de Berg, Marc van Krefeld, and Mark Overmars\n\n    // XXX the algorithm assumes that the input polygon is CCW, but sometimes it\n    // isn't because a uses wants to make, for example, an inverted extrusion.\n    // check for this case\n    if (isClockwiseHint === undefined) {\n        isClockwiseHint = isClockwise2DPolygon(polyline);\n    }\n\n    if (isClockwiseHint) {\n        polyline = polyline.slice().reverse();\n    }\n\n    // sort vertices in polyline. since our triangulation algorithm sweeps from\n    // -X to +X, sort by X values and then Y values, instead of Y then X from\n    // the original algorithm\n    const vertexCount = polyline.length;\n    const helpers = new Map<number, number>();\n    // XXX the original algorithm uses a BST for the status container instead of\n    // a set, but performance has been OK with a set. maybe change in the\n    // future?\n    const status = new Set<number>();\n    const types = new Map<number, VertexType>();\n    const diagonals = new Array<[number, number]>();\n\n    for (const index of sort2DIndices(polyline)) {\n        // get vertex type\n        const prevIndex = ((index - 1 % vertexCount) + vertexCount) % vertexCount;\n        const nextIndex = (index + 1) % vertexCount;\n        const prevVertex = polyline[prevIndex];\n        const vertex = polyline[index];\n        const nextVertex = polyline[nextIndex];\n\n        const abovePrev = isAbove(vertex, prevVertex);\n        const aboveNext = isAbove(vertex, nextVertex);\n\n        if (abovePrev && aboveNext) {\n            // this is either a start or split vertex. check internal angle\n            if (interiorAngle(prevVertex, vertex, nextVertex) < Math.PI) {\n                // start vertex\n                types.set(index, VertexType.Start);\n            } else {\n                // split vertex\n                types.set(index, VertexType.Split);\n\n                const leftEdge = getLeftEdge(polyline, status, vertexCount, vertex);\n                diagonals.push([index, helpers.get(leftEdge) as number]);\n                helpers.set(leftEdge, index);\n            }\n\n            // shared logic\n            status.add(index);\n            helpers.set(index, index);\n\n            continue;\n        } else if (!abovePrev && !aboveNext) {\n            // shared logic\n            const prevHelper = helpers.get(prevIndex);\n            if (prevHelper !== undefined && types.get(prevHelper) === VertexType.Merge) {\n                diagonals.push([index, prevHelper]);\n            }\n\n            status.delete(prevIndex);\n\n            // this is either an end or merge vertex. check internal angle\n            if (interiorAngle(prevVertex, vertex, nextVertex) < Math.PI) {\n                // end vertex\n                types.set(index, VertexType.End);\n            } else {\n                // merge vertex\n                types.set(index, VertexType.Merge);\n\n                const leftEdge = getLeftEdge(polyline, status, vertexCount, vertex);\n                const leftHelper = helpers.get(leftEdge);\n                if (leftHelper !== undefined && types.get(leftHelper) === VertexType.Merge) {\n                    diagonals.push([index, leftHelper]);\n                }\n\n                helpers.set(leftEdge, index);\n            }\n\n            continue;\n        }\n\n        // regular vertex\n        types.set(index, VertexType.Regular);\n\n        // check if interior lies to the right of the vertex. on a CCW polygon,\n        // the polygon interior always lies to the left of an edge, meaning that\n        // the interior lies to the right of a vertex when the edge to the next\n        // vertex is below the vertex\n        if (nextVertex[0] > vertex[0]) {\n            // interior to the right\n            const prevHelper = helpers.get(prevIndex);\n            if (prevHelper !== undefined && types.get(prevHelper) === VertexType.Merge) {\n                diagonals.push([index, prevHelper]);\n            }\n\n            status.delete(prevIndex);\n            status.add(index);\n            helpers.set(index, index);\n        } else {\n            // interior not to the right\n            const leftEdge = getLeftEdge(polyline, status, vertexCount, vertex);\n            const leftHelper = helpers.get(leftEdge);\n            if (leftHelper !== undefined && types.get(leftHelper) === VertexType.Merge) {\n                diagonals.push([index, leftHelper]);\n            }\n\n            helpers.set(leftEdge, index);\n        }\n    }\n\n    // get all partitions by finding all loops in the graph made by the original\n    // polyline and diagonals\n    return split2DPolygon(polyline, diagonals, output, isClockwiseHint);\n}", "import { vec2 } from 'gl-matrix';\nimport { tv0_2, tv1_2 } from '../math/temp';\nimport isClockwise2DPolygon from './is-clockwise-2d-polygon';\nimport isClockwise2DTriangle from './is-clockwise-2d-triangle';\nimport sort2DIndices from './sort-2d-indices';\n\nfunction addTriangle(output: Array<vec2>, index: number, clockwise: boolean, a: vec2, b: vec2, c: vec2): number {\n    output[index++] = a;\n\n    if (isClockwise2DTriangle(a, b, c) === clockwise) {\n        output[index++] = b;\n        output[index++] = c;\n    } else {\n        output[index++] = c;\n        output[index++] = b;\n    }\n\n    return index;\n}\n\nfunction isInInterval(index: number, start: number, end: number) {\n    if (start > end) {\n        return index >= start || index < end;\n    } else {\n        return index >= start && index < end;\n    }\n}\n\nexport default function triangulateMonotone2DPolygon(polyline: Array<vec2>, output?: Array<vec2>, index = 0, isClockwiseHint?: boolean): [triangles: Array<vec2>, lastIndex: number] {\n    const vertexCount = polyline.length;\n\n    // fast paths (and error conditions):\n    if (vertexCount < 3) {\n        throw new Error(`Expected input polyline with 3 or more vertices, got ${vertexCount}`);\n    }\n\n    const outputSize = index + (vertexCount - 2) * 3;\n    if (output) {\n        if (output.length < outputSize) {\n            output.length = outputSize;\n        }\n    } else {\n        output = new Array(outputSize);\n    }\n\n    if (vertexCount === 3) {\n        // already a triangle, copy it\n        output[index++] = vec2.clone(polyline[0]);\n        output[index++] = vec2.clone(polyline[1]);\n        output[index++] = vec2.clone(polyline[2]);\n\n        return [output, index];\n    }\n\n    // XXX don't do a special case for squares since the square may not be\n    // convex and may result in bad triangles\n\n    // general case: using monotone polygon triangulation algorithm from a book:\n    // Computational Geometry: Algorithms and Applications (second edition,\n    // section 3.3), by Mark de Berg, Marc van Krefeld, and Mark Overmars\n\n    // XXX triangle orientation is very chaotic, so it is properly oriented\n    // when inserting each triangle in the output instead of relying of the\n    // algorithm's scan order\n    if (isClockwiseHint === undefined) {\n        isClockwiseHint = isClockwise2DPolygon(polyline);\n    }\n\n    // sort vertices by XY respectively\n    const indices = sort2DIndices(polyline);\n    // XXX a vertex is in the \"other\"/\"second\" chain when it comes after or is\n    // at the right-most vertex (last in sorted array), and comes before the\n    // left-most vertex (first in sorted array)\n    const secondChainStart = indices[vertexCount - 1];\n    const secondChainEnd = indices[0];\n    let stack = [indices[0], indices[1]];\n\n    for (let i = 2; i < vertexCount - 1; i++) {\n        const thisIndex = indices[i];\n        const thisVertex = polyline[thisIndex];\n\n        const stackLen = stack.length;\n        const topIndex = stack[stackLen - 1];\n        const topVertex = polyline[topIndex];\n\n        if (isInInterval(thisIndex, secondChainStart, secondChainEnd) !== isInInterval(topIndex, secondChainStart, secondChainEnd)) {\n            // opposite chains\n            for (let j = 0; j < stackLen - 1; j++) {\n                index = addTriangle(output, index, isClockwiseHint, thisVertex, vec2.clone(polyline[stack[j]]), vec2.clone(polyline[stack[j + 1]]));\n            }\n\n            stack = [topIndex, thisIndex];\n        } else {\n            // same chain\n            let lastPoppedVertex = topVertex;\n            let lastPoppedIndex = stack.pop() as number;\n            const lastDelta = vec2.sub(tv1_2, lastPoppedVertex, thisVertex);\n\n            // swap if delta is going in opposite direction\n            if (thisIndex === (lastPoppedIndex + 1) % vertexCount !== isClockwiseHint) {\n                vec2.negate(lastDelta, lastDelta);\n            }\n\n            while (stack.length > 0) {\n                const nextPoppedIndex = stack[stack.length - 1];\n                const nextPoppedVertex = polyline[nextPoppedIndex];\n\n                // check if diagonal from current vertex to popped vertex is\n                // inside polygon. if not, stop popping\n                const delta = vec2.sub(tv0_2, nextPoppedVertex, lastPoppedVertex);\n                const cross = lastDelta[0] * delta[1] - lastDelta[1] * delta[0];\n\n                if (cross <= 0) {\n                    break;\n                }\n\n                stack.pop();\n                index = addTriangle(output, index, isClockwiseHint, thisVertex, vec2.clone(lastPoppedVertex), vec2.clone(nextPoppedVertex));\n                lastPoppedIndex = nextPoppedIndex;\n                lastPoppedVertex = nextPoppedVertex;\n            }\n\n            stack.push(lastPoppedIndex);\n            stack.push(thisIndex);\n        }\n    }\n\n    const lastVertex = polyline[indices[vertexCount - 1]];\n    const iterLen = stack.length - 1;\n\n    for (let i = 0; i < iterLen; i++) {\n        index = addTriangle(output, index, isClockwiseHint, vec2.clone(lastVertex), vec2.clone(polyline[stack[i]]), vec2.clone(polyline[stack[i + 1]]));\n    }\n\n    return [output, index];\n}", "import type { vec2 } from 'gl-matrix';\n\nexport default function isClockwise2DTriangle(a: vec2, b: vec2, c: vec2): boolean {\n    // similar to isClockwise2DPolygon, but optimised for 3 points\n    return (\n        (b[0] - a[0]) * (b[1] + a[1]) +\n        (c[0] - b[0]) * (c[1] + b[1]) +\n        (a[0] - c[0]) * (a[1] + c[1])\n    ) >= 0;\n}", "import { vec2 } from 'gl-matrix';\nimport isClockwise2DPolygon from './is-clockwise-2d-polygon';\nimport partition2DPolygon from './partition-2d-polygon';\nimport triangulateMonotone2DPolygon from './triangulate-monotone-2d-polygon';\n\nexport default function triangulate2DPolygon(polyline: Array<vec2>, output?: Array<vec2>): Array<vec2> {\n    const isClockwiseHint = isClockwise2DPolygon(polyline);\n    const partitions = partition2DPolygon(polyline, undefined, isClockwiseHint);\n    let outputSize = 0;\n\n    for (const partition of partitions) {\n        outputSize += (partition.length - 2) * 3;\n    }\n\n    if (output) {\n        if (output.length < outputSize) {\n            output.length = outputSize;\n        }\n    } else {\n        output = new Array(outputSize);\n    }\n\n    let index = 0;\n    for (const partition of partitions) {\n        [output, index] = triangulateMonotone2DPolygon(partition, output, index, isClockwiseHint);\n    }\n\n    return output;\n}", "import { curveExtrude } from './curve-extrusion-helper';\n\nimport type { CurveExtrusionOptions } from './curve-extrusion-helper';\nimport type { vec2, vec3 } from 'gl-matrix';\nimport type { CurveFrame } from './curve-frame';\n\nexport default function linearExtrude(polyline: Array<vec2>, depth: number, options?: CurveExtrusionOptions) {\n    const positions: Array<vec3> = [[0, 0, 0], [0, 0, depth]];\n    const forwardFrame: CurveFrame = depth >= 0\n        ? [[0, 1, 0], [1, 0, 0], [0, 0, 1]]\n        : [[0, 1, 0], [-1, 0, 0], [0, 0, -1]];\n    const frames = [forwardFrame, forwardFrame];\n\n    return curveExtrude(polyline, positions, frames, options);\n}", "import { quat, vec3 } from 'gl-matrix';\nimport { HALF_PI, TAU } from '../math/const-numbers';\nimport { tq0, tv0, tv1, tv2 } from '../math/temp';\n\nimport type { CurveFrames } from './curve-frame';\n\nexport interface RMFOptions {\n    // end boundary condition for the RMF curve; the up direction at the end of\n    // the curve\n    endNormal?: vec3;\n    // how many twists should be added to the curve. 0 by default\n    twists?: number;\n}\n\nexport function makeRotationMinimizingFrames(positions: Array<vec3>, tangents: Array<vec3>, startNormal: vec3, options?: RMFOptions): CurveFrames {\n    // XXX startNormal should be a unit vector pointing up, or if the start is\n    // rotated, then the rotated up unit vector\n\n    // validate curve\n    const pointCount = positions.length;\n\n    if (tangents.length < pointCount) {\n        throw new Error('There must be at least one tangent per point');\n    }\n\n    if (pointCount < 2) {\n        throw new Error('There must be at least 1 segment (2 points) in the curve');\n    }\n\n    // compute rotation minimizing frames. using method from this paper:\n    // https://www.microsoft.com/en-us/research/publication/computation-rotation-minimizing-frames/\n    const frames: CurveFrames = new Array(pointCount);\n    const startTangent = tangents[0];\n    const startBinormal = vec3.cross(vec3.create(), startTangent, startNormal);\n    // first frame = (r,s,t); r = normal, s = binormal, t = tangent\n    frames[0] = [startNormal, startBinormal, startTangent];\n\n    for (let i = 0; i < pointCount - 1; i++) {\n        const v_1 = vec3.sub(tv0, positions[i + 1], positions[i]);\n        const c_1 = vec3.dot(v_1, v_1);\n        const r_i = frames[i][0];\n        const t_i = frames[i][2];\n        const temp = -2 / c_1;\n        const r_L_i = vec3.scaleAndAdd(tv1, r_i, v_1, vec3.dot(v_1, r_i) * temp);\n        const t_L_i = vec3.scaleAndAdd(tv2, t_i, v_1, vec3.dot(v_1, t_i) * temp);\n\n        const t_i1 = tangents[i + 1];\n\n        const v_2 = vec3.sub(tv2, t_i1, t_L_i);\n        const c_2 = vec3.dot(v_2, v_2);\n        const r_i1 = vec3.scaleAndAdd(vec3.create(), r_L_i, v_2, vec3.dot(v_2, r_L_i) * -2 / c_2);\n        const s_i1 = vec3.cross(vec3.create(), t_i1, r_i1);\n\n        frames[i + 1] = [r_i1, s_i1, t_i1];\n    }\n\n    const endNormal = options?.endNormal;\n    const twists = options?.twists ?? 0;\n    if (endNormal || twists > 0) {\n        let angleErr = 0;\n\n        if (endNormal) {\n            // end normal included. calculate the error between the computed\n            // normal in the last frame and the wanted normal. convert it to an\n            // angle.\n\n            // this is an extension to the algorithm described in the same paper\n            // as before (section 6.3: variational principles for rmf with\n            // boundary conditions)\n\n            const endTangent = tangents[pointCount - 1];\n            const endBinormal = vec3.cross(vec3.create(), endTangent, endNormal);\n            const actualNormal = frames[pointCount - 1][0];\n\n            const dx = vec3.dot(endBinormal, actualNormal);\n            const dy = vec3.dot(endNormal, actualNormal);\n\n            if (dx !== 0 && dy !== 0) {\n                angleErr = Math.atan2(dy, dx) - HALF_PI;\n            }\n        }\n\n        angleErr += TAU * twists;\n\n        if (angleErr !== 0) {\n            // divide the angle evenly along the curve (angular speed). apply\n            // the angular speed to the whole curve\n            // XXX the technique's article uses a curvature value that is\n            // calculated from the second differential of the curve, however, we\n            // are estimating it by getting the length of each segment instead.\n            // the more segments there are, the more accurate the curvature\n            // value is\n            let totalLength = 0;\n            let lastPos = positions[0];\n            for (let i = 1; i < pointCount; i++) {\n                const curPos = positions[i];\n                totalLength += vec3.distance(lastPos, curPos);\n                lastPos = curPos;\n            }\n\n            let interpLength = 0;\n            lastPos = positions[0];\n            for (let i = 1; i < pointCount; i++) {\n                const [r, s, _t] = frames[i];\n                const curPos = positions[i];\n                interpLength += vec3.distance(lastPos, curPos);\n                lastPos = curPos;\n\n                const thisAngleErr = angleErr * interpLength / totalLength;\n                quat.setAxisAngle(tq0, tangents[i], thisAngleErr);\n                vec3.transformQuat(r, r, tq0);\n                vec3.transformQuat(s, s, tq0);\n            }\n        }\n    }\n\n    return frames;\n}", "import { curveExtrude } from './curve-extrusion-helper';\nimport { makeRotationMinimizingFrames } from './make-rotation-minimizing-frames';\n\nimport type { CurveExtrusionOptions } from './curve-extrusion-helper';\nimport type { vec2, vec3 } from 'gl-matrix';\nimport type { RMFOptions } from './make-rotation-minimizing-frames';\n\nexport type RMFCurveExtrusionOptions = CurveExtrusionOptions & RMFOptions;\n\nexport function rotationMinimizingCurveExtrude(polyline: Array<vec2>, positions: Array<vec3>, tangents: Array<vec3>, startNormal: vec3, options?: RMFCurveExtrusionOptions) {\n    return curveExtrude(\n        polyline,\n        positions,\n        makeRotationMinimizingFrames(positions, tangents, startNormal, options),\n        options\n    );\n}", "import { vec2 } from 'gl-matrix';\nimport { TAU } from '../math/const-numbers';\n\nexport default function makeRegularPolyline(radius: number, sides: number, clockwise = false): Array<vec2> {\n    if (sides < 3) {\n        throw new Error('There must be at least 3 sides in a regular polyline');\n    }\n\n    const polyline = new Array(sides);\n    const sidesM1 = sides - 1;\n\n    for (let i = 0; i < sides; i++) {\n        const j = clockwise ? i : (sidesM1 - i);\n        const angle = TAU * j / sides;\n        const y = Math.cos(angle) * radius;\n        const x = Math.sin(angle) * radius;\n        polyline[i] = vec2.fromValues(x, y);\n    }\n\n    return polyline;\n}", "import makeRegularPolyline from './regular-polyline';\n\nimport type { vec2 } from 'gl-matrix';\n\nexport default function makeCirclePolyline(radius: number, clockwise = false, subDivisions = 12): Array<vec2> {\n    return makeRegularPolyline(radius, subDivisions, clockwise);\n}", "import { vec2 } from 'gl-matrix';\n\nexport default function makeCubePolyline(length: number, clockwise = false): Array<vec2> {\n    const half = length / 2;\n    return clockwise ? [\n        vec2.fromValues(half, half), vec2.fromValues(half, -half),\n        vec2.fromValues(-half, -half), vec2.fromValues(-half, half)\n    ] : [\n        vec2.fromValues(half, half), vec2.fromValues(-half, half),\n        vec2.fromValues(-half, -half), vec2.fromValues(half, -half)\n    ];\n}", "import { vec2 } from 'gl-matrix';\n\nexport default function makeRectanglePolyline(width: number, height: number, clockwise = false): Array<vec2> {\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n    return clockwise ? [\n        vec2.fromValues(halfWidth, halfHeight), vec2.fromValues(halfWidth, -halfHeight),\n        vec2.fromValues(-halfWidth, -halfHeight), vec2.fromValues(-halfWidth, halfHeight)\n    ] : [\n        vec2.fromValues(halfWidth, halfHeight), vec2.fromValues(-halfWidth, halfHeight),\n        vec2.fromValues(-halfWidth, -halfHeight), vec2.fromValues(halfWidth, -halfHeight)\n    ];\n}", "import { vec2 } from 'gl-matrix';\nimport { TAU } from '../math/const-numbers';\n\nexport default function makeStarPolyline(outerRadius: number, innerRadius: number, sides: number, clockwise = false): Array<vec2> {\n    if (sides < 3) {\n        throw new Error('There must be at least 3 sides in a star polyline');\n    }\n\n    const polyline = new Array(sides * 2);\n    const sidesM1 = sides - 1;\n    const halfAngle = TAU / sides / 2;\n    let k = 0;\n\n    for (let i = 0; i < sides; i++) {\n        const j = clockwise ? i : (sidesM1 - i);\n\n        const outerAngle = TAU * j / sides;\n        const outerY = Math.cos(outerAngle) * outerRadius;\n        const outerX = Math.sin(outerAngle) * outerRadius;\n        const outerPos = vec2.fromValues(outerX, outerY);\n\n        const innerAngle = outerAngle + halfAngle;\n        const innerY = Math.cos(innerAngle) * innerRadius;\n        const innerX = Math.sin(innerAngle) * innerRadius;\n        const innerPos = vec2.fromValues(innerX, innerY);\n\n        if (clockwise) {\n            polyline[k++] = outerPos;\n            polyline[k++] = innerPos;\n        } else {\n            polyline[k++] = innerPos;\n            polyline[k++] = outerPos;\n        }\n    }\n\n    return polyline;\n}", "import { vec2 } from 'gl-matrix';\nimport { MaterialAttributeStandardType } from '../base/MaterialDefinition';\n\nimport type { vec3 } from 'gl-matrix';\nimport type { Polygon } from '../math/Polygon';\nimport type Vertex from '../math/Vertex';\nimport type { MaterialAttribute, MaterialAttributes, MaterialDefinitions } from '../base/MaterialDefinition';\nimport type OctreeCSG from '../base/OctreeCSG';\n\nexport type ProjectorCondition = (polygon: Polygon) => boolean;\nexport type AttributesMap = Map<number, Array<number | null>>;\nexport type NewUVsMap = Map<number, number>;\n\nexport interface ProjectorOptions {\n    /**\n     * If true, then the projector will assign a material and generate new UVs\n     * for the material, otherwise, only the material assignment will be done.\n     * Defaults to true.\n     */\n    generatesUVs?: boolean;\n}\n\nexport abstract class Projector<ExtraPolygonDataType = undefined> {\n    readonly conditions = new Array<ProjectorCondition>();\n    generatesUVs: boolean;\n\n    constructor(options?: ProjectorOptions) {\n        this.generatesUVs = options?.generatesUVs ?? true;\n    }\n\n    protected canProjectToPolygon(polygon: Polygon): boolean {\n        for (const condition of this.conditions) {\n            if (!condition(polygon)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    abstract clone(): Projector<ExtraPolygonDataType>;\n    protected abstract projectUV(position: vec3, extraPolygonData: ExtraPolygonDataType): vec2;\n    protected abstract projectSingle(polygon: Polygon, newMaterialID: number, attributeMaps: AttributesMap, newUVsIdx: number | null, attributes: MaterialAttributes | null): void;\n\n    protected projectVertex(vertex: Vertex, attributeMap: Array<number | null>, newUVsIdx: number | null, attributes: MaterialAttributes | null, extraPolygonData: ExtraPolygonDataType) {\n        if (!vertex.extra) {\n            throw new Error('Expected extra polygon attributes, but got undefined');\n        }\n\n        const curExtra = [...vertex.extra];\n        vertex.extra.length = attributes === null ? 0 : attributes.length;\n\n        if (vertex.extra.length > 0) {\n            for (const [aIdx, bIdx] of attributeMap.entries()) {\n                if (bIdx !== null) {\n                    if (this.generatesUVs && (attributes as MaterialAttributes)[bIdx].type === MaterialAttributeStandardType.TextureCoordinate) {\n                        const [u, v] = this.projectUV(vertex.pos, extraPolygonData);\n                        vec2.set(curExtra[aIdx] as vec2, u, v);\n                    }\n\n                    vertex.extra[bIdx] = curExtra[aIdx];\n                }\n            }\n\n            if (newUVsIdx !== null) {\n                const [u, v] = this.projectUV(vertex.pos, extraPolygonData);\n                vertex.extra[newUVsIdx] = vec2.fromValues(u, v);\n            }\n        }\n    }\n\n    protected projectSingleWithExtraData(polygon: Polygon, newMaterialID: number, attributeMaps: AttributesMap, newUVsIdx: number | null, attributes: MaterialAttributes | null, extraPolygonData: ExtraPolygonDataType) {\n        const attributeMap = attributeMaps.get(polygon.shared) as Array<number>;\n        polygon.shared = newMaterialID;\n        this.projectVertex(polygon.vertices[0], attributeMap, newUVsIdx, attributes, extraPolygonData);\n        this.projectVertex(polygon.vertices[1], attributeMap, newUVsIdx, attributes, extraPolygonData);\n        this.projectVertex(polygon.vertices[2], attributeMap, newUVsIdx, attributes, extraPolygonData);\n    }\n\n    private handlePolygon(polygon: Polygon, materialMap: Map<number, number>, attributeMaps: AttributesMap, newUVsMap: NewUVsMap, materials: MaterialDefinitions | null) {\n        if (this.canProjectToPolygon(polygon)) {\n            const newMaterialID = materialMap.get(polygon.shared);\n            if (newMaterialID !== undefined) {\n                this.projectSingle(polygon, newMaterialID, attributeMaps, newUVsMap.get(polygon.shared) ?? null, materials?.get(polygon.shared) ?? null);\n            }\n        }\n    }\n\n    private makeAttributesMap(materialMap: Map<number, number>, materials: MaterialDefinitions | null): [attributeMaps: AttributesMap, newUVsMap: NewUVsMap] {\n        // validate material map and build attribute map for each material being\n        // mapped\n        const attributeMaps: AttributesMap = new Map();\n        const newUVsMap: NewUVsMap = new Map();\n\n        if (materials) {\n            for (const [a, b] of materialMap) {\n                const bAttributes = materials.get(b);\n\n                if (bAttributes === undefined || bAttributes.length === 0) {\n                    attributeMaps.set(a, []);\n                    continue;\n                }\n\n                const aAttributes = materials.get(a);\n\n                if (aAttributes === undefined || aAttributes.length === 0) {\n                    throw new Error(`Projection failed; material ID ${a} has no extra attributes and is not compatible with material ID ${b}`);\n                }\n\n                const bAttributesLeft = new Map(bAttributes.entries());\n                const extraIDsMap = new Array<number | null>();\n\n                for (const aAttribute of aAttributes) {\n                    let attrMissing = true;\n                    for (const [bIdx, bAttribute] of bAttributesLeft) {\n                        if (aAttribute.type === bAttribute.type) {\n                            extraIDsMap.push(bIdx);\n                            bAttributesLeft.delete(bIdx);\n                            attrMissing = false;\n                            break;\n                        }\n                    }\n\n                    if (attrMissing) {\n                        console.warn(`No matching attribute for extra attribute at index ${extraIDsMap.length} (mapping material ID ${a} to ${b})`);\n                        extraIDsMap.push(null);\n                    }\n                }\n\n                if (bAttributesLeft.size === 1 && this.generatesUVs) {\n                    // XXX if there is a missing attribute for UVs and this\n                    // projector generates UVs, then add a special case where\n                    // the source material doesn't need existing UV values\n                    const [bIdx, bAttribute]: [number, MaterialAttribute] = bAttributesLeft.entries().next().value;\n\n                    if (bAttribute.type === MaterialAttributeStandardType.TextureCoordinate) {\n                        newUVsMap.set(a, bIdx);\n                        bAttributesLeft.delete(bIdx);\n                    }\n                }\n\n                if (bAttributesLeft.size > 0) {\n                    const missing = `index${bAttributesLeft.size > 1 ? 'es' : ''} ${Array.from(bAttributesLeft.keys()).join(', ')}`;\n                    throw new Error(`Projection failed; material ID ${a} is missing some extra attributes (${missing}) and is not compatible with material ID ${b}`);\n                }\n\n                attributeMaps.set(a, extraIDsMap);\n            }\n        } else {\n            // no material definitions. only using vertex positions\n            for (const a of materialMap.keys()) {\n                attributeMaps.set(a, []);\n            }\n        }\n\n        return [attributeMaps, newUVsMap];\n    }\n\n    private projectSubtree(octree: OctreeCSG, materialMap: Map<number, number>, materials: MaterialDefinitions | null, attributeMaps: AttributesMap, newUVsMap: NewUVsMap) {\n        // project to all polygons in this level\n        for (const polygon of octree.treePolygons) {\n            this.handlePolygon(polygon, materialMap, attributeMaps, newUVsMap, materials);\n        }\n\n        // replace material definitions if needed\n        if (materials) {\n            octree.materials = materials;\n        }\n\n        // go to lower levels\n        for (const subTree of octree.lowerLevels) {\n            this.projectSubtree(subTree, materialMap, materials, attributeMaps, newUVsMap);\n        }\n    }\n\n    projectOctree(octree: OctreeCSG, materialMap: Map<number, number>, extraMaterials: MaterialDefinitions | null = null) {\n        // merge material definitions. must not have conflicts\n        let materials: MaterialDefinitions | null = null;\n        if (extraMaterials && extraMaterials.size > 0) {\n            materials = new Map(octree.materials.entries());\n\n            for (const [materialID, extraAttributes] of extraMaterials) {\n                materials.set(materialID, extraAttributes);\n            }\n        }\n\n        // if a destination material is missing, use the source material\n        for (const [source, destination] of materialMap) {\n            if (!octree.materials.has(destination)) {\n                if (materials && materials.has(destination)) {\n                    continue;\n                }\n\n                const attrs = octree.materials.get(source) as MaterialAttributes;\n\n                if (materials) {\n                    materials.set(destination, attrs);\n                } else {\n                    materials = new Map(octree.materials.entries());\n                    materials.set(destination, attrs);\n                }\n            }\n        }\n\n        const [attributeMaps, newUVsMap] = this.makeAttributesMap(materialMap, materials);\n\n        this.projectSubtree(octree, materialMap, materials, attributeMaps, newUVsMap);\n    }\n\n    project(polygons: Polygon | Iterable<Polygon>, materialMap: Map<number, number>, materials: MaterialDefinitions | null = null) {\n        const [attributeMaps, newUVsMap] = this.makeAttributesMap(materialMap, materials);\n\n        // project to polygons\n        if (Symbol.iterator in polygons) {\n            // iterable\n            for (const polygon of polygons as Iterable<Polygon>) {\n                this.handlePolygon(polygon, materialMap, attributeMaps, newUVsMap, materials);\n            }\n        } else {\n            // single polygon\n            this.handlePolygon(polygons as Polygon, materialMap, attributeMaps, newUVsMap, materials);\n        }\n    }\n}", "import { Projector } from './Projector';\n\nimport type { ProjectorOptions } from './Projector';\nimport type { mat4 } from 'gl-matrix';\n\nexport interface DirectionalProjectorOptions extends ProjectorOptions {\n    /**\n     * If true, then the back faces will not be reassigned a material. A back\n     * face is a face with a normal in the same direction as the projection, NOT\n     * a back face in the context of a mesh. Defaults to true.\n     */\n    ignoreBackFaces?: boolean;\n    /**\n     * Threshold, from 0 to 1, for a projection to be valid. If the threshold is\n     * 1, then the direction of a projection must be exactly parallel to the\n     * surface's normal. If the threshold is 0, then the projection will still\n     * be valid if the projection is perpendicular to the surface's normal.\n     * Essentially, this threshold is a check on the dot product between the\n     * projection and the surface's normal; if the threshold is 0.5, then the\n     * threshold represents a 45 degree angle between the surface normal and the\n     * projection. Defaults to 0.\n     */\n    threshold?: number;\n}\n\nexport abstract class DirectionalProjector<ExtraPolygonDataType = undefined> extends Projector<ExtraPolygonDataType> {\n    ignoreBackFaces: boolean;\n    // XXX threshold must be enforced BY CHILD CLASSES, not by the\n    // DirectionalProjector class itself, since it doesnt know what direction(s)\n    // the child classes will have\n    threshold: number;\n\n    constructor(options?: DirectionalProjectorOptions) {\n        super(options);\n\n        this.ignoreBackFaces = options?.ignoreBackFaces ?? true;\n        this.threshold = options?.threshold ?? 0;\n    }\n\n    abstract applyMatrix(matrix: mat4): void;\n}", "import { DirectionalProjector } from './DirectionalProjector';\nimport { mat3, vec2, vec3 } from 'gl-matrix';\nimport { tmpm3, tv0 } from '../math/temp';\n\nimport type { Polygon } from '../math/Polygon';\nimport type { AttributesMap } from './Projector';\nimport type { MaterialAttributes } from '../base/MaterialDefinition';\nimport type { DirectionalProjectorOptions } from './DirectionalProjector';\nimport type { mat4 } from 'gl-matrix';\n\nexport interface FlatProjectorOptions extends DirectionalProjectorOptions {\n    /** The width of a repeating tile in the flat projection. Defaults to 1. */\n    width?: number;\n    /** The height of a repeating tile in the flat projection. Defaults to 1. */\n    height?: number;\n}\n\nexport class FlatProjector extends DirectionalProjector {\n    protected upTangent = vec3.create();\n    protected invWidth: number;\n    protected invHeight: number;\n    protected uOffset: number;\n    protected vOffset: number;\n    protected width: number;\n    protected height: number;\n\n    constructor(protected origin: vec3, protected normal: vec3, protected rightTangent: vec3, options?: FlatProjectorOptions) {\n        super(options);\n\n        this.width = options?.width ?? 1;\n        this.height = options?.height ?? 1;\n\n        vec3.cross(this.upTangent, normal, rightTangent);\n        this.invWidth = 1 / this.width;\n        this.invHeight = 1 / this.height;\n\n        const [uOffset, vOffset] = this.projectUV(origin);\n        this.uOffset = uOffset + 0.5 * this.invWidth;\n        this.vOffset = vOffset + 0.5 * this.invHeight;\n    }\n\n    override clone(): FlatProjector {\n        return new FlatProjector(\n            vec3.clone(this.origin),\n            vec3.clone(this.normal),\n            vec3.clone(this.rightTangent),\n            {\n                width: this.width,\n                height: this.height,\n                ignoreBackFaces: this.ignoreBackFaces,\n                threshold: this.threshold,\n                generatesUVs: this.generatesUVs,\n            }\n        );\n    }\n\n    protected override projectUV(position: vec3): vec2 {\n        // p' = p - (n . (p - o)) * n\n        // tv0 === p'\n        vec3.sub(tv0, position, this.origin);\n        const tempDot = vec3.dot(this.normal, tv0);\n        vec3.scaleAndAdd(tv0, position, this.normal, -tempDot);\n\n        // extract u and v component from projected position\n        return vec2.fromValues(\n            vec3.dot(tv0, this.rightTangent) * this.invWidth,\n            vec3.dot(tv0, this.upTangent) * this.invHeight\n        );\n    }\n\n    protected override projectSingle(polygon: Polygon, newMaterialID: number, attributeMaps: AttributesMap, newUVsIdx: number | null, attributes: MaterialAttributes | null) {\n        const dotProd = vec3.dot(this.normal, polygon.plane.unsafeNormal);\n        if (!(this.ignoreBackFaces && dotProd <= 0) && (this.threshold === 0 || Math.abs(dotProd) >= this.threshold)) {\n            super.projectSingleWithExtraData(polygon, newMaterialID, attributeMaps, newUVsIdx, attributes, undefined);\n        }\n    }\n\n    applyMatrix(matrix: mat4): void {\n        vec3.transformMat4(this.origin, this.origin, matrix);\n        mat3.normalFromMat4(tmpm3, matrix);\n        vec3.transformMat3(this.normal, this.normal, tmpm3);\n        vec3.normalize(this.normal, this.normal);\n        vec3.transformMat3(this.rightTangent, this.rightTangent, tmpm3);\n        vec3.normalize(this.rightTangent, this.rightTangent);\n        vec3.transformMat3(this.upTangent, this.upTangent, tmpm3);\n        vec3.normalize(this.upTangent, this.upTangent);\n    }\n}", "import { DirectionalProjector } from './DirectionalProjector';\nimport { mat3, vec2, vec3 } from 'gl-matrix';\nimport { TAU } from '../math/const-numbers';\nimport { tmpm3, tv0, tv1, tv2 } from '../math/temp';\n\nimport type { DirectionalProjectorOptions } from './DirectionalProjector';\nimport type { AttributesMap } from './Projector';\nimport type { MaterialAttributes } from '../base/MaterialDefinition';\nimport type { Polygon } from '../math/Polygon';\nimport type { mat4 } from 'gl-matrix';\n\nexport interface TubeProjectorOptions extends DirectionalProjectorOptions {\n    /** The length of a repeating tile along the tube. Defaults to 1. */\n    length?: number;\n    /** The angle at which the projection repeats. Defaults to 360 deg (2Pi). */\n    wrapAngle?: number;\n    /**\n     * Should the projection be done on the inside of the tube? Defaults to\n     * false.\n     */\n    useInnerFaces?: boolean;\n    /**\n     * Should the UVs be inverted? Note that this is different than\n     * useInnerFaces; useInnerFaces inverts the projection direction which also\n     * inverts the UVs, but this only inverts the UVs while keeping the same\n     * projection direction, which is useful when, for example, projecting to a\n     * solid that will subtract another. Defaults to false.\n     */\n    invertTexCoords?: boolean;\n}\n\nexport class TubeProjector extends DirectionalProjector<boolean> {\n    protected binormal = vec3.create();\n    protected length: number;\n    protected wrapAngle: number;\n    protected invLength: number;\n    protected uMul: number;\n    useInnerFaces: boolean;\n    invertTexCoords: boolean;\n\n    constructor(protected origin: vec3, protected direction: vec3, protected normal: vec3, options?: TubeProjectorOptions) {\n        super(options);\n\n        vec3.cross(this.binormal, this.normal, this.direction);\n        this.length = options?.length ?? 1;\n        this.wrapAngle = options?.wrapAngle ?? TAU;\n        this.invLength = 1 / this.length;\n        this.uMul = TAU / this.wrapAngle;\n        this.useInnerFaces = options?.useInnerFaces ?? false;\n        this.invertTexCoords = options?.invertTexCoords ?? false;\n    }\n\n    override clone(): TubeProjector {\n        return new TubeProjector(\n            vec3.clone(this.origin),\n            vec3.clone(this.direction),\n            vec3.clone(this.normal),\n            {\n                length: this.length,\n                wrapAngle: this.wrapAngle,\n                useInnerFaces: this.useInnerFaces,\n                invertTexCoords: this.invertTexCoords,\n                ignoreBackFaces: this.ignoreBackFaces,\n                threshold: this.threshold,\n                generatesUVs: this.generatesUVs,\n            }\n        );\n    }\n\n    get needsInvertedTexCoords(): boolean {\n        // equivalent to: useInnerFaces XOR invertTexCoords\n        return this.useInnerFaces !== this.invertTexCoords;\n    }\n\n    protected override projectUV(position: vec3, uWrapsAround: boolean): vec2 {\n        // get v from tube direction\n        vec3.sub(tv1, position, this.origin);\n        const v = vec3.dot(this.direction, tv1) * this.invLength - 0.5;\n\n        // get u from angle around direction\n        // 1. get point along tube direction that is perpendicular to position\n        const tubeDotPos = vec3.dot(tv1, this.direction);\n        vec3.scaleAndAdd(tv2, this.origin, this.direction, tubeDotPos);\n        vec3.sub(tv2, position, tv2);\n        vec3.normalize(tv2, tv2);\n\n        // 2. get angle between normal and perpendicular around tube direction\n        // theta = atan2((tv2 x this.normal) . this.direction, tv2 . this.normal)\n        // u = theta / PI\n        vec3.cross(tv0, tv2, this.normal);\n        let u = Math.atan2(\n            vec3.dot(tv0, this.direction),\n            vec3.dot(tv2, this.normal)\n        ) / TAU + 0.5;\n\n        // 3. correct u values that wrapped around by checking angle between\n        // polygon average point and tube direction. flip u if using the inside\n        // of the tube. use the correct wrapping angle\n        if (uWrapsAround && u < 0.25) {\n            u += 1;\n        } else if (!uWrapsAround && u > 0.75) {\n            u -= 1;\n        }\n\n        u *= this.uMul;\n\n        if (!this.needsInvertedTexCoords) {\n            u = 1 - u;\n        }\n\n        return vec2.fromValues(u, v);\n    }\n\n    protected override projectSingle(polygon: Polygon, newMaterialID: number, attributeMaps: AttributesMap, newUVsIdx: number | null, attributes: MaterialAttributes | null) {\n        // check if polygon will wrap around\n        // 1. get point along tube direction that is perpendicular to polygon\n        // midpoint\n        const mid = polygon.midpoint;\n        vec3.sub(tv1, mid, this.origin);\n        const tubeDotPos = vec3.dot(tv1, this.direction);\n        const tubePerp = vec3.create();\n        vec3.scaleAndAdd(tubePerp, this.origin, this.direction, tubeDotPos);\n        vec3.sub(tubePerp, mid, tubePerp);\n        vec3.normalize(tubePerp, tubePerp);\n\n        // 2. get angle between normal and perpendicular around tube direction\n        // theta = atan2((tubePerp x this.normal) . this.direction, tubePerp . this.normal)\n        // u = theta / PI\n        vec3.cross(tv0, tubePerp, this.normal);\n        const u = Math.atan2(\n            vec3.dot(tv0, this.direction),\n            vec3.dot(tubePerp, this.normal)\n        );\n\n        if (this.ignoreBackFaces) {\n            // 3. flip normal if using the inside of the tube\n            if (this.useInnerFaces) {\n                vec3.negate(tubePerp, tubePerp);\n            }\n\n            if (vec3.dot(tubePerp, polygon.plane.unsafeNormal) <= 0) {\n                return;\n            }\n        }\n\n        super.projectSingleWithExtraData(polygon, newMaterialID, attributeMaps, newUVsIdx, attributes, u >= 0);\n    }\n\n    applyMatrix(matrix: mat4): void {\n        vec3.transformMat4(this.origin, this.origin, matrix);\n        mat3.normalFromMat4(tmpm3, matrix);\n        vec3.transformMat3(this.direction, this.direction, tmpm3);\n        vec3.normalize(this.direction, this.direction);\n        vec3.transformMat3(this.normal, this.normal, tmpm3);\n        vec3.normalize(this.normal, this.normal);\n        vec3.transformMat3(this.binormal, this.binormal, tmpm3);\n        vec3.normalize(this.binormal, this.binormal);\n    }\n}", "import { mat3, mat4, vec2, vec3 } from 'gl-matrix';\nimport { TAU } from '../math/const-numbers';\nimport { tmpm3, tv0, tv1 } from '../math/temp';\nimport { DirectionalProjector } from './DirectionalProjector';\n\nimport type { DirectionalProjectorOptions } from './DirectionalProjector';\nimport { Polygon } from '../math/Polygon';\nimport { AttributesMap } from './Projector';\nimport { MaterialAttributes } from '../base/MaterialDefinition';\n\nexport interface SphereProjectorOptions extends DirectionalProjectorOptions {\n    /**\n     * The yaw angle at which the projection repeats. Defaults to 360 deg\n     * (2Pi).\n     */\n    uWrapAngle?: number;\n    /**\n     * The pitch angle at which the projection repeats. Defaults to 180 deg\n     * (Pi).\n     */\n    vWrapAngle?: number;\n    /**\n     * Should the projection be done on the inside of the tube? Defaults to\n     * false.\n     */\n    useInnerFaces?: boolean;\n}\n\nexport class SphereProjector extends DirectionalProjector<boolean> {\n    protected front = vec3.create();\n    protected uWrapAngle: number;\n    protected vWrapAngle: number;\n    protected uMul: number;\n    protected vMul: number;\n    useInnerFaces: boolean;\n\n    constructor(protected origin: vec3, protected up: vec3, protected right: vec3, options?: SphereProjectorOptions) {\n        super(options);\n\n        vec3.cross(this.front, this.right, this.up);\n        this.uWrapAngle = options?.uWrapAngle ?? TAU;\n        this.vWrapAngle = options?.vWrapAngle ?? Math.PI;\n        this.uMul = TAU / this.uWrapAngle;\n        this.vMul = Math.PI / this.vWrapAngle;\n        this.useInnerFaces = options?.useInnerFaces ?? false;\n    }\n\n    override clone(): SphereProjector {\n        return new SphereProjector(\n            vec3.clone(this.origin),\n            vec3.clone(this.up),\n            vec3.clone(this.right),\n            {\n                uWrapAngle: this.uWrapAngle,\n                vWrapAngle: this.vWrapAngle,\n                useInnerFaces: this.useInnerFaces,\n                ignoreBackFaces: this.ignoreBackFaces,\n                threshold: this.threshold,\n                generatesUVs: this.generatesUVs,\n            }\n        );\n    }\n\n    protected override projectUV(position: vec3, uWrapsAround: boolean): vec2 {\n        // 1. get relative position\n        vec3.sub(tv1, position, this.origin);\n        vec3.normalize(tv1, tv1);\n\n        // 2. get normalized angles (-PI to PI) from relative position in sphere\n        // and turn them into the 0 to 1 range\n        let u = this.getNormalisedAngle(tv1, this.up, this.right);\n        let v = this.getLatAngle(tv1, this.up);\n\n        // 3. correct uv values that wrapped around by checking angle of polygon\n        // average point in sphere. use the correct wrapping angle\n        if (!uWrapsAround && u > 0.75) {\n            u -= 1;\n        } else if (uWrapsAround && u < 0.25) {\n            u += 1;\n        }\n\n        u *= this.uMul;\n        v *= this.vMul;\n\n        return vec2.fromValues(u, v);\n    }\n\n    protected override projectSingle(polygon: Polygon, newMaterialID: number, attributeMaps: AttributesMap, newUVsIdx: number | null, attributes: MaterialAttributes | null) {\n        // check if polygon will wrap around\n        // 1. get average point of polygon\n        vec3.set(tv0, 0, 0, 0);\n        for (const vertex of polygon.vertices) {\n            vec3.add(tv0, tv0, vertex.pos);\n        }\n\n        vec3.scale(tv0, tv0, 1 / polygon.vertices.length);\n        const avg = vec3.create();\n        vec3.sub(avg, tv0, this.origin);\n        vec3.normalize(avg, avg);\n\n        // 2. get yaw angle of polygon average point in sphere\n        const u = this.getNormalisedAngle(avg, this.up, this.right);\n\n        // 3. flip normal if using the inside of the tube\n        if (this.useInnerFaces) {\n            vec3.negate(avg, avg);\n        }\n\n        if (vec3.dot(avg, polygon.plane.unsafeNormal) <= 0 && this.ignoreBackFaces) {\n            return;\n        }\n\n        super.projectSingleWithExtraData(polygon, newMaterialID, attributeMaps, newUVsIdx, attributes, u >= 0.5);\n    }\n\n    private getNormalisedAngle(relPoint: vec3, direction: vec3, tangent: vec3) {\n        // get angle between tangent and point around tube direction\n        // theta = atan2((relPoint x tangent) . direction, relPoint . tangent)\n        vec3.cross(tv0, relPoint, tangent);\n        return Math.atan2(\n            vec3.dot(tv0, direction),\n            vec3.dot(relPoint, tangent)\n        ) / TAU + 0.5;\n    }\n\n    private getLatAngle(relPoint: vec3, direction: vec3) {\n        const dotProd = vec3.dot(relPoint, direction);\n        if(dotProd >= 0)\n            return 1 - Math.acos(dotProd) / Math.PI;\n        else\n            return Math.acos(-dotProd) / Math.PI;\n    }\n\n    applyMatrix(matrix: mat4): void {\n        vec3.transformMat4(this.origin, this.origin, matrix);\n        mat3.normalFromMat4(tmpm3, matrix);\n        vec3.transformMat3(this.up, this.up, tmpm3);\n        vec3.normalize(this.up, this.up);\n        vec3.transformMat3(this.right, this.right, tmpm3);\n        vec3.normalize(this.right, this.right);\n        vec3.transformMat3(this.front, this.front, tmpm3);\n        vec3.normalize(this.front, this.front);\n    }\n}", "import { DirectionalProjector } from './DirectionalProjector';\nimport { mat3, vec2, vec3 } from 'gl-matrix';\nimport { TAU } from '../math/const-numbers';\nimport { tmpm3, tv0, tv1, tv2 } from '../math/temp';\n\nimport type { AttributesMap } from './Projector';\nimport type { MaterialAttributes } from '../base/MaterialDefinition';\nimport type { Polygon } from '../math/Polygon';\nimport type { mat4 } from 'gl-matrix';\nimport type { TubeProjectorOptions } from './TubeProjector';\nimport type { CurveFrames } from '../helpers/curve-frame';\n\nfunction projectPointToLine(out: vec3, point: Readonly<vec3>, lineStart: Readonly<vec3>, lineEnd: Readonly<vec3>): number {\n    // m = out; x = point; a = start; b = end; ab = tv1; ax = tv2\n    // t = (ab . ax) / (ab . ab);\n    // m = a + t * ab\n    vec3.sub(tv1, lineEnd, lineStart);\n    vec3.sub(tv2, point, lineStart);\n    const t = vec3.dot(tv1, tv2) / vec3.dot(tv1, tv1);\n    vec3.scaleAndAdd(out, lineStart, tv1, t);\n\n    return t;\n}\n\ntype CurveTubeExtraData = [nearestPolygonSegmentIdx: number, uWrapsAround: boolean];\n\nexport interface CurveTubeProjectorOptions extends TubeProjectorOptions {\n    /**\n     * The segment index radius when re-checking the nearest segment to a point.\n     * If too large, then the projection will run very slowly and will have\n     * artifacts when the radii of the curve intersect. If 0, then there will be\n     * no artifacts because of curve radii, but the projection will be incorrect\n     * as the polygon midpoint will be used for the segment UV, instead of a\n     * vertex position. The sweet spot is a small value around 2-3. Defaults to\n     * 2.\n     */\n    checkRadius?: number;\n}\n\nexport class CurveTubeProjector extends DirectionalProjector<CurveTubeExtraData> {\n    protected length: number;\n    protected wrapAngle: number;\n    useInnerFaces: boolean;\n    invertTexCoords: boolean;\n    protected segmentLengthSums: Array<number>;\n    protected uMul: number;\n    checkRadius: number;\n\n    constructor(protected positions: Readonly<Array<vec3>>, protected curveFrames: Readonly<CurveFrames>, options?: CurveTubeProjectorOptions) {\n        super(options);\n\n        this.length = options?.length ?? 1;\n        this.wrapAngle = options?.wrapAngle ?? TAU;\n        this.uMul = TAU / this.wrapAngle;\n        this.useInnerFaces = options?.useInnerFaces ?? false;\n        this.invertTexCoords = options?.invertTexCoords ?? false;\n        this.checkRadius = options?.checkRadius ?? 2;\n\n        // pre-calculate segment length sums\n        const pointCount = positions.length;\n        this.segmentLengthSums = new Array(pointCount);\n        this.segmentLengthSums[0] = 0;\n        let lastSum = 0;\n\n        for (let i = 1; i < pointCount; i++) {\n            lastSum += vec3.distance(positions[i - 1], positions[i]);\n            this.segmentLengthSums[i] = lastSum;\n        }\n    }\n\n    override clone(): CurveTubeProjector {\n        return new CurveTubeProjector(\n            this.positions,\n            this.curveFrames,\n            {\n                length: this.length,\n                wrapAngle: this.wrapAngle,\n                useInnerFaces: this.useInnerFaces,\n                invertTexCoords: this.invertTexCoords,\n                ignoreBackFaces: this.ignoreBackFaces,\n                threshold: this.threshold,\n                generatesUVs: this.generatesUVs,\n            }\n        );\n    }\n\n    get needsInvertedTexCoords(): boolean {\n        // equivalent to: useInnerFaces XOR invertTexCoords\n        return this.useInnerFaces !== this.invertTexCoords;\n    }\n\n    protected override projectUV(position: vec3, extraData: CurveTubeExtraData): vec2 {\n        const [nearestPolygonSegmentIdx, uWrapsAround] = extraData;\n\n        // get nearest segment to vertex\n        const segmentCount = this.positions.length - 1;\n        const minSegIdx = Math.max(nearestPolygonSegmentIdx - this.checkRadius, 0);\n        const maxSegIdx = Math.min(nearestPolygonSegmentIdx + this.checkRadius, segmentCount);\n\n        let nearestSegmentIdx = Math.max(maxSegIdx - 1, minSegIdx);\n        const nearestPoint = vec3.clone(this.positions[nearestSegmentIdx + 1]);\n        let nearestDist = vec3.squaredDistance(nearestPoint, position);\n        let nearestT = 1;\n\n        for (let i = minSegIdx; i < maxSegIdx; i++) {\n            const a = this.positions[i];\n            const b = this.positions[i + 1];\n            const t = projectPointToLine(tv0, position, a, b);\n\n            if (t >= 0 && t <= 1) {\n                const thisDist = vec3.squaredDistance(tv0, position);\n\n                if (thisDist < nearestDist) {\n                    nearestSegmentIdx = i;\n                    vec3.copy(nearestPoint, tv0);\n                    nearestDist = thisDist;\n                    nearestT = t;\n                }\n            } else {\n                const thisDist = vec3.squaredDistance(a, position);\n\n                if (thisDist < nearestDist) {\n                    nearestSegmentIdx = i;\n                    vec3.copy(nearestPoint, a);\n                    nearestDist = thisDist;\n                    nearestT = 0;\n                }\n            }\n        }\n\n        // interpolate V from point in nearest segment\n        const thisSum = this.segmentLengthSums[nearestSegmentIdx];\n        const thisLength = this.segmentLengthSums[nearestSegmentIdx + 1] - thisSum;\n        const curLength = thisSum + thisLength * nearestT;\n        const v = curLength / this.length;\n\n        // get U by getting normal and binormal component. flip it if projection\n        // direction is outside to inside\n        let u = this.getUNorm(position, nearestPoint, nearestT, nearestSegmentIdx) / TAU + 0.5;\n\n        if (uWrapsAround && u < 0.25) {\n            u += 1;\n        } else if (!uWrapsAround && u > 0.75) {\n            u -= 1;\n        }\n\n        u *= this.uMul;\n\n        if (!this.needsInvertedTexCoords) {\n            u = 1 - u;\n        }\n\n        return vec2.fromValues(u, v);\n    }\n\n    private getUNorm(position: Readonly<vec3>, nearestPoint: Readonly<vec3>, nearestT: number, nearestSegmentIdx: number): number {\n        const dirToNear = vec3.sub(tv0, position, nearestPoint);\n        vec3.normalize(dirToNear, dirToNear);\n        const [normalA, binormalA, _tangentA] = this.curveFrames[nearestSegmentIdx];\n        const [normalB, binormalB, _tangentB] = this.curveFrames[nearestSegmentIdx + 1];\n        const normalT = vec3.lerp(tv1, normalA, normalB, nearestT);\n        const binormalT = vec3.lerp(tv2, binormalA, binormalB, nearestT);\n        const normalComp = vec3.dot(normalT, dirToNear);\n        const binormalComp = vec3.dot(binormalT, dirToNear);\n        return Math.atan2(normalComp, binormalComp);\n    }\n\n    protected override projectSingle(polygon: Polygon, newMaterialID: number, attributeMaps: AttributesMap, newUVsIdx: number | null, attributes: MaterialAttributes | null) {\n        // get nearest segment to polygon\n        const mid = polygon.midpoint;\n        const segmentCount = this.positions.length - 1;\n        let nearestSegmentIdx = segmentCount - 1;\n        const nearestPoint = vec3.clone(this.positions[segmentCount]);\n        let nearestDist = vec3.squaredDistance(nearestPoint, mid);\n        let nearestT = 1;\n\n        for (let i = 0; i < segmentCount; i++) {\n            const a = this.positions[i];\n            const b = this.positions[i + 1];\n            const t = projectPointToLine(tv0, mid, a, b);\n\n            if (t >= 0 && t <= 1) {\n                const thisDist = vec3.squaredDistance(tv0, mid);\n\n                if (thisDist < nearestDist) {\n                    nearestSegmentIdx = i;\n                    vec3.copy(nearestPoint, tv0);\n                    nearestDist = thisDist;\n                    nearestT = t;\n                }\n            } else {\n                const thisDist = vec3.squaredDistance(a, mid);\n\n                if (thisDist < nearestDist) {\n                    nearestSegmentIdx = i;\n                    vec3.copy(nearestPoint, a);\n                    nearestDist = thisDist;\n                    nearestT = 0;\n                }\n            }\n        }\n\n        // make sure that projection is going in the right direction if not\n        // bi-directional\n        if (this.ignoreBackFaces) {\n            const tubePerp = vec3.sub(tv1, mid, nearestPoint);\n\n            if (this.useInnerFaces) {\n                vec3.negate(tubePerp, tubePerp);\n            }\n\n            if (vec3.dot(tubePerp, polygon.plane.unsafeNormal) <= 0) {\n                return;\n            }\n        }\n\n        // check if polygon vertices' U values can wrap around\n        const uMid = this.getUNorm(mid, nearestPoint, nearestT, nearestSegmentIdx);\n        const uWrapsAround = uMid >= 0;\n\n        super.projectSingleWithExtraData(polygon, newMaterialID, attributeMaps, newUVsIdx, attributes, [nearestSegmentIdx, uWrapsAround]);\n    }\n\n    applyMatrix(matrix: mat4): void {\n        const posCount = this.positions.length;\n        const outPositions: Array<vec3> = new Array(posCount);\n        const outFrames: CurveFrames = new Array(posCount);\n\n        for (let i = 0; i < posCount; i++) {\n            const oPos = vec3.create();\n            vec3.transformMat4(oPos, this.positions[i], matrix);\n            outPositions[i] = oPos;\n\n            mat3.normalFromMat4(tmpm3, matrix);\n\n            const [r, s, t] = this.curveFrames[i];\n            const or = vec3.create();\n            vec3.transformMat3(or, r, tmpm3);\n            vec3.normalize(or, or);\n            const os = vec3.create();\n            vec3.transformMat3(os, s, tmpm3);\n            vec3.normalize(os, os);\n            const ot = vec3.create();\n            vec3.transformMat3(ot, t, tmpm3);\n            vec3.normalize(ot, ot);\n        }\n\n        this.positions = outPositions;\n        this.curveFrames = outFrames;\n    }\n}"],
  "mappings": "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",
  "names": ["JobFailReason", "JobError", "failReason", "originalError", "failMessage", "THIRD", "TAU", "HALF_PI", "mat3", "vec3", "_wV1", "_wV2", "_wV3", "_wP", "_wP_EPS_ARR", "_matrix3", "wNPI", "returnXYZ", "arr", "index", "calcWindingNumber_buffer", "trianglesArr", "point", "wN", "trianglesArrLen", "i", "lenA", "lenB", "lenC", "polyInside_WindingNumber_buffer", "coplanar", "_wP_EPS", "prepareTriangleBuffer", "polygons", "array", "bufferIndex", "polygon", "triangle", "vec2", "vec3", "_v1", "_v2", "_v3", "triangleIntersectsTriangle", "triangleA", "triangleB", "additionsIn", "additions", "p1", "q1", "r1", "p2", "q2", "r2", "N2", "dp1", "dq1", "dr1", "N1", "dp2", "dq2", "dr2", "tri_tri_intersection", "coplanar_tri_tri3d", "construct_intersection", "normal_1", "P1", "Q1", "R1", "P2", "Q2", "R2", "n_x", "n_y", "n_z", "tri_tri_overlap_test_2d", "ORIENT_2D", "ccw_tri_tri_intersection_2d", "b", "c", "intersection_test_edge", "intersection_test_vertex", "alpha", "N", "lineIntersects", "line1", "line2", "points", "r", "s", "q", "dotqr", "dotqs", "dotrs", "dotrr", "dotss", "denom", "t", "u", "p0", "onSegment", "intersects", "getLines", "triangle", "checkTrianglesIntersection", "triangle1", "triangle2", "triangle1Lines", "triangle2Lines", "i", "j", "vec3", "Triangle", "a", "b", "c", "source", "destination", "THIRD", "other", "k", "data", "seed", "h", "view", "key", "mat3", "mat4", "quat", "vec2", "vec3", "tv0", "tv1", "tv2", "tmpm3", "tmpm4_0", "tmpm4_1", "tv0_2", "tv1_2", "tq0", "vec3", "vec4", "Plane", "buffer", "normal", "w", "p", "a", "b", "c", "tv0", "tv1", "n", "mat3", "vec3", "MaterialAttributeValueType", "MaterialAttributeTransform", "MaterialAttributeStandardType", "_polygonID", "Polygon", "vertices", "shared", "_polygonID", "v", "Plane", "Triangle", "attributes", "matrix", "normalMatrix", "vec3", "materials", "normalMatrixIn", "propDef", "mat3", "tmpm3", "resetOriginal", "state", "keepState", "previousState", "polygon", "tmp", "vec3", "ReturnPolygonType", "COPLANAR", "FRONT", "BACK", "SPANNING", "splitPolygonByPlane", "polygon", "plane", "materials", "result", "attributes", "returnPolygon", "polygonType", "types", "vertex", "t", "type", "f", "b", "vertCount", "i", "j", "ti", "tj", "vi", "vj", "tv0", "v", "newPoly", "splitPolygonArr", "Polygon", "arr", "resultArr", "vec3", "edge1", "edge2", "h", "s", "q", "RAY_EPSILON", "rayIntersectsTriangle", "ray", "triangle", "target", "a", "f", "u", "v", "t", "vec3", "_tv1", "_tv2", "_tv3", "_bxNorm", "_byNorm", "_bzNorm", "_lub", "_rub", "_luf", "_ruf", "_ldb", "_rdb", "_ldf", "_rdf", "_ba", "_cb", "_ac", "canonMin", "x", "y", "canonMax", "Box3", "min", "max", "point", "scalar", "points", "normal", "count", "i", "dotProd", "boxAxisMin", "boxAxisMax", "vertices", "triEdge", "boxNormal", "triVerts", "boxVerts", "axis", "boxMin", "boxMax", "triMin", "triMax", "triangle", "triNorm", "Plane", "triOffset", "box", "ray", "tmax", "tmin", "output", "vec3", "Ray", "mat3", "vec3", "getVertexPropertyTypeSize", "propertyType", "encodePointDatum", "datum", "datumType", "view", "idx", "datumVec", "encodePoint", "point", "attributes", "idxExtra", "attribute", "getVertexPropertyTypeSize", "TriangleHasher", "triangle", "hash", "arr", "other", "CSG_Rules", "countExtraVertexBytes", "materials", "materialID", "extraBytes", "attributes", "attribute", "getVertexPropertyTypeSize", "vec2", "vec3", "vec4", "lerp", "b", "Vertex", "pos", "extra", "extraClone", "extraCount", "i", "val", "vec3", "attributes", "attribute", "vec2", "vec4", "matrix", "normalMatrix", "transformMode", "out", "other", "otherVal", "lerp", "vec2", "vec3", "vec4", "decodePointDatum", "datumType", "view", "idx", "x", "y", "z", "w", "decodePoint", "attributes", "pos", "extra", "attribute", "getVertexPropertyTypeSize", "Vertex", "incompPrefix", "attrProps", "assertAttributesMatch", "materialID", "first", "second", "attrCount", "i", "attrFirst", "attrSecond", "propName", "mergeTwoMaterials", "equal", "attributes", "otherAttributes", "merged", "_v1", "vec3", "_v2", "_v3", "_ray", "Ray", "_rayDirection", "uint32Max", "__pow", "defaultUseWindingNumber", "defaultBatchSize", "defaultMaxLevel", "defaultPolygonsPerTree", "_a", "_OctreeCSG", "materials", "box", "parent", "source", "p", "subTree", "array", "index", "polygon", "triangleHasher", "triangle", "Box3", "treeMid", "point", "level", "maxLevel", "polygonsPerTree", "subTrees", "halfsize", "x", "y", "z", "v", "kept", "origIdx", "candidSubTree", "candidBox", "a", "b", "c", "nextLevel", "polygons", "firstVertex", "targetPolygon", "handlePolygonArrayIntersections", "ray", "replacedPolygon", "intersects", "result", "rayIntersectsTriangle", "distance", "raycastIntersectAscSort", "curInt", "thisIntersection", "intSubTrees", "intCount", "tv0", "i", "_distance", "intersection", "polygonsArray", "newPolygons", "polygonIndex", "rulesArr", "firstRun", "found", "rule", "states", "missingStates", "state", "previousState", "targetOctree", "resetOriginal", "useWindingNumber", "targetOctreeBuffer", "polygonStack", "currentPolygon", "targetPolygons", "target", "splitResults", "splitPolygonByPlane", "singleResult", "ReturnPolygonType", "inside", "polyInside_WindingNumber_buffer", "closestInt", "_wP_EPS", "_wP_EPS_ARR", "deletePolygons", "octreeOffsets", "octreePolygonCounts", "octreeSectionOffsets", "bytesCount", "polygonCounts", "materialID", "polygonCount", "sectionOffsets", "extraBytes", "countExtraVertexBytes", "subTreeCount", "view", "octreeOffset", "sectionCount", "hasBox", "flags", "encodePointDatum", "sectionStart", "offset", "attributes", "encodePoint", "transferables", "buffer", "byteOffset", "byteLength", "octree", "sectionsCount", "hasSubTrees", "min", "decodePointDatum", "max", "vertexBytes", "sectionBytes", "sectionEnd", "decodePoint", "Polygon", "_byteOffset", "cbFunc", "matrix", "normalMatrix", "needsNormalMatrix", "attribute", "mat3", "tmpm3", "triangles", "octreeA", "octreeB", "options", "newMatDefs", "mergeTwoMaterials", "TriangleHasher", "CSG_Rules", "objArr", "arrayOperation", "objArrCount", "obj", "resultOctree", "handleObjectForOp", "disposeOctree", "octrees", "octreeObj", "bothOctrees", "octreeA_buffer", "octreeB_buffer", "prepareTriangleBuffer", "OctreeCSG", "mergedMatDef", "asyncOperation", "asyncArrayOperation", "__async", "resolve", "reject", "promises", "handleObjectForOp_async", "results", "csg", "objIndex", "resultPromise", "e", "promise", "returnObj", "outputPolygons", "checkTrianglesIntersection", "callback", "octreesArray", "octreeCount", "nextOctreeArray", "op", "syncCallback", "error", "rethrow", "JobError", "singleCallback", "arrayCallback", "batchSize", "usingBatches", "mainOctree", "mainOctreeUsed", "batches", "currentIndex", "batch", "objArrLen", "leftOverOctree", "octreesArrayLen", "innerResult", "encodeOctreeCSGObject", "obj", "materials", "transferables", "encodeOctreeCSGObjectOrCSG", "encodedObjs", "octreeObj", "OctreeCSG", "Job", "operation", "options", "resolveCallback", "rejectCallback", "workerIndex", "jobIndex", "buffer", "JobError", "error", "JOB_REG_MSG", "WARN_START", "OctreeCSGJobDispatcher", "workers", "workerPath", "timeoutMS", "name", "resolve", "reject", "timeout", "worker", "message", "workerIndex", "workerCount", "workersDone", "i", "reason", "actualWorkerCount", "dispatcher", "event", "jobIndex", "job", "JobError", "minWorkerIndex", "minJobCount", "jobCount", "operation", "materials", "options", "Job", "__async", "jobDispatcher", "e", "vec3", "mat4", "quat", "vertexNormal", "CSGPrimitiveMaterialAttributes", "CSGPrimitiveMaterialAttributes_default", "CSGPrimitive", "OctreeCSG", "box", "triangleVertices", "options", "_a", "vertexCount", "materialID", "materials", "CSGPrimitiveMaterialAttributes_default", "i", "polygon", "Polygon", "outputMatrix", "matrix", "mat4", "rotation", "xDeg", "yDeg", "zDeg", "quat", "tmpMat", "addSquare", "vertices", "index", "a", "b", "c", "d", "normal", "Vertex", "vec3", "Cuboid", "CSGPrimitive", "xLength", "yLength", "zLength", "options", "max", "min", "luf", "ruf", "lub", "rub", "ldf", "rdf", "ldb", "rdb", "Box3", "Cube", "Cuboid", "length", "options", "vec3", "spherifyFace", "spherifyPoint", "index", "subDivs", "radius", "vertices", "origin", "right", "up", "i", "ip", "inp", "j", "jp", "jnp", "a", "aNorm", "b", "bNorm", "c", "cNorm", "d", "dNorm", "Vertex", "vec3", "CubeSphere", "CSGPrimitive", "diameter", "options", "_a", "vertexCount", "max", "min", "Box3", "vec3", "spherifyPoint", "ip", "jp", "radius", "origin", "right", "up", "vec3", "tv0", "tv1", "normal", "THIRD", "Sphere", "CubeSphere", "diameter", "options", "vec3", "spherifyPoint", "ip", "jp", "radius", "origin", "right", "up", "vec3", "tv0", "normal", "UVSphere", "CubeSphere", "diameter", "options", "vec3", "vec3", "vec3", "triangulateConvexPolygon", "vertices", "flip", "output", "startIndex", "vertexCount", "indices", "_", "aIdx", "bIdx", "a", "b", "i", "idxLow", "idxMid", "idxHigh", "makeCircularBase", "vertices", "xzn", "y", "normal", "index", "flip", "segments", "polyline", "i", "Vertex", "vec3", "triangulateConvexPolygon", "precalcCircularBase", "subDivs", "radius", "generateNormals", "angle", "TAU", "dx", "dz", "Cylinder", "CSGPrimitive", "diameter", "length", "options", "_a", "subDivs", "vertexCount", "vertices", "radius", "halfLength", "xzn", "precalcCircularBase", "index", "makeCircularBase", "vec3", "i", "x1", "z1", "normal1", "x2", "z2", "normal2", "Vertex", "max", "min", "Box3", "vec3", "BaseCone", "CSGPrimitive", "baseVertices", "smoothNormals", "diameter", "length", "options", "vertexCount", "vertices", "radius", "halfLength", "tip", "vec3", "xzn", "precalcCircularBase", "angle", "xNormMul", "yNormVal", "i", "normal", "index", "makeCircularBase", "xzn1", "xzn2", "x1", "z1", "x2", "z2", "a", "b", "c", "an", "bn", "cn", "Plane", "Vertex", "max", "min", "Box3", "Cone", "BaseCone", "diameter", "length", "options", "_a", "Pyramid", "BaseCone", "sides", "diameter", "length", "options", "vec3", "vec3", "ICO_V", "makeIcosahedronTriangles", "addTriangle", "vertices", "radius", "index", "addTriangle", "vertices", "index", "radius", "a", "b", "c", "normal", "Plane", "Vertex", "vec3", "Icosahedron", "CSGPrimitive", "diameter", "options", "max", "min", "makeIcosahedronTriangles", "Box3", "vec3", "addTriangle", "depth", "vertices", "index", "radius", "a", "b", "c", "Vertex", "vec3", "abm", "bcm", "cam", "nextDepth", "Icosphere", "CSGPrimitive", "diameter", "options", "_a", "max", "min", "subDivs", "__pow", "makeIcosahedronTriangles", "Box3", "mat4", "quat", "vec3", "Torus", "CSGPrimitive", "outerDiameter", "innerDiameter", "options", "_a", "_b", "radSubDivs", "tubSubDivs", "outerRadius", "innerRadius", "tubeRadius", "max", "vec3", "min", "tubularSegments", "i", "radialSegments", "tubeRot", "quat", "tv0", "mat4", "tmpm4_0", "tmpm4_1", "j", "angle", "TAU", "x", "y", "pos", "normal", "vertices", "index", "segment1", "segment2", "jNext", "pos11", "normal11", "pos21", "normal21", "pos12", "normal12", "pos22", "normal22", "Vertex", "Box3", "mat3", "mat4", "vec2", "vec3", "isClockwise2DPolygon", "polyline", "sum", "vertCount", "last", "next", "sort2DIndices", "polyline", "indices", "_", "i", "aIdx", "bIdx", "a", "b", "getPolygonInLoop", "indices", "start", "end", "indexCount", "output", "i", "actualIndex", "splitPolygonTo", "polyline", "diagonals", "flip", "aIndices", "bIndices", "aDiags", "bDiags", "diagonalCount", "oStart", "oEnd", "outPolyline", "split2DPolygon", "_", "isAbove", "p", "q", "interiorAngle", "prev", "cur", "next", "prevAngle", "TAU", "getLeftEdge", "polyline", "status", "vertexCount", "vertex", "leftEdge", "leftY", "lineStartIndex", "lineEndIndex", "lineStart", "lineEnd", "lineMin", "lineMax", "m", "c", "y", "partition2DPolygon", "output", "isClockwiseHint", "isClockwise2DPolygon", "helpers", "types", "diagonals", "index", "sort2DIndices", "prevIndex", "nextIndex", "prevVertex", "nextVertex", "abovePrev", "aboveNext", "prevHelper", "leftHelper", "split2DPolygon", "vec2", "isClockwise2DTriangle", "b", "c", "addTriangle", "output", "index", "clockwise", "a", "b", "c", "isClockwise2DTriangle", "isInInterval", "start", "end", "triangulateMonotone2DPolygon", "polyline", "isClockwiseHint", "vertexCount", "outputSize", "vec2", "isClockwise2DPolygon", "indices", "sort2DIndices", "secondChainStart", "secondChainEnd", "stack", "i", "thisIndex", "thisVertex", "stackLen", "topIndex", "topVertex", "j", "lastPoppedVertex", "lastPoppedIndex", "lastDelta", "tv1_2", "nextPoppedIndex", "nextPoppedVertex", "delta", "tv0_2", "lastVertex", "iterLen", "triangulate2DPolygon", "polyline", "output", "isClockwiseHint", "isClockwise2DPolygon", "partitions", "partition2DPolygon", "outputSize", "partition", "index", "triangulateMonotone2DPolygon", "makeSlice", "output", "outputMat", "polyline", "position", "s", "t", "mat4", "sliceVerts", "i", "outputVec", "vec2", "vec3", "makeBase", "octree", "triangulatedBase", "mat", "baseTriVerts", "flip", "a", "b", "normal", "Plane", "aVert", "Vertex", "bVert", "cVert", "polygon", "Polygon", "curveExtrude", "positions", "frames", "options", "_a", "_b", "_c", "pointCount", "materialID", "materials", "CSGPrimitiveMaterialAttributes_default", "OctreeCSG", "sliceVertices", "lastSlice", "curSlice", "lastMat", "lastMatNormal", "mat3", "curMat", "curMatNormal", "edgeNormals", "tv0", "j", "iXY", "jXY", "smoothNormals", "vertexNormals", "includeBases", "triangulate2DPolygon", "lastSegment", "k", "lastNormalA", "lastNormalB", "curNormalA", "curNormalB", "jNorm", "kNorm", "norm", "lastA", "lastB", "curA", "curB", "polygonA", "polygonB", "linearExtrude", "polyline", "depth", "options", "positions", "forwardFrame", "curveExtrude", "quat", "vec3", "makeRotationMinimizingFrames", "positions", "tangents", "startNormal", "options", "_a", "pointCount", "frames", "startTangent", "startBinormal", "vec3", "i", "v_1", "tv0", "c_1", "r_i", "t_i", "temp", "r_L_i", "tv1", "t_L_i", "tv2", "t_i1", "v_2", "c_2", "r_i1", "s_i1", "endNormal", "twists", "angleErr", "endTangent", "endBinormal", "actualNormal", "dx", "dy", "HALF_PI", "TAU", "totalLength", "lastPos", "curPos", "interpLength", "r", "s", "_t", "thisAngleErr", "quat", "tq0", "rotationMinimizingCurveExtrude", "polyline", "positions", "tangents", "startNormal", "options", "curveExtrude", "makeRotationMinimizingFrames", "vec2", "makeRegularPolyline", "radius", "sides", "clockwise", "polyline", "sidesM1", "i", "j", "angle", "TAU", "y", "x", "vec2", "makeCirclePolyline", "radius", "clockwise", "subDivisions", "makeRegularPolyline", "vec2", "makeCubePolyline", "length", "clockwise", "half", "vec2", "makeRectanglePolyline", "width", "height", "clockwise", "halfWidth", "halfHeight", "vec2", "makeStarPolyline", "outerRadius", "innerRadius", "sides", "clockwise", "polyline", "sidesM1", "halfAngle", "TAU", "k", "i", "j", "outerAngle", "outerY", "outerX", "outerPos", "vec2", "innerAngle", "innerY", "innerX", "innerPos", "vec2", "Projector", "options", "_a", "polygon", "condition", "vertex", "attributeMap", "newUVsIdx", "attributes", "extraPolygonData", "curExtra", "aIdx", "bIdx", "u", "v", "vec2", "newMaterialID", "attributeMaps", "materialMap", "newUVsMap", "materials", "_b", "a", "b", "bAttributes", "aAttributes", "bAttributesLeft", "extraIDsMap", "aAttribute", "attrMissing", "bAttribute", "missing", "octree", "subTree", "extraMaterials", "materialID", "extraAttributes", "source", "destination", "attrs", "polygons", "DirectionalProjector", "Projector", "options", "_a", "_b", "mat3", "vec2", "vec3", "FlatProjector", "DirectionalProjector", "origin", "normal", "rightTangent", "options", "_a", "_b", "vec3", "uOffset", "vOffset", "position", "tv0", "tempDot", "vec2", "polygon", "newMaterialID", "attributeMaps", "newUVsIdx", "attributes", "dotProd", "matrix", "mat3", "tmpm3", "mat3", "vec2", "vec3", "TubeProjector", "DirectionalProjector", "origin", "direction", "normal", "options", "_a", "_b", "_c", "_d", "vec3", "TAU", "position", "uWrapsAround", "tv1", "v", "tubeDotPos", "tv2", "tv0", "u", "vec2", "polygon", "newMaterialID", "attributeMaps", "newUVsIdx", "attributes", "mid", "tubePerp", "matrix", "mat3", "tmpm3", "mat3", "vec2", "vec3", "SphereProjector", "DirectionalProjector", "origin", "up", "right", "options", "_a", "_b", "_c", "vec3", "TAU", "position", "uWrapsAround", "tv1", "u", "v", "vec2", "polygon", "newMaterialID", "attributeMaps", "newUVsIdx", "attributes", "tv0", "vertex", "avg", "relPoint", "direction", "tangent", "dotProd", "matrix", "mat3", "tmpm3", "mat3", "vec2", "vec3", "projectPointToLine", "out", "point", "lineStart", "lineEnd", "vec3", "tv1", "tv2", "t", "CurveTubeProjector", "DirectionalProjector", "positions", "curveFrames", "options", "_a", "_b", "_c", "_d", "_e", "TAU", "pointCount", "lastSum", "i", "position", "extraData", "nearestPolygonSegmentIdx", "uWrapsAround", "segmentCount", "minSegIdx", "maxSegIdx", "nearestSegmentIdx", "nearestPoint", "nearestDist", "nearestT", "a", "b", "tv0", "thisDist", "thisSum", "thisLength", "v", "u", "vec2", "dirToNear", "normalA", "binormalA", "_tangentA", "normalB", "binormalB", "_tangentB", "normalT", "binormalT", "normalComp", "binormalComp", "polygon", "newMaterialID", "attributeMaps", "newUVsIdx", "attributes", "mid", "tubePerp", "matrix", "posCount", "outPositions", "outFrames", "oPos", "mat3", "tmpm3", "r", "s", "or", "os", "ot"]
}
